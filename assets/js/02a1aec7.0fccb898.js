"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9763],{15680:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>s,MDXProvider:()=>u,mdx:()=>x,useMDXComponents:()=>p,withMDXComponents:()=>r});var t=a(96540);function l(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},o.apply(this,arguments)}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function d(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){l(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function m(e,n){if(null==e)return{};var a,t,l=function(e,n){if(null==e)return{};var a,t,l={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(l[a]=e[a]);return l}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=t.createContext({}),r=function(e){return function(n){var a=p(n.components);return t.createElement(e,o({},n,{components:a}))}},p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):d(d({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,l=e.mdxType,o=e.originalType,i=e.parentName,s=m(e,["components","mdxType","originalType","parentName"]),r=p(a),u=l,h=r["".concat(i,".").concat(u)]||r[u]||c[u]||o;return a?t.createElement(h,d(d({ref:n},s),{},{components:a})):t.createElement(h,d({ref:n},s))}));function x(e,n){var a=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var o=a.length,i=new Array(o);i[0]=h;var d={};for(var m in n)hasOwnProperty.call(n,m)&&(d[m]=n[m]);d.originalType=e,d.mdxType="string"==typeof e?e:l,i[1]=d;for(var s=2;s<o;s++)i[s]=a[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},75181:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>h,frontMatter:()=>m,metadata:()=>r,toc:()=>u});var t=a(9668),l=a(21367),o=(a(96540),a(15680)),i=a(52112),d=["components"],m={id:"pysa-model-dsl",title:"Model Domain Specific Language (DSL)",sidebar_label:"Model DSL"},s=void 0,r={unversionedId:"pysa-model-dsl",id:"pysa-model-dsl",title:"Model Domain Specific Language (DSL)",description:"We have started developing a model Domain Specific Language (DSL) that can be",source:"@site/docs/pysa_model_dsl.md",sourceDirName:".",slug:"/pysa-model-dsl",permalink:"/docs/pysa-model-dsl",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/pysa_model_dsl.md",tags:[],version:"current",frontMatter:{id:"pysa-model-dsl",title:"Model Domain Specific Language (DSL)",sidebar_label:"Model DSL"},sidebar:"pysa",previous:{title:"Dynamically Generating Models",permalink:"/docs/pysa-model-generators"},next:{title:"User Docs",permalink:"/docs/category/user-docs"}},p={},u=[{value:"Basics",id:"basics",level:2},{value:"Name clauses",id:"name-clauses",level:2},{value:"Find clauses",id:"find-clauses",level:2},{value:"Where clauses",id:"where-clauses",level:2},{value:"<code>fully_qualified_name.matches</code>",id:"fully_qualified_namematches",level:3},{value:"<code>fully_qualified_name.equals</code>",id:"fully_qualified_nameequals",level:3},{value:"<code>name.matches</code>",id:"namematches",level:3},{value:"<code>name.equals</code>",id:"nameequals",level:3},{value:"<code>return_annotation</code> clauses",id:"return_annotation-clauses",level:3},{value:"<code>return_annotation.equals</code>",id:"return_annotationequals",level:4},{value:"<code>return_annotation.matches</code>",id:"return_annotationmatches",level:4},{value:"<code>return_annotation.is_annotated_type</code>",id:"return_annotationis_annotated_type",level:4},{value:"<code>return_annotation.extends</code>",id:"return_annotationextends",level:4},{value:"<code>type_annotation</code> clauses",id:"type_annotation-clauses",level:3},{value:"<code>type_annotation.equals</code>",id:"type_annotationequals",level:4},{value:"<code>type_annotation.matches</code>",id:"type_annotationmatches",level:4},{value:"<code>type_annotation.is_annotated_type</code>",id:"type_annotationis_annotated_type",level:4},{value:"<code>type_annotation.extends</code>",id:"type_annotationextends",level:4},{value:"<code>any_parameter</code> clauses",id:"any_parameter-clauses",level:3},{value:"<code>any_parameter.annotation.equals</code>",id:"any_parameterannotationequals",level:4},{value:"<code>any_parameter.annotation.matches</code>",id:"any_parameterannotationmatches",level:4},{value:"<code>any_parameter.annotation.is_annotated_type</code>",id:"any_parameterannotationis_annotated_type",level:4},{value:"<code>AnyOf</code> clauses",id:"anyof-clauses",level:3},{value:"<code>AllOf</code> clauses",id:"allof-clauses",level:3},{value:"<code>Decorator</code> clauses",id:"decorator-clauses",level:3},{value:"Decorator <code>fully_qualified_callee</code> clauses",id:"decorator-fully_qualified_callee-clauses",level:4},{value:"Decorator <code>name</code> clauses",id:"decorator-name-clauses",level:4},{value:"Decorator <code>arguments</code> clauses",id:"decorator-arguments-clauses",level:4},{value:"Decorator <code>Not</code>, <code>AllOf</code> and <code>AnyOf</code> clauses",id:"decorator-not-allof-and-anyof-clauses",level:4},{value:"<code>cls.fully_qualified_name.equals</code> clause",id:"clsfully_qualified_nameequals-clause",level:3},{value:"<code>cls.fully_qualified_name.matches</code> clause",id:"clsfully_qualified_namematches-clause",level:3},{value:"<code>cls.name.matches</code> clause",id:"clsnamematches-clause",level:3},{value:"<code>cls.name.equals</code> clause",id:"clsnameequals-clause",level:3},{value:"<code>cls.extends</code> clause",id:"clsextends-clause",level:3},{value:"<code>cls.decorator</code> clause",id:"clsdecorator-clause",level:3},{value:"<code>cls.any_child</code> clause",id:"clsany_child-clause",level:3},{value:"<code>cls.any_parent</code> clause",id:"clsany_parent-clause",level:3},{value:"<code>any_overriden_method</code> clause",id:"any_overriden_method-clause",level:3},{value:"<code>Not</code> clauses",id:"not-clauses",level:3},{value:"Generated models (Model clauses)",id:"generated-models-model-clauses",level:2},{value:"Returned taint",id:"returned-taint",level:3},{value:"Parameter taint",id:"parameter-taint",level:3},{value:"<code>name</code> clauses",id:"name-clauses-1",level:4},{value:"<code>index</code> clause",id:"index-clause",level:4},{value:"<code>has_position</code> clause",id:"has_position-clause",level:4},{value:"<code>has_name</code> clause",id:"has_name-clause",level:4},{value:"<code>type_annotation</code> clause",id:"type_annotation-clause",level:4},{value:"<code>Not</code>, <code>AllOf</code> and <code>AnyOf</code> clauses",id:"not-allof-and-anyof-clauses",level:4},{value:"Using <code>ViaTypeOf</code> with the <code>Parameters</code> clause",id:"using-viatypeof-with-the-parameters-clause",level:4},{value:"Models for attributes",id:"models-for-attributes",level:3},{value:"Using <code>ViaAttributeName</code> with the <code>AttributeModel</code> clause",id:"using-viaattributename-with-the-attributemodel-clause",level:4},{value:"Models for globals",id:"models-for-globals",level:3},{value:"Models for setting modes",id:"models-for-setting-modes",level:3},{value:"Expected and Unexpected Models clauses",id:"expected-and-unexpected-models-clauses",level:2},{value:"Cache Queries",id:"cache-queries",level:2},{value:"WriteToCache clause",id:"writetocache-clause",level:3},{value:"read_from_cache clause",id:"read_from_cache-clause",level:3},{value:"Format strings",id:"format-strings",level:2},{value:"Regular expression capture",id:"regular-expression-capture",level:3},{value:"Logging group clauses",id:"logging-group-clauses",level:2}],c={toc:u};function h(e){var n=e.components,a=(0,l.A)(e,d);return(0,o.mdx)("wrapper",(0,t.A)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"We have started developing a model Domain Specific Language (DSL) that can be\nused to solve many of the same problems as\n",(0,o.mdx)("a",{parentName:"p",href:"/docs/pysa-model-generators"},"model generators"),", while still keeping model information\nin ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files. The DSL aims to provide a compact way to generate models for\nall code that matches a given query. This allows users to avoid writing hundreds\nor thousands of models."),(0,o.mdx)("h2",{id:"basics"},"Basics"),(0,o.mdx)("p",null,"The most basic form of querying Pysa's DSL is by generating models based on\nfunction names. To do so, add a ",(0,o.mdx)("inlineCode",{parentName:"p"},"ModelQuery")," to your ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  # Indicates the name of the query\n  name = "get_foo_sources",\n  # Indicates that this query is looking for functions\n  find = "functions",\n  # Indicates those functions should be called \'foo\'\n  where = [name.matches("foo")],\n  # Indicates that matched function should be modeled as returning \'Test\' taint\n  model = [\n    Returns(TaintSource[Test]),\n  ],\n  # Indicates that the generated models should include the \'foo\' and \'foo2\' functions\n  expected_models = [\n    "def file.foo() -> TaintSource[Test]: ...",\n    "def file.foo2() -> TaintSource[Test]: ..."\n  ],\n  # Indicates that the generated models should not include the \'bar\' function\n  unexpected_models = [\n    "def file.bar() -> TaintSource[Test]: ..."\n  ]\n)\n')),(0,o.mdx)("p",null,"Things to note in this example:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"name")," clause is the name of your query."),(0,o.mdx)("li",{parentName:"ol"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"find")," clause lets you pick whether you want to model functions, methods\nor attributes."),(0,o.mdx)("li",{parentName:"ol"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"where")," clause is how you refine your criteria for when a model should be\ngenerated - in this example, we're filtering for functions whose names\ncontain ",(0,o.mdx)("inlineCode",{parentName:"li"},"foo"),"."),(0,o.mdx)("li",{parentName:"ol"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"model")," clause is a list of models to generate. Here, the syntax means\nthat the functions matching the where clause should be modelled as returning\n",(0,o.mdx)("inlineCode",{parentName:"li"},"TaintSource[Test]"),"."),(0,o.mdx)("li",{parentName:"ol"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"expected_models")," and ",(0,o.mdx)("inlineCode",{parentName:"li"},"unexpected_models")," clauses are optional and allow\nyou to specify models that should or should not be generated by your query.")),(0,o.mdx)("p",null,"When invoking Pysa, if you add the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"--dump-model-query-results /path/to/output/file")," flag to your invocation, the\ngenerated models, sorted under the respective ModelQuery that created them, will\nbe written to a file in JSON format."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre analyze --dump-model-query-results /path/to/output/file.txt\n...\n> Emitting the model query results to `/my/home/dir/.pyre/model_query_results.pysa`\n")),(0,o.mdx)("p",null,"You can then view this file to see the generated models."),(0,o.mdx)("p",null,"You can also test DSL queries using\n",(0,o.mdx)("a",{parentName:"p",href:"/docs/querying-pyre#model-query"},(0,o.mdx)("inlineCode",{parentName:"a"},"pyre query")),"."),(0,o.mdx)(i.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,o.mdx)("p",null,"Example"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-bash"},"pyre query \"model_query('/data/sandcastle/boxes/instagram-server/distillery/stubs/taint/core_privacy_security/','model_query_name')\" > /tmp/model_query_output\ncat /tmp/model_query_output | jq .\n"))),(0,o.mdx)("h2",{id:"name-clauses"},"Name clauses"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"name")," clause describes what the query is meant to find. Normally it follows\nthe format of ",(0,o.mdx)("inlineCode",{parentName:"p"},"get_")," + ","[what the query matches with in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"where")," clause]"," +\n","[",(0,o.mdx)("inlineCode",{parentName:"p"},"_sinks"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"_source")," and/or ",(0,o.mdx)("inlineCode",{parentName:"p"},"_tito"),"]",". This clause should be unique for every\nModelQuery within a file."),(0,o.mdx)("h2",{id:"find-clauses"},"Find clauses"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"find")," clause specifies what entities to model, and currently supports\n",(0,o.mdx)("inlineCode",{parentName:"p"},'"functions"'),", ",(0,o.mdx)("inlineCode",{parentName:"p"},'"methods"'),", ",(0,o.mdx)("inlineCode",{parentName:"p"},'"attributes"'),", and ",(0,o.mdx)("inlineCode",{parentName:"p"},'"globals"'),". ",(0,o.mdx)("inlineCode",{parentName:"p"},'"functions"'),"\nindicates that you're querying for free functions, ",(0,o.mdx)("inlineCode",{parentName:"p"},'"methods"')," indicates that\nyou're only querying class methods, ",(0,o.mdx)("inlineCode",{parentName:"p"},'"attributes"')," indicates that you're\nquerying for attributes on classes, and ",(0,o.mdx)("inlineCode",{parentName:"p"},'"globals"')," indicates that you're\nquerying for names available in the global scope."),(0,o.mdx)("p",null,"Note that ",(0,o.mdx)("inlineCode",{parentName:"p"},'"attributes"')," also includes constructor-initialized attributes, such\nas ",(0,o.mdx)("inlineCode",{parentName:"p"},"C.y")," in the following case:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class C:\n  x = ...\n\n  def __init__(self):\n    self.y = ...\n")),(0,o.mdx)("p",null,"Note that ",(0,o.mdx)("inlineCode",{parentName:"p"},'"globals"')," currently don't infer the type annotation of their value,\nso querying is more effective when they're properly annotated."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def fun(x: int, y: str) -> int:\n    return x + int(y)\n\na = fun(1, "2") # -> typing.Any\nb: int = fun(1, "2") # -> int\n')),(0,o.mdx)("h2",{id:"where-clauses"},"Where clauses"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"where")," clauses are a list of predicates, all of which must match for an entity\nto be modelled. Note that certain predicates are only compatible with specific\nfind clause kinds."),(0,o.mdx)("h3",{id:"fully_qualified_namematches"},(0,o.mdx)("inlineCode",{parentName:"h3"},"fully_qualified_name.matches")),(0,o.mdx)("p",null,"The most basic query predicate is a name match - the name you're searching for\nis compiled as a regex, and the entity's fully qualified name is compared\nagainst it. A fully qualified name includes the module and class - for example,\nfor a method ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo")," in class ",(0,o.mdx)("inlineCode",{parentName:"p"},"C")," which is part of module ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar"),", the fully\nqualified name is ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar.C.foo"),"."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_starting_with_foo",\n  find = ...,\n  where = [\n    fully_qualified_name.matches("foo.*")\n  ],\n  model = ...\n)\n')),(0,o.mdx)("admonition",{type:"caution"},(0,o.mdx)("p",{parentName:"admonition"},(0,o.mdx)("inlineCode",{parentName:"p"},"matches")," performs a partial match! For instance, ",(0,o.mdx)("inlineCode",{parentName:"p"},'matches("bar")')," will match\nagainst a function named ",(0,o.mdx)("inlineCode",{parentName:"p"},"my_module.foobarbaz"),". To perform a full match, use ",(0,o.mdx)("inlineCode",{parentName:"p"},"^"),"\nand ",(0,o.mdx)("inlineCode",{parentName:"p"},"$"),". For instance: ",(0,o.mdx)("inlineCode",{parentName:"p"},'matches("^.*\\.bar$")'),".")),(0,o.mdx)("h3",{id:"fully_qualified_nameequals"},(0,o.mdx)("inlineCode",{parentName:"h3"},"fully_qualified_name.equals")),(0,o.mdx)("p",null,"This clause will match when the entity's fully qualified name is exactly the\nsame as the specified string."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_bar_C_foo",\n  find = ...,\n  where = [\n    fully_qualified_name.equals("bar.C.foo")\n  ],\n  model = ...\n)\n')),(0,o.mdx)("h3",{id:"namematches"},(0,o.mdx)("inlineCode",{parentName:"h3"},"name.matches")),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"name.matches")," clause is similar to ",(0,o.mdx)("inlineCode",{parentName:"p"},"fully_qualified_name.matches"),", but\nmatches against the actual name of the entity, excluding module and class names."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_starting_with_foo",\n  find = ...,\n  where = [\n    name.matches("foo.*")\n  ],\n  model = ...\n)\n')),(0,o.mdx)("admonition",{type:"caution"},(0,o.mdx)("p",{parentName:"admonition"},(0,o.mdx)("inlineCode",{parentName:"p"},"matches")," performs a partial match! For instance, ",(0,o.mdx)("inlineCode",{parentName:"p"},'matches("bar")')," will match\nagainst a function named ",(0,o.mdx)("inlineCode",{parentName:"p"},"foobarbaz"),". To perform a full match, use ",(0,o.mdx)("inlineCode",{parentName:"p"},"^")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"$"),".\nFor instance: ",(0,o.mdx)("inlineCode",{parentName:"p"},'matches("^.*bar$")'),".")),(0,o.mdx)("h3",{id:"nameequals"},(0,o.mdx)("inlineCode",{parentName:"h3"},"name.equals")),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"name.equals")," clause is similar to ",(0,o.mdx)("inlineCode",{parentName:"p"},"fully_qualified_name.equals"),", but\nmatches against the actual name of the entity, excluding module and class names."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_foo",\n  find = ...,\n  where = [\n    name.equals("foo")\n  ],\n  model = ...\n)\n')),(0,o.mdx)("h3",{id:"return_annotation-clauses"},(0,o.mdx)("inlineCode",{parentName:"h3"},"return_annotation")," clauses"),(0,o.mdx)("p",null,"Model queries allow for querying based on the return annotation of a callable.\nNote that this ",(0,o.mdx)("inlineCode",{parentName:"p"},"where")," clause does not work when the ",(0,o.mdx)("inlineCode",{parentName:"p"},"find")," clause specifies\n",(0,o.mdx)("inlineCode",{parentName:"p"},'"attributes"'),"."),(0,o.mdx)("h4",{id:"return_annotationequals"},(0,o.mdx)("inlineCode",{parentName:"h4"},"return_annotation.equals")),(0,o.mdx)("p",null,"The clause will match when the fully-qualified name of the callable's return\ntype matches the specified value exactly."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_return_HttpRequest_sources",\n  find = "functions",\n  where = [\n    return_annotation.equals("django.http.HttpRequest"),\n  ],\n  model = Returns(TaintSource[UserControlled, Via[http_request]])\n)\n')),(0,o.mdx)("h4",{id:"return_annotationmatches"},(0,o.mdx)("inlineCode",{parentName:"h4"},"return_annotation.matches")),(0,o.mdx)("p",null,"This is similar to the previous clause, but will match when the fully-qualified\nname of the callable's return type matches the specified pattern."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_return_Request_sources",\n  find = "methods",\n  where = [\n    return_annotation.matches(".*Request"),\n  ],\n  model = Returns(TaintSource[UserControlled, Via[http_request]])\n)\n')),(0,o.mdx)("h4",{id:"return_annotationis_annotated_type"},(0,o.mdx)("inlineCode",{parentName:"h4"},"return_annotation.is_annotated_type")),(0,o.mdx)("p",null,"This will match when a callable's return type is annotated with\n",(0,o.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/library/typing.html#typing.Annotated"},(0,o.mdx)("inlineCode",{parentName:"a"},"typing.Annotated")),".\nThis is a type used to decorate existing types with context-specific metadata,\ne.g."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Annotated\n\ndef bad() -> Annotated[str, "SQL"]:\n  ...\n')),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_return_annotated_sources",\n  find = functions,\n  where = [\n    return_annotation.is_annotated_type(),\n  ],\n  model = Returns(TaintSource[SQL])\n)\n')),(0,o.mdx)("p",null,"This query would match on functions like the one shown above."),(0,o.mdx)("h4",{id:"return_annotationextends"},(0,o.mdx)("inlineCode",{parentName:"h4"},"return_annotation.extends")),(0,o.mdx)("p",null,"This will match when a callable's return type is a class that is a subclass of\nthe provided class names. Note that this will ",(0,o.mdx)("strong",{parentName:"p"},"only work on class names"),". More\ncomplex types like ",(0,o.mdx)("inlineCode",{parentName:"p"},"Union"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"Callable")," are not supported. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"extends")," clause\nalso takes boolean parameters ",(0,o.mdx)("inlineCode",{parentName:"p"},"is_transitive"),", which when set to true means it\nwill match when the class is a transitive subclass, otherwise it will only match\nwhen it is a direct subclass, and ",(0,o.mdx)("inlineCode",{parentName:"p"},"includes_self"),", which determines whether\n",(0,o.mdx)("inlineCode",{parentName:"p"},"extends(T)")," should include ",(0,o.mdx)("inlineCode",{parentName:"p"},"T")," itself."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_return_annotation_extends",\n  find = functions,\n  where = [\n    return_annotation.extends("test.A", is_transitive=True, includes_self=True),\n  ],\n  model = Returns(TaintSource[Test])\n)\n')),(0,o.mdx)("p",null,"Given the following Python code in module ",(0,o.mdx)("inlineCode",{parentName:"p"},"test"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n  pass\n\nclass B(A):\n  pass\n\nclass C:\n  pass\n\ndef foo() -> A: ...\ndef bar() -> B: ...\ndef baz() -> C: ...\n")),(0,o.mdx)("p",null,"The above query would match ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"baz")," which are transitive subclasses of\n",(0,o.mdx)("inlineCode",{parentName:"p"},"A"),", but not ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo"),", since ",(0,o.mdx)("inlineCode",{parentName:"p"},"includes_self")," was ",(0,o.mdx)("inlineCode",{parentName:"p"},"False"),"."),(0,o.mdx)("p",null,"If the return type is ",(0,o.mdx)("inlineCode",{parentName:"p"},"Optional[T]"),", or ",(0,o.mdx)("inlineCode",{parentName:"p"},"ReadOnly[T]"),", they will be effectively\ntreated as if they were type ",(0,o.mdx)("inlineCode",{parentName:"p"},"T")," for the purpose of matching."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Optional\nfrom pyre_extensions import ReadOnly\n\n# These should all also match\ndef bar_optional() -> Optional[B]: ...\ndef bar_readonly() -> ReadOnly[B]: ...\ndef baz2() -> Optional[ReadOnly[Optional[C]]]: ...\n")),(0,o.mdx)("h3",{id:"type_annotation-clauses"},(0,o.mdx)("inlineCode",{parentName:"h3"},"type_annotation")," clauses"),(0,o.mdx)("p",null,"Model queries allow for querying based on the type annotation of a ",(0,o.mdx)("inlineCode",{parentName:"p"},"global"),".\nNote that this is similar to the\n",(0,o.mdx)("a",{parentName:"p",href:"#return_annotation-clauses"},(0,o.mdx)("inlineCode",{parentName:"a"},"return_annotation"))," clauses shown previously. See\nalso: ",(0,o.mdx)("inlineCode",{parentName:"p"},"Parameters")," model ",(0,o.mdx)("a",{parentName:"p",href:"#type_annotation-clause"},(0,o.mdx)("inlineCode",{parentName:"a"},"type_annotation"))," clauses."),(0,o.mdx)("h4",{id:"type_annotationequals"},(0,o.mdx)("inlineCode",{parentName:"h4"},"type_annotation.equals")),(0,o.mdx)("p",null,"The clause will match when the fully-qualified name of the global's explicitly\nannotated type matches the specified value exactly."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_string_dicts",\n  find = "globals",\n  where = [\n    type_annotation.equals("typing.Dict[(str, str)]"),\n  ],\n  model = GlobalModel(TaintSource[SelectDict])\n)\n')),(0,o.mdx)("p",null,"For example, the above query when run on the following code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'unannotated_dict = {"hello": "world", "abc": "123"}\nannotated_dict: Dict[str, str] = {"hello": "world", "abc": "123"}\n')),(0,o.mdx)("p",null,"will result in a model for ",(0,o.mdx)("inlineCode",{parentName:"p"},"annotated_dict: TaintSource[SelectDict]"),"."),(0,o.mdx)("h4",{id:"type_annotationmatches"},(0,o.mdx)("inlineCode",{parentName:"h4"},"type_annotation.matches")),(0,o.mdx)("p",null,"This is similar to the previous clause, but will match when the fully-qualified\nname of the global's explicit type annotation matches the specified pattern."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_anys",\n  find = "globals",\n  where = [\n    return_annotation.matches(".*typing.Any.*"),\n  ],\n  model = GlobalModel(TaintSource[SelectAny])\n)\n')),(0,o.mdx)("h4",{id:"type_annotationis_annotated_type"},(0,o.mdx)("inlineCode",{parentName:"h4"},"type_annotation.is_annotated_type")),(0,o.mdx)("p",null,"This will match when a global's type is annotated with\n",(0,o.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/library/typing.html#typing.Annotated"},(0,o.mdx)("inlineCode",{parentName:"a"},"typing.Annotated")),".\nThis is a type used to decorate existing types with context-specific metadata,\ne.g."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Annotated\n\nresult: Annotated[str, "SQL"] = ...\n')),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_return_annotated_sources",\n  find = globals,\n  where = [\n    return_annotation.is_annotated_type(),\n  ],\n  model = GlobalModel(TaintSource[SQL])\n)\n')),(0,o.mdx)("p",null,"This query would match on functions like the one shown above."),(0,o.mdx)("h4",{id:"type_annotationextends"},(0,o.mdx)("inlineCode",{parentName:"h4"},"type_annotation.extends")),(0,o.mdx)("p",null,"This behaves the same way as the ",(0,o.mdx)("inlineCode",{parentName:"p"},"return_annotation.extends()")," clause. Please\nrefer to ",(0,o.mdx)("a",{parentName:"p",href:"#return_annotationextends"},"the section above"),"."),(0,o.mdx)("h3",{id:"any_parameter-clauses"},(0,o.mdx)("inlineCode",{parentName:"h3"},"any_parameter")," clauses"),(0,o.mdx)("p",null,"Model queries allow matching callables where any parameter matches a given\nclause. For now, the only clauses we support for parameters is specifying\nconditions on the type annotation of a callable's parameters. These can be used\nin conjunction with the ",(0,o.mdx)("inlineCode",{parentName:"p"},"Parameters")," model clause (see\n",(0,o.mdx)("a",{parentName:"p",href:"#type_annotation-clause"},(0,o.mdx)("inlineCode",{parentName:"a"},"type_annotation")),") to taint specific parameters. Note\nthat this ",(0,o.mdx)("inlineCode",{parentName:"p"},"where")," clause does not work when the ",(0,o.mdx)("inlineCode",{parentName:"p"},"find")," clause specifies\n",(0,o.mdx)("inlineCode",{parentName:"p"},'"attributes"'),"."),(0,o.mdx)("h4",{id:"any_parameterannotationequals"},(0,o.mdx)("inlineCode",{parentName:"h4"},"any_parameter.annotation.equals")),(0,o.mdx)("p",null,"This clause will match all callables which have at least one parameter where the\nfully-qualified name of the parameter type matches the specified value exactly."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_parameter_HttpRequest_sources",\n  find = "functions",\n  where = [\n    any_parameter.annotation.equals("django.http.HttpRequest")\n  ],\n  model =\n    Parameters(\n      TaintSource[UserControlled],\n      where=[\n        name.equals("request"),\n        name.matches("data$")\n      ]\n    )\n)\n')),(0,o.mdx)("h4",{id:"any_parameterannotationmatches"},(0,o.mdx)("inlineCode",{parentName:"h4"},"any_parameter.annotation.matches")),(0,o.mdx)("p",null,"This clause will match all callables which have at least one parameter where the\nfully-qualified name of the parameter type matches the specified pattern."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_parameter_Request_sources",\n  find = "methods",\n  where = [\n    any_parameter.annotation.matches(".*Request")\n  ],\n  model =\n    Parameters(\n      TaintSource[UserControlled],\n      where=[\n        type_annotation.matches(".*Request"),\n      ]\n    )\n)\n')),(0,o.mdx)("h4",{id:"any_parameterannotationis_annotated_type"},(0,o.mdx)("inlineCode",{parentName:"h4"},"any_parameter.annotation.is_annotated_type")),(0,o.mdx)("p",null,"This clause will match all callables which have at least one parameter with type\n",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Annotated"),"."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_parameter_annotated_sources",\n  find = "functions",\n  where = [\n    any_parameter.annotation.is_annotated_type()\n  ],\n  model =\n    Parameters(\n      TaintSource[Test],\n      where=[\n        type_annotation.is_annotated_type(),\n      ]\n    )\n)\n')),(0,o.mdx)("h3",{id:"anyof-clauses"},(0,o.mdx)("inlineCode",{parentName:"h3"},"AnyOf")," clauses"),(0,o.mdx)("p",null,"There are cases when we want to model entities which match any of a set of\nclauses. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"AnyOf")," clause represents exactly this case."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_AnyOf_example",\n  find = "methods",\n  where = [\n    AnyOf(\n      any_parameter.annotation.is_annotated_type(),\n      return_annotation.is_annotated_type(),\n    )\n  ],\n  model = ...\n)\n')),(0,o.mdx)("h3",{id:"allof-clauses"},(0,o.mdx)("inlineCode",{parentName:"h3"},"AllOf")," clauses"),(0,o.mdx)("p",null,"There are cases when we want to model entities which match all of a set of\nclauses. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"AllOf")," clause may be used in this case."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_AllOf_example",\n  find = "methods",\n  where = [\n    AnyOf(\n      AllOf(\n        cls.extends("a.b"),\n        cls.name.matches("Foo"),\n      ),\n      AllOf(\n        cls.extends("c.d"),\n        cls.name.matches("Bar")\n      )\n    )\n  ],\n  model = ...\n)\n')),(0,o.mdx)("h3",{id:"decorator-clauses"},(0,o.mdx)("inlineCode",{parentName:"h3"},"Decorator")," clauses"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"Decorator")," clauses are used to find callables decorated with decorators that\nmatch a pattern. This clause takes decorator clauses as arguments."),(0,o.mdx)("h4",{id:"decorator-fully_qualified_callee-clauses"},"Decorator ",(0,o.mdx)("inlineCode",{parentName:"h4"},"fully_qualified_callee")," clauses"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"fully_qualified_callee")," decorator clause is used to match on the fully\nqualified name of a decorator. That is, the fully qualified name of a higher\norder function. The supported name clauses are the same as the ones discussed\nabove for model query constraints, i.e.,"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},'fully_qualified_callee.matches("pattern")'),", which will match when the\ndecorator matches the regex pattern specified as a string, and"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},'fully_qualified_callee.equals("foo.bar.d1")'),", which will match when the\nfully-qualified name of the decorator equals the specified string exactly.")),(0,o.mdx)("p",null,"For example, if you wanted to find all functions that are decorated by\n",(0,o.mdx)("inlineCode",{parentName:"p"},"@App().route()"),", a decorator whose definition is in file ",(0,o.mdx)("inlineCode",{parentName:"p"},"my_module.py"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class App:\n  def route(self, func: Callable) -> Callable:\n    ...\n")),(0,o.mdx)("p",null,"You can write:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_my_module_app_route_decorator",\n  find = "functions",\n  where = Decorator(fully_qualified_callee.equals("my_module.App.route")),\n  ...\n)\n')),(0,o.mdx)("p",null,"which is arguably better because it is more precise than regex matching, or"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_app_route_decorator",\n  find = "functions",\n  where = Decorator(fully_qualified_callee.matches(".*\\.App\\.route")),\n  ...\n)\n')),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Clarification.")," As another example, assume the following code is in file\n",(0,o.mdx)("inlineCode",{parentName:"p"},"test.py"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Flask:\n    def route(self, func: Callable) -> Callable:\n      ...\napplication = Flask()\n@application.route\ndef my_view():\n  pass\n")),(0,o.mdx)("p",null,"Then, for decorator ",(0,o.mdx)("inlineCode",{parentName:"p"},"@application.route"),", clause ",(0,o.mdx)("inlineCode",{parentName:"p"},"fully_qualified_callee"),"\nmatches against the decorator's fully qualified name ",(0,o.mdx)("inlineCode",{parentName:"p"},"test.Flask.route"),", as\noppposed to the local identifier's fully qualified name ",(0,o.mdx)("inlineCode",{parentName:"p"},"test.application.route"),"\n(that refers to this decorator)."),(0,o.mdx)("h4",{id:"decorator-name-clauses"},"Decorator ",(0,o.mdx)("inlineCode",{parentName:"h4"},"name")," clauses"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"name")," clause is similar to ",(0,o.mdx)("inlineCode",{parentName:"p"},"fully_qualified_name"),", but matches against the\nactual name of the entity, excluding module and class names."),(0,o.mdx)("h4",{id:"decorator-arguments-clauses"},"Decorator ",(0,o.mdx)("inlineCode",{parentName:"h4"},"arguments")," clauses"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"arguments")," clauses is used to match on the arguments provided to the\ndecorator. The supported arguments clauses are ",(0,o.mdx)("inlineCode",{parentName:"p"},"arguments.contains(...)"),", which\nwill match when the arguments specified are a subset of the decorator's\narguments, and ",(0,o.mdx)("inlineCode",{parentName:"p"},"arguments.equals(...)"),", which will match when the decorator has\nthe specified arguments exactly."),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"arguments.contains()")," supports both positional and keyword arguments. For\npositional arguments, the list of positonal arguments supplied to the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"arguments.contains()")," clause must be a prefix of the list of positional\narguments on the actual decorator, i.e. the value of the argument at each\nposition should be the same. For example, with the following Python code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@d1(a, 2)\ndef match1():\n  ...\n\n@d1(a, 2, 3, 4)\ndef match2():\n  ...\n\n@d1(2, a):\ndef nomatch():\n  ...\n")),(0,o.mdx)("p",null,"This query will match both ",(0,o.mdx)("inlineCode",{parentName:"p"},"match1()")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"match2()"),", but not ",(0,o.mdx)("inlineCode",{parentName:"p"},"nomatch()"),", since\nthe values of the positional arguments don't match up."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_d1_decorator",\n  find = "functions",\n  where = Decorator(\n    fully_qualified_name.matches("d1"),\n    arguments.contains(a, 2)\n  ),\n  ...\n)\n')),(0,o.mdx)("p",null,"For keyword arguments in ",(0,o.mdx)("inlineCode",{parentName:"p"},"arguments.contains()"),", the specified keyword arguments\nmust be a subset of the decorator's keyword arguments, but can be specified in\nany order. For example, with the following Python code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'@d1(a, 2, foo="Bar")\ndef match1():\n  ...\n\n@d1(baz="Boo", foo="Bar")\ndef match2():\n  ...\n')),(0,o.mdx)("p",null,"This query will match both ",(0,o.mdx)("inlineCode",{parentName:"p"},"match1()")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"match2()"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_d1_decorator",\n  find = "functions",\n  where = Decorator(\n    fully_qualified_name.matches("d1"),\n    arguments.contains(foo="Bar")\n  ),\n  ...\n)\n')),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"arguments.equals()")," operates similarly, but will only match if the specified\narguments match the decorator's arguments exactly. This means that for\npositional arguments, all arguments in each position must match by value\nexactly. Keyword arguments can be specified in a different order, but the set of\nspecified keyword arguments and the set of the decorator's actual keyword\narguments must be the same. For example, with the following Python code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'@d1(a, 2, foo="Bar", baz="Boo")\ndef match1():\n  ...\n\n@d1(a, 2, baz="Boo", foo="Bar")\ndef match2():\n  ...\n\n@d1(2, a, baz="Boo", foo="Bar")\ndef nomatch1():\n  ...\n\n@d1(a, 2, 3, baz="Boo", foo="Bar")\ndef nomatch2():\n  ...\n')),(0,o.mdx)("p",null,"This query will match both ",(0,o.mdx)("inlineCode",{parentName:"p"},"match1()")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"match2()"),", but not ",(0,o.mdx)("inlineCode",{parentName:"p"},"nomatch1()")," or\n",(0,o.mdx)("inlineCode",{parentName:"p"},"nomatch2()"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_d1_decorator",\n  find = "functions",\n  where = Decorator(\n    fully_qualified_name.matches("d1"),\n    arguments.equals(a, 2, foo="bar", baz="Boo")\n  ),\n  ...\n)\n')),(0,o.mdx)("h4",{id:"decorator-not-allof-and-anyof-clauses"},"Decorator ",(0,o.mdx)("inlineCode",{parentName:"h4"},"Not"),", ",(0,o.mdx)("inlineCode",{parentName:"h4"},"AllOf")," and ",(0,o.mdx)("inlineCode",{parentName:"h4"},"AnyOf")," clauses"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"Not"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"AllOf")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"AnyOf")," clauses can be used in decorators clauses in the\nsame way as they are in the main ",(0,o.mdx)("inlineCode",{parentName:"p"},"where")," clause of the model query."),(0,o.mdx)("h3",{id:"clsfully_qualified_nameequals-clause"},(0,o.mdx)("inlineCode",{parentName:"h3"},"cls.fully_qualified_name.equals")," clause"),(0,o.mdx)("p",null,"You may use the ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls")," clause to specify predicates on the class. This predicate\ncan only be used when the find clause specifies methods or attributes."),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.fully_qualified_name.equals")," clause is used to model entities when the\nclass's fully qualified name is an exact match for the specified string."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_childOf_foo_Bar",\n  find = "methods",\n  where = cls.name.equals("foo.Bar"),\n  ...\n)\n')),(0,o.mdx)("h3",{id:"clsfully_qualified_namematches-clause"},(0,o.mdx)("inlineCode",{parentName:"h3"},"cls.fully_qualified_name.matches")," clause"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.fully_qualified_name.matches")," clause is used to model entities when the\nclass's fully qualified name matches the provided regex."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_childOf_Foo",\n  find = "methods",\n  where = cls.fully_qualified_name.matches(".*Foo.*"),\n  ...\n)\n')),(0,o.mdx)("h3",{id:"clsnamematches-clause"},(0,o.mdx)("inlineCode",{parentName:"h3"},"cls.name.matches")," clause"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.name.matches")," clause is similar to ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.fully_qualified_name.matches"),",\nbut matches against the actual name of the class, excluding modules."),(0,o.mdx)("h3",{id:"clsnameequals-clause"},(0,o.mdx)("inlineCode",{parentName:"h3"},"cls.name.equals")," clause"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.name.equals")," clause is similar to ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.fully_qualified_name.equals"),",\nbut matches against the actual name of the class, excluding modules."),(0,o.mdx)("h3",{id:"clsextends-clause"},(0,o.mdx)("inlineCode",{parentName:"h3"},"cls.extends")," clause"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.extends")," clause is used to model entities when the class is a subclass\nof the provided class name."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_subclassOf_C",\n  find = "attributes",\n  where = cls.extends("C"),\n  ...\n)\n')),(0,o.mdx)("p",null,"The default behavior is that it will only match if the class is an instance of,\nor a direct subclass of the specified class. For example, with classes:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class C:\n  x = ...\n\nclass D(C):\n  y = ...\n\nclass E(D):\n  z = ...\n")),(0,o.mdx)("p",null,"the above query will only model the attributes ",(0,o.mdx)("inlineCode",{parentName:"p"},"C.z")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"D.y"),", since ",(0,o.mdx)("inlineCode",{parentName:"p"},"C")," is\nconsidered to extend itself, and ",(0,o.mdx)("inlineCode",{parentName:"p"},"D")," is a direct subclass of ",(0,o.mdx)("inlineCode",{parentName:"p"},"C"),". However, it\nwill not model ",(0,o.mdx)("inlineCode",{parentName:"p"},"E.z"),", since ",(0,o.mdx)("inlineCode",{parentName:"p"},"E")," is a sub-subclass of ",(0,o.mdx)("inlineCode",{parentName:"p"},"C"),"."),(0,o.mdx)("p",null,"If you would like to model a class and all subclasses transitively, you can use\nthe ",(0,o.mdx)("inlineCode",{parentName:"p"},"is_transitive")," flag."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_transitive_subclassOf_C",\n  find = "attributes",\n  where = cls.extends("C", is_transitive=True),\n  ...\n)\n')),(0,o.mdx)("p",null,"This query will model ",(0,o.mdx)("inlineCode",{parentName:"p"},"C.x"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"D.y")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"E.z"),"."),(0,o.mdx)("p",null,"If you do not want to match on the class itself, you can use the ",(0,o.mdx)("inlineCode",{parentName:"p"},"includes_self"),"\nflag."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_transitive_subclassOf_C",\n  find = "attributes",\n  where = cls.extends("C", is_transitive=True, includes_self=False),\n  ...\n)\n')),(0,o.mdx)("p",null,"This query will model ",(0,o.mdx)("inlineCode",{parentName:"p"},"D.y")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"E.z"),"."),(0,o.mdx)("h3",{id:"clsdecorator-clause"},(0,o.mdx)("inlineCode",{parentName:"h3"},"cls.decorator")," clause"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.decorator")," clause is used to specify constraints on a class decorator,\nso you can choose to model entities on classes only if the class it is part of\nhas the specified decorator."),(0,o.mdx)("p",null,"The arguments for this clause are identical to the non-class constraint\n",(0,o.mdx)("inlineCode",{parentName:"p"},"Decorator"),", for more information, please see the\n",(0,o.mdx)("a",{parentName:"p",href:"#decorator-clauses"},(0,o.mdx)("inlineCode",{parentName:"a"},"Decorator")," clauses")," section."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_childOf_d1_decorator_sources",\n  find = "methods",\n  where = [\n    name.equals("__init__"),\n    cls.decorator(\n      fully_qualified_name.matches("d1"),\n      arguments.contains(2)\n    ),\n  ],\n  model = [\n    Parameters(TaintSource[Test], where=[\n        Not(name.equals("self")),\n        Not(name.equals("a"))\n    ])\n  ]\n)\n')),(0,o.mdx)("p",null,"For example, the above query when run on the following code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@d1(2)\nclass Foo:\n  def __init__(self, a, b):\n     ...\n\n@d1()\nclass Bar:\n  def __init__(self, a, b):\n    ...\n\n@d2(2)\nclass Baz:\n  def __init__(self, a, b):\n    ...\n")),(0,o.mdx)("p",null,"will result in a model for ",(0,o.mdx)("inlineCode",{parentName:"p"},"def Foo.__init__(b: TaintSource[Test])"),"."),(0,o.mdx)("h3",{id:"clsany_child-clause"},(0,o.mdx)("inlineCode",{parentName:"h3"},"cls.any_child")," clause"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.any_child")," clause is used to model entities when any child of the\ncurrent class meets the specified constraints."),(0,o.mdx)("p",null,"The arguments for this clause are any combination of valid class constraints\n(",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.name.equals"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.name.matches"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.fully_qualified_name.equals"),",\n",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.fully_qualified_name.matches"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.extends"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.decorator"),") and logical\nclauses (",(0,o.mdx)("inlineCode",{parentName:"p"},"AnyOf"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"AllOf"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"Not"),"), along with the optional ",(0,o.mdx)("inlineCode",{parentName:"p"},"is_transitive")," and\n",(0,o.mdx)("inlineCode",{parentName:"p"},"includes_self")," clauses."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_parent_of_d1_decorator_sources",\n  find = "methods",\n  where = [\n    name.equals("__init__"),\n    cls.any_child(\n      cls.decorator(\n        fully_qualified_name.matches("d1"),\n        arguments.contains(2)\n      )\n    ),\n  ],\n  model = [\n    Parameters(TaintSource[Test], where=[\n        Not(name.equals("self")),\n        Not(name.equals("a"))\n    ])\n  ]\n)\n')),(0,o.mdx)("p",null,"Similar to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.extends")," constraint, the default behavior is that it will\nonly match if any immediate children (or itself) of the class of the method or\nattribute matches against the inner clause. For example, with classes:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Foo:\n  def __init__(self, a, b):\n     ...\n\nclass Bar(Foo):\n  def __init__(self, a, b):\n    ...\n\n@d1(2)\nclass Baz(Bar):\n  def __init__(self, a, b):\n    ...\n")),(0,o.mdx)("p",null,"The above query will only model the methods ",(0,o.mdx)("inlineCode",{parentName:"p"},"Bar.__init__")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"Baz.__init__"),",\nsince ",(0,o.mdx)("inlineCode",{parentName:"p"},"Bar")," is an immediate parent of ",(0,o.mdx)("inlineCode",{parentName:"p"},"Baz"),", and ",(0,o.mdx)("inlineCode",{parentName:"p"},"Baz")," is considered to extend\nitself. However, it will not model ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo.__init__"),", since ",(0,o.mdx)("inlineCode",{parentName:"p"},"Bar")," is a sub-subclass\nof ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo"),"."),(0,o.mdx)("p",null,"If you would like to model a class and all subclasses transitively, you can use\nthe ",(0,o.mdx)("inlineCode",{parentName:"p"},"is_transitive")," flag."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_transitive_parent_of_d1_decorator_sources",\n  find = "attributes",\n  where = [\n    name.equals("__init__"),\n    cls.any_child(\n      cls.decorator(\n        fully_qualified_name.matches("d1"),\n        arguments.contains(2)\n      ),\n      is_transitive=True\n    ),\n  ],\n  ...\n)\n')),(0,o.mdx)("p",null,"This query will model ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo.__init__"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"Bar.__init__")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"Baz.__init__"),"."),(0,o.mdx)("p",null,"If you would like to model all subclasses of a class excluding itself, you can\nuse the ",(0,o.mdx)("inlineCode",{parentName:"p"},"includes_self")," flag."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_transitive_parent_of_d1_decorator_sources",\n  find = "attributes",\n  where = [\n    name.equals("__init__"),\n    cls.any_child(\n      cls.decorator(\n        fully_qualified_name.matches("d1"),\n        arguments.contains(2)\n      ),\n      is_transitive=True,\n      includes_self=False\n    ),\n  ],\n  ...\n)\n')),(0,o.mdx)("p",null,"This query will model ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo.__init__"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"Bar.__init__")," but NOT ",(0,o.mdx)("inlineCode",{parentName:"p"},"Baz.__init__"),"."),(0,o.mdx)("admonition",{type:"tip"},(0,o.mdx)("p",{parentName:"admonition"},"We recommend to always specify both ",(0,o.mdx)("inlineCode",{parentName:"p"},"is_transitive")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"includes_self")," to avoid\nconfusion.")),(0,o.mdx)("h3",{id:"clsany_parent-clause"},(0,o.mdx)("inlineCode",{parentName:"h3"},"cls.any_parent")," clause"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.any_parent")," clause is used to model entities when any parent of the\ncurrent class meets the specified constraints."),(0,o.mdx)("p",null,"The arguments for this clause are any combination of valid class constraints\n(",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.name.equals"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.name.matches"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.fully_qualified_name.equals"),",\n",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.fully_qualified_name.matches"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.extends"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.decorator"),") and logical\nclauses (",(0,o.mdx)("inlineCode",{parentName:"p"},"AnyOf"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"AllOf"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"Not"),"), along with the optional ",(0,o.mdx)("inlineCode",{parentName:"p"},"is_transitive")," and\n",(0,o.mdx)("inlineCode",{parentName:"p"},"includes_self")," clauses."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_children_of_d1_decorator_sources",\n  find = "methods",\n  where = [\n    name.equals("__init__"),\n    cls.any_parent(\n      cls.decorator(\n        fully_qualified_name.matches("d1"),\n        arguments.contains(2)\n      )\n    ),\n  ],\n  model = [\n    Parameters(TaintSource[Test], where=[\n        Not(name.equals("self")),\n        Not(name.equals("a"))\n    ])\n  ]\n)\n')),(0,o.mdx)("p",null,"Similar to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.extends")," constraint, the default behavior is that it will\nonly match if any immediate parent (or itself) of the class of the method or\nattribute matches against the inner clause. For example, with classes:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@d1(2)\nclass Foo:\n  def __init__(self, a, b):\n     ...\n\nclass Bar(Foo):\n  def __init__(self, a, b):\n    ...\n\nclass Baz(Bar):\n  def __init__(self, a, b):\n    ...\n")),(0,o.mdx)("p",null,"The above query will only model the methods ",(0,o.mdx)("inlineCode",{parentName:"p"},"Bar.__init__")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo.__init__"),",\nsince ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo")," is an immediate parent of ",(0,o.mdx)("inlineCode",{parentName:"p"},"Bar"),", and ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo")," is considered to extend\nitself. However, it will not model ",(0,o.mdx)("inlineCode",{parentName:"p"},"Baz.__init__"),", since ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo")," is not an\nimmediate parent of ",(0,o.mdx)("inlineCode",{parentName:"p"},"Baz"),"."),(0,o.mdx)("p",null,"If you would like to model a class and all transitive parents, you can use the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"is_transitive")," flag."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_transitive_children_of_d1_decorator_sources",\n  find = "attributes",\n  where = [\n    cls.any_parent(\n      cls.decorator(\n        fully_qualified_name.matches("d1"),\n        arguments.contains(2)\n      ),\n      is_transitive=True\n    ),\n    name.equals("__init__")\n  ],\n  ...\n)\n')),(0,o.mdx)("p",null,"This query will model ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo.__init__"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"Bar.__init__")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"Baz.__init__"),"."),(0,o.mdx)("p",null,"If you would like to model all parents of a class excluding itself, you can use\nthe ",(0,o.mdx)("inlineCode",{parentName:"p"},"includes_self")," flag."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_transitive_parent_of_d1_decorator_sources",\n  find = "attributes",\n  where = [\n    cls.any_parent(\n      cls.decorator(\n        fully_qualified_name.matches("d1"),\n        arguments.contains(2)\n      ),\n      is_transitive=True,\n      includes_self=False\n    ),\n    name.equals("__init__")\n  ],\n  ...\n)\n')),(0,o.mdx)("p",null,"This query will model ",(0,o.mdx)("inlineCode",{parentName:"p"},"Bar.__init__"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"Baz.__init__")," but NOT ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo.__init__"),"."),(0,o.mdx)("admonition",{type:"tip"},(0,o.mdx)("p",{parentName:"admonition"},"We recommend to always specify both ",(0,o.mdx)("inlineCode",{parentName:"p"},"is_transitive")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"includes_self")," to avoid\nconfusion.")),(0,o.mdx)("h3",{id:"any_overriden_method-clause"},(0,o.mdx)("inlineCode",{parentName:"h3"},"any_overriden_method")," clause"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"any_overriden_method")," clause is used to model methods that override a\nmethod that meets the specified constraints."),(0,o.mdx)("p",null,"This clause accept a single argument, which is the constraint on the overriden\nmethod. It can use any constraints valid for methods, including ",(0,o.mdx)("inlineCode",{parentName:"p"},"AllOf"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"AnyOf"),"\nand ",(0,o.mdx)("inlineCode",{parentName:"p"},"Not"),"."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_Foo_bar_overrides",\n  find = "methods",\n  where = [\n    name.equals("bar"),\n    any_overriden_method(\n      cls.name.equals("Foo")\n    )\n  ],\n  model = [\n    Parameters(TaintSource[Test], where=[\n        Not(name.equals("self")),\n        Not(name.equals("a"))\n    ])\n  ]\n)\n')),(0,o.mdx)("p",null,"This will add sources to all methods that override the method ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo.bar"),"."),(0,o.mdx)("admonition",{type:"tip"},(0,o.mdx)("p",{parentName:"admonition"},"This constraint is expensive to compute. To make it faster, we recommend to put\ncheaper constraints before it so it gets short-circuited. For instance,\n",(0,o.mdx)("inlineCode",{parentName:"p"},'name.equals("bar")')," here can be placed before ",(0,o.mdx)("inlineCode",{parentName:"p"},"any_overriden_method")," and will\nmake model generation faster.")),(0,o.mdx)("p",null,"To use multiple constraints inside ",(0,o.mdx)("inlineCode",{parentName:"p"},"any_overriden_method"),", use ",(0,o.mdx)("inlineCode",{parentName:"p"},"AllOf"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_Foo_bar_overrides",\n  find = "methods",\n  where = [\n    name.equals("bar"),\n    any_overriden_method(AllOf(\n      cls.name.equals("Foo"),\n      Decorator(fully_qualified_callee.equals("my_module.my_decorator")),\n    ))\n  ],\n  model = [\n    Parameters(TaintSource[Test], where=[\n        Not(name.equals("self")),\n        Not(name.equals("a"))\n    ])\n  ]\n)\n')),(0,o.mdx)("p",null,"To match all method overrides, use ",(0,o.mdx)("inlineCode",{parentName:"p"},"any_overriden_method(True)"),".\n",(0,o.mdx)("inlineCode",{parentName:"p"},"True")," is a constraint that is always met."),(0,o.mdx)("h3",{id:"not-clauses"},(0,o.mdx)("inlineCode",{parentName:"h3"},"Not")," clauses"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"Not")," clause negates any existing clause that is valid for the entity being\nmodelled."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_Not_example",\n  find = "methods",\n  where = [\n    Not(\n      name.matches("foo.*"),\n      cls.fully_qualified_name.matches("testing.unittest.UnitTest"),\n    )\n  ],\n  model = ...\n)\n')),(0,o.mdx)("h2",{id:"generated-models-model-clauses"},"Generated models (Model clauses)"),(0,o.mdx)("p",null,"The last bit of model queries is actually generating models for all entities\nthat match the provided where clauses. For callables, we support generating\nmodels for parameters by name or position, as well as generating models for all\nparamaters. Additionally, we support generating models for the return\nannotation."),(0,o.mdx)("h3",{id:"returned-taint"},"Returned taint"),(0,o.mdx)("p",null,"Returned taint takes the form of ",(0,o.mdx)("inlineCode",{parentName:"p"},"Returns(TaintSpecification)"),", where\n",(0,o.mdx)("inlineCode",{parentName:"p"},"TaintSpecification")," is either a taint annotation or a list of taint\nannotations."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_Returns_sources",\n  find = "methods",\n  where = ...,\n  model = [\n    Returns(TaintSource[Test, Via[foo]])\n  ]\n)\n')),(0,o.mdx)("h3",{id:"parameter-taint"},"Parameter taint"),(0,o.mdx)("p",null,"Parameters can be tainted using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"Parameters()")," clause. By default, all\nparameters will be tained with the supplied taint specification. If you would\nlike to only taint specific parameters matching certain conditions, an optional\n",(0,o.mdx)("inlineCode",{parentName:"p"},"where")," clause can be specified to accomplish this, allowing for constraints on\nparameter names, the annotation type of the parameter, or parameter position.\nFor example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_Parameters_sources",\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(TaintSource[A]), # will taint all parameters by default\n    Parameters(\n      TaintSource[B],\n      where=[\n        Not(index.equals(0))   # will only taint parameters that are not the first parameter\n      ]\n    ),\n  ]\n)\n')),(0,o.mdx)("h4",{id:"name-clauses-1"},(0,o.mdx)("inlineCode",{parentName:"h4"},"name")," clauses"),(0,o.mdx)("p",null,"To specify a constraint on parameter name, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"name.equals()")," or\n",(0,o.mdx)("inlineCode",{parentName:"p"},"name.matches()")," clauses can be used. As in the main ",(0,o.mdx)("inlineCode",{parentName:"p"},"where")," clause of the model\nquery, ",(0,o.mdx)("inlineCode",{parentName:"p"},"equals()")," searches for an exact match on the specified string, while\n",(0,o.mdx)("inlineCode",{parentName:"p"},"matches()")," allows a regex to be supplied as a pattern to match against."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_request_data_sources",\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        name.equals("request"),\n        name.matches("data$")\n      ]\n    )\n  ]\n)\n')),(0,o.mdx)("h4",{id:"index-clause"},(0,o.mdx)("inlineCode",{parentName:"h4"},"index")," clause"),(0,o.mdx)("p",null,"To specify a constraint on parameter position, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"index.equals()")," clause can\nbe used. It takes a single integer denoting the position of the parameter."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_index_sources",\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        index.equals(1)\n      ]\n    )\n  ]\n)\n')),(0,o.mdx)("h4",{id:"has_position-clause"},(0,o.mdx)("inlineCode",{parentName:"h4"},"has_position")," clause"),(0,o.mdx)("p",null,"To match on parameters that have a position, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"has_position()")," clause can be\nused. This is mostly used to exclude keyword-only parameters, ",(0,o.mdx)("inlineCode",{parentName:"p"},"*args")," and\n",(0,o.mdx)("inlineCode",{parentName:"p"},"**kwargs"),"."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_index_sources",\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        has_position()\n      ]\n    )\n  ]\n)\n')),(0,o.mdx)("h4",{id:"has_name-clause"},(0,o.mdx)("inlineCode",{parentName:"h4"},"has_name")," clause"),(0,o.mdx)("p",null,"To match on parameters that have a name, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"has_name()")," clause can be used.\nThis is mostly used to exclude ",(0,o.mdx)("inlineCode",{parentName:"p"},"*args")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"**kwargs"),"."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_index_sources",\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        has_name()\n      ]\n    )\n  ]\n)\n')),(0,o.mdx)("h4",{id:"type_annotation-clause"},(0,o.mdx)("inlineCode",{parentName:"h4"},"type_annotation")," clause"),(0,o.mdx)("p",null,"This clause is used to specify a constraint on parameter type annotation.\nCurrently the clauses supported are: ",(0,o.mdx)("inlineCode",{parentName:"p"},"type_annotation.equals()"),", which takes the\nfully-qualified name of a Python type or class and matches when there is an\nexact match, ",(0,o.mdx)("inlineCode",{parentName:"p"},"type_annotation.matches()"),", which takes a regex pattern to match\ntype annotations against, and ",(0,o.mdx)("inlineCode",{parentName:"p"},"type_annotation.is_annotated_type()"),", which will\nmatch parameters of type\n",(0,o.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/library/typing.html#typing.Annotated"},(0,o.mdx)("inlineCode",{parentName:"a"},"typing.Annotated")),"."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_annotated_parameters_sources",\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        type_annotation.equals("foo.bar.C"),  # exact match\n        type_annotation.matches("^List\\["),   # regex match\n        type_annotation.is_annotated_type(),  # matches Annotated[T, x]\n      ]\n    )\n  ]\n)\n')),(0,o.mdx)("p",null,"To match on the annotation portion of ",(0,o.mdx)("inlineCode",{parentName:"p"},"Annotated")," types, consider the following\nexample. Suppose this code was in ",(0,o.mdx)("inlineCode",{parentName:"p"},"test.py"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from enum import Enum\nfrom typing import Annotated, Option\n\nclass Color(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\nclass Foo:\n  x: Annotated[Optional[int], Color.RED]\n  y: Annotated[Optional[int], Color.BLUE]\n  z: Annotated[int, "z"]\n')),(0,o.mdx)("p",null,"Note that the type name that should be matched against is its fully qualified\nname, which also includes the fully qualified name of any other types referenced\n(for example, ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Optional")," rather than just ",(0,o.mdx)("inlineCode",{parentName:"p"},"Optional"),"). When multiple\narguments are provided to the type they are implicitly treated as being in a\ntuple."),(0,o.mdx)("p",null,"Here are some examples of ",(0,o.mdx)("inlineCode",{parentName:"p"},"where")," clauses that can be used to specify models for\nthe annotated attributes in this case:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_annotated_attributes_sources",\n  find = "attributes",\n  where = [\n    AnyOf(\n      type_annotation.equals("typing.Annotated[(typing.Optional[int], test.Color.RED)]"),\n      type_annotation.equals("typing.Annotated[(int, z)]"),\n      type_annotation.matches(".*Annotated\\[.*Optional[int].*Color\\..*\\]")\n      type_annotation.is_annotated_type()\n    )\n  ],\n  model = [\n    AttributeModel(TaintSource[Test]),\n  ]\n)\n')),(0,o.mdx)("p",null,"This query should generate the following models:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"test.Foo.x: TaintSource[Test]\ntest.Foo.y: TaintSource[Test]\ntest.Foo.z: TaintSource[Test]\n")),(0,o.mdx)("h4",{id:"not-allof-and-anyof-clauses"},(0,o.mdx)("inlineCode",{parentName:"h4"},"Not"),", ",(0,o.mdx)("inlineCode",{parentName:"h4"},"AllOf")," and ",(0,o.mdx)("inlineCode",{parentName:"h4"},"AnyOf")," clauses"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"Not"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"AllOf")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"AnyOf")," clauses can be used in the same way as they are\nin the main ",(0,o.mdx)("inlineCode",{parentName:"p"},"where")," clause of the model query. ",(0,o.mdx)("inlineCode",{parentName:"p"},"Not")," can be used to negate any\nexisting clause, ",(0,o.mdx)("inlineCode",{parentName:"p"},"AllOf")," to match when all of several supplied clauses match,\nand ",(0,o.mdx)("inlineCode",{parentName:"p"},"AnyOf")," can be used to match when any one of several supplied clauses match."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_Not_AnyOf_AllOf_example_sources",\n  find = "methods",\n  where = ...,\n  model = [\n    Parameters(\n      TaintSource[Test],\n      where=[\n        Not(\n          AnyOf(\n            AllOf(\n              cls.extends("a.b"),\n              cls.name.matches("Foo"),\n            ),\n            AllOf(\n              cls.extends("c.d"),\n              cls.name.matches("Bar")\n            )\n          )\n        )\n      ]\n    )\n  ]\n)\n')),(0,o.mdx)("h4",{id:"using-viatypeof-with-the-parameters-clause"},"Using ",(0,o.mdx)("inlineCode",{parentName:"h4"},"ViaTypeOf")," with the ",(0,o.mdx)("inlineCode",{parentName:"h4"},"Parameters")," clause"),(0,o.mdx)("p",null,"Usually when specifying a ",(0,o.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," the argument that you want to capture the\nvalue or type of should be specified. However, when writing model queries and\ntrying to find all parameters that match certain conditions, we may not know the\nexact name of the parameters that will be modelled. For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def f1(bad_1, good_1, good_2):\n  pass\n\ndef f2(good_3, bad_2, good_4):\n  pass\n")),(0,o.mdx)("p",null,"Suppose we wanted to model all parameters with the prefix ",(0,o.mdx)("inlineCode",{parentName:"p"},"bad_")," here and attach\na ",(0,o.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," to them. In this case it is still possible to attach these\nfeatures to the parameter model, by using a standalone ",(0,o.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," as follows:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_f_sinks",\n  find = "functions",\n  where = name.matches("f"),\n  model = [\n    Parameters(\n      TaintSink[Test, ViaTypeOf],\n      where=[\n        name.matches("bad_")\n      ]\n    )\n  ]\n)\n')),(0,o.mdx)("p",null,"This would produce models equivalent to the following:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def f1(bad_1: TaintSink[Test, ViaTypeOf[bad_1]]): ...\ndef f2(bad_2: TaintSink[Test, ViaTypeOf[bad_2]]): ...\n")),(0,o.mdx)("h3",{id:"models-for-attributes"},"Models for attributes"),(0,o.mdx)("p",null,"Taint for attribute models requires a ",(0,o.mdx)("inlineCode",{parentName:"p"},"AttributeModel")," model clause, which can\nonly be used when the find clause specifies attributes."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_attribute_sources_sinks",\n  find = "attributes",\n  where = ...,\n  model = [\n    AttributeModel(TaintSource[Test], TaintSink[Test])\n  ]\n)\n')),(0,o.mdx)("h4",{id:"using-viaattributename-with-the-attributemodel-clause"},"Using ",(0,o.mdx)("inlineCode",{parentName:"h4"},"ViaAttributeName")," with the ",(0,o.mdx)("inlineCode",{parentName:"h4"},"AttributeModel")," clause"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"ViaAttributeName")," can be used within ",(0,o.mdx)("inlineCode",{parentName:"p"},"AttributeModel")," to add a feature\ncontaining the name of the attribute to any taint flowing through the given\nattributes."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_attribute_of_Foo",\n  find = "attributes",\n  where = [cls.name.equals("Foo")],\n  model = [\n    AttributeModel(ViaAttributeName[WithTag["Foo"]])\n  ]\n)\n')),(0,o.mdx)("p",null,"On the following code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Foo:\n  first_name: str\n  last_name: str\n\ndef last_name_to_sink(foo: Foo):\n  sink(foo.last_name)\n")),(0,o.mdx)("p",null,"This will add the feature ",(0,o.mdx)("inlineCode",{parentName:"p"},"via-Foo-attribute:last_name")," on the flow to the sink."),(0,o.mdx)("h3",{id:"models-for-globals"},"Models for globals"),(0,o.mdx)("p",null,"Taint for global models requires a ",(0,o.mdx)("inlineCode",{parentName:"p"},"GlobalModel")," model clause, which can only be\nused when the find clause specifies globals."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_global_sources",\n  find = "globals",\n  where = ...,\n  model = [\n    GlobalModel(TaintSource[Test])\n  ]\n)\n')),(0,o.mdx)("h3",{id:"models-for-setting-modes"},"Models for setting modes"),(0,o.mdx)("p",null,"This model clause is different from the others in this section in the sense that\nit doesn't produce taint for the models it targets, but updates their models\nwith specific modes to change their behavior with taint analysis."),(0,o.mdx)("p",null,"The available modes are:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/pysa-advanced#obscure-models"},(0,o.mdx)("inlineCode",{parentName:"a"},"Obscure")),(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"Marks the function or method as obscure"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/pysa-advanced#obscure-models"},(0,o.mdx)("inlineCode",{parentName:"a"},"SkipObscure")),(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"Prevents a function or method from being marked as obscure"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/pysa-advanced#prevent-inferring-models-with-skipanalysis"},(0,o.mdx)("inlineCode",{parentName:"a"},"SkipAnalysis")),(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"Skips inference of the function or model targeted, and forces the use of\nuser-defined models for taint flow"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/pysa-advanced#ignoring-overrides"},(0,o.mdx)("inlineCode",{parentName:"a"},"SkipOverrides")),(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"Prevents taint propagation from the targeted model into and from overridden\nmethods on subclasses"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/pysa-advanced#filtering-the-call-graph-with-entrypoint"},(0,o.mdx)("inlineCode",{parentName:"a"},"Entrypoint")),(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"Specifies functions or methods to be used as entrypoints for analysis, so\nonly transitive calls from that function are analyzed"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/pysa-advanced#prevent-inlining-decorators-with-skipdecoratorwheninlining"},(0,o.mdx)("inlineCode",{parentName:"a"},"SkipDecoratorWhenInlining")),(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"Prevents the selected decorator from being inlined during analysis"),(0,o.mdx)("li",{parentName:"ul"},"Note: this mode will be a no-op, since model queries are generated after\ndecorators are inlined"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/pysa-advanced#model-broadening"},(0,o.mdx)("inlineCode",{parentName:"a"},"SkipModelBroadening")),(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"Prevents model broadening for the given function or method")))),(0,o.mdx)("p",null,"For instance, instead of annotating each function separately, as in the\nfollowing ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@Entrypoint\ndef myfile.func1(): ...\n\n@Entrypoint\ndef myfile.func2(): ...\n\n@Entrypoint\ndef myfile.func3(): ...\n\n@Entrypoint\ndef myfile.func4(): ...\n")),(0,o.mdx)("p",null,"One could instead use the following model query:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_myfile_entrypoint_functions",\n  find = "functions",\n  where = [\n    name.matches("myfile\\.func.*")\n  ],\n  model = [\n    Modes([Entrypoint])\n  ]\n)\n')),(0,o.mdx)("p",null,"The benefit is that any new functions that matches that name will also be\nconsidered entrypoints."),(0,o.mdx)("p",null,"Note that it is also possible to include multiple modes in a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Modes")," model\nclause by extending the list (e.g ",(0,o.mdx)("inlineCode",{parentName:"p"},"Modes([SkipOverrides, Obscure])"),"."),(0,o.mdx)("h2",{id:"expected-and-unexpected-models-clauses"},"Expected and Unexpected Models clauses"),(0,o.mdx)("p",null,"The optional ",(0,o.mdx)("inlineCode",{parentName:"p"},"expected_models")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"unexpected_models")," clauses allow you to\nspecify models that your ModelQuery should or should not generate the equivalent\nof. The models in these clauses should be syntactically correct Pysa models (see\n",(0,o.mdx)("a",{parentName:"p",href:"https://staticdocs.internalfb.com/pyre/docs/pysa-basics/#model-files"},"this documentation"),"\nfor a guide on how to write a Pysa model). If your query does not generate a\nmodel in ",(0,o.mdx)("inlineCode",{parentName:"p"},"expected_models"),", or if it generates a model in ",(0,o.mdx)("inlineCode",{parentName:"p"},"unexpected_models"),",\nan error will be raised."),(0,o.mdx)("p",null,"Example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "get_foo_returns_sources",\n  find = "functions",\n  where = [name.matches("foo")],\n  model = [\n    Returns(TaintSource[Test]),\n  ],\n  expected_models = [\n    "def file.foo() -> TaintSource[Test]: ...",\n    "def file.foo2() -> TaintSource[Test]: ..."\n  ],\n  unexpected_models = [\n    "def file.bar() -> TaintSource[Test]: ..."\n  ]\n)\n')),(0,o.mdx)("p",null,"This would not produce any errors, since the models the ModelQuery generates\nwill contain ",(0,o.mdx)("inlineCode",{parentName:"p"},"expected_models")," and not ",(0,o.mdx)("inlineCode",{parentName:"p"},"unexpected_models"),"."),(0,o.mdx)("h2",{id:"cache-queries"},"Cache Queries"),(0,o.mdx)("p",null,"Generating models for a large number of queries can be quite slow. Cache queries\nallow to speed up model generation by factoring out queries with similar ",(0,o.mdx)("inlineCode",{parentName:"p"},"where"),"\nclause into a single query, which builds a mapping from an arbitrary name to a\nset of matching entities. Then, other queries can read from this cache, making\nthem quick to execute."),(0,o.mdx)("p",null,"For instance, imagine having the following queries:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  ...\n  find = "methods",\n  where = [\n    AnyOf(cls.extends("my_module.Foo"), cls.extends("other_module.Bar")),\n    fully_qualified_name.matches("\\.ClassA\\.method$"),\n  ],\n  model = ...\n)\nModelQuery(\n  ...\n  find = "methods",\n  where = [\n    AnyOf(cls.extends("my_module.Foo"), cls.extends("other_module.Bar")),\n    fully_qualified_name.matches("\\.ClassB\\.method$"),\n  ],\n  model = ...\n)\nModelQuery(\n  ...\n  find = "methods",\n  where = [\n    AnyOf(cls.extends("my_module.Foo"), cls.extends("other_module.Bar")),\n    fully_qualified_name.matches("\\.ClassC\\.other_method$"),\n  ],\n  model = ...\n)\n# etc.\n')),(0,o.mdx)("p",null,"We can factor out the expensive where clause into a single query which writes to\na key-value cache, using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"WriteToCache")," clause."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  ...\n  find = "methods",\n  where = [AnyOf(cls.extends("my_module.Foo"), cls.extends("other_module.Bar"))],\n  model = WriteToCache(kind="FooBar", name=f"{class_name}:{function_name}")\n)\n')),(0,o.mdx)("p",null,"All matching methods will be stored in a cache named ",(0,o.mdx)("inlineCode",{parentName:"p"},"FooBar"),", under the key\n",(0,o.mdx)("inlineCode",{parentName:"p"},"{class_name}:{function_name}"),"."),(0,o.mdx)("p",null,"After executing the query, we might get the following cache ",(0,o.mdx)("inlineCode",{parentName:"p"},"FooBar"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"ClassA:method -> {some_module.ClassA.method}\nClassB:method -> {some_other_module.ClassB.method}\nClassC:other_method -> {some_module.ClassC.other_method}\n")),(0,o.mdx)("p",null,"We can then read from the cache using the where clause ",(0,o.mdx)("inlineCode",{parentName:"p"},"read_from_cache"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = read_from_cache(kind="FooBar", name="ClassA:method",\n  model = ...\n)\nModelQuery(\n  find = "methods",\n  where = read_from_cache(kind="FooBar", name="ClassB:method",\n  model = ...\n)\nModelQuery(\n  find = "methods",\n  where = read_from_cache(kind="FooBar", name="ClassC:other_method",\n  model = ...\n)\n')),(0,o.mdx)("p",null,"This will generate the same models as the first example, but model generation\nwill be a lot faster."),(0,o.mdx)("p",null,"In terms of time complexity, if the number of entities (methods here) is ",(0,o.mdx)("inlineCode",{parentName:"p"},"N"),",\nthe number of queries is ",(0,o.mdx)("inlineCode",{parentName:"p"},"Q")," and the average cost of evaluating a where clause\nis ",(0,o.mdx)("inlineCode",{parentName:"p"},"C"),", the first example would have a ",(0,o.mdx)("inlineCode",{parentName:"p"},"O(N*Q*C)")," complexity. Using cache\nqueries, this turns into ",(0,o.mdx)("inlineCode",{parentName:"p"},"O(N*C+Q)"),", which is much better."),(0,o.mdx)("h3",{id:"writetocache-clause"},"WriteToCache clause"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"WriteToCache")," is a model clause that is used to store entities into a cache. It\ntakes the following arguments:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},"kind"),", which is the name of the cache."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},"name")," as a ",(0,o.mdx)("a",{parentName:"li",href:"#format-strings"},"format string"),", which will be the key for the\nentity in the cache.")),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  ...\n  find = "methods",\n  model = WriteToCache(kind="cache_name", name=f"{class_name}:{function_name}")\n)\n')),(0,o.mdx)("p",null,"Note that you can write multiple entities under the same name. For instance,\nthis happens if you use ",(0,o.mdx)("inlineCode",{parentName:"p"},'name=f"{class_name}"')," and multiple methods of the same\nclass match against the where clause."),(0,o.mdx)("h3",{id:"read_from_cache-clause"},"read_from_cache clause"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"read_from_cache")," is a where clause that will only match against entities with\nthe given name in the cache. It takes the following arguments:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},"kind"),", which is the name of the cache."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},"name")," as a string, which is the key for the entities in the cache.")),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = read_from_cache(kind="cache_name", name="Class:method"),\n  model = ...\n)\n')),(0,o.mdx)("p",null,"Note that you can use ",(0,o.mdx)("inlineCode",{parentName:"p"},"read_from_cache")," in combination with other where clauses,\nas long as at least one ",(0,o.mdx)("inlineCode",{parentName:"p"},"read_from_cache")," clause is active on all branches."),(0,o.mdx)("p",null,"For instance, this is ",(0,o.mdx)("strong",{parentName:"p"},"disallowed"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "methods",\n  where = AnyOf(\n    read_from_cache(kind="cache_name", name="Class:method"),\n    cls.extends("module.Foo")\n  ),\n  model = ...\n)\n')),(0,o.mdx)("h2",{id:"format-strings"},"Format strings"),(0,o.mdx)("p",null,"Format strings can be used to craft a string using information from the matched\nentity. They can be used in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"WriteToCache")," name argument as well as the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"CrossRepositoryTaintAnchor")," canonical name and port arguments."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},'WriteToCache(kind="cache_name", name=f"{class_name}:{function_name}")')),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},'CrossRepositoryTaintAnchor[TaintSink[Thrift], f"{class_name}:{function_mame}", f"formal({parameter_position + 1})"]'))),(0,o.mdx)("p",null,"The following variables can be used:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"function_name"),": The (non-qualified) name of the function;"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"method_name"),": The (non-qualified) name of the method;"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"class_name"),": The (non-qualified) name of the class;"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"parameter_name"),": The parameter name, when used within the ",(0,o.mdx)("inlineCode",{parentName:"li"},"Parameters"),"\nclause;"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"parameter_position"),": The parameter position, when used within the\n",(0,o.mdx)("inlineCode",{parentName:"li"},"Parameters")," clause. This will give -1 for keyword only parameters;"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"capture(identifier)"),": The regular expression capture group called\n",(0,o.mdx)("inlineCode",{parentName:"li"},"identifier"),". See documentation below.")),(0,o.mdx)("p",null,"Math operators such as ",(0,o.mdx)("inlineCode",{parentName:"p"},"+"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"-")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"*")," can be used on ",(0,o.mdx)("inlineCode",{parentName:"p"},"parameter_position")," and\ninteger literals, such as ",(0,o.mdx)("inlineCode",{parentName:"p"},'f"{parameter_position * 2 + 1}"'),"."),(0,o.mdx)("h3",{id:"regular-expression-capture"},"Regular expression capture"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"name.matches")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls.name.matches")," clause can use named capturing groups,\nwhich can be used in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"name")," of ",(0,o.mdx)("inlineCode",{parentName:"p"},"WriteToCache")," clauses."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  find = "functions",\n  where = name.matches("^get_(?P<attribute>[a-z]+)$"),\n  model = WriteToCache(kind="cache_name", name=f"{capture(attribute)}")\n)\n')),(0,o.mdx)("p",null,"For a function ",(0,o.mdx)("inlineCode",{parentName:"p"},"get_foo"),", this will create a cache for key ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo"),"."),(0,o.mdx)("admonition",{type:"caution"},(0,o.mdx)("p",{parentName:"admonition"},"Be careful when using regular expression captures. If the capture group is not\nfound (e.g, a typo), ",(0,o.mdx)("inlineCode",{parentName:"p"},"WriteToCache")," will use the empty string.")),(0,o.mdx)("p",null,"Note that we do not support numbered capture groups, e.g ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo(.*)"),"."),(0,o.mdx)("h2",{id:"logging-group-clauses"},"Logging group clauses"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"logging_group_name")," clause specifies that the model query should be\nconsidered part of the given group for logging purposes. This is useful when\nauto generating large amounts of model queries. When verbose logging is enabled\n(",(0,o.mdx)("inlineCode",{parentName:"p"},"-n"),"), Pysa will print a single line\n",(0,o.mdx)("inlineCode",{parentName:"p"},"Model Query group 'XXX' generated YYY models")," instead of printing one line per\nmodel query in the group."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name = "generated_dangerous_foo",\n  logging_group_name = "generated_dangerous",\n  find = "methods",\n  where = read_from_cache(kind="annotated", name="foo"),\n  model = ...\n)\nModelQuery(\n  name = "generated_dangerous_bar",\n  logging_group_name = "generated_dangerous",\n  find = "methods",\n  where = read_from_cache(kind="annotated", name="bar"),\n  model = ...\n)\n')))}h.isMDXComponent=!0}}]);