"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[518],{3905:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>m,MDXProvider:()=>u,mdx:()=>h,useMDXComponents:()=>p,withMDXComponents:()=>d});var t=a(67294);function l(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},r.apply(this,arguments)}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){l(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,t,l=function(e,n){if(null==e)return{};var a,t,l={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(l[a]=e[a]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var m=t.createContext({}),d=function(e){return function(n){var a=p(n.components);return t.createElement(e,r({},n,{components:a}))}},p=function(e){var n=t.useContext(m),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(m.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},y=t.forwardRef((function(e,n){var a=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(a),u=l,y=d["".concat(o,".").concat(u)]||d[u]||c[u]||r;return a?t.createElement(y,i(i({ref:n},m),{},{components:a})):t.createElement(y,i({ref:n},m))}));function h(e,n){var a=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var r=a.length,o=new Array(r);o[0]=y;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:l,o[1]=i;for(var m=2;m<r;m++)o[m]=a[m];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}y.displayName="MDXCreateElement"},73268:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>m,toc:()=>p});var t=a(83117),l=a(80102),r=(a(67294),a(3905)),o=["components"],i={id:"querying-pyre",title:"Querying Pyre",sidebar_label:"Querying Pyre"},s=void 0,m={unversionedId:"querying-pyre",id:"querying-pyre",title:"Querying Pyre",description:"These interfaces are considered legacy code by our team. They are far from production-ready, will receive minimal maintenance effort in the short to medium term (for Pysa only) and will eventually be removed in the long term. It is ok if you want to rely on them for debugging or manual triaging purpose. But we would strongly discourage relying on them to build any automation or product on top.",source:"@site/docs/querying_pyre.md",sourceDirName:".",slug:"/querying-pyre",permalink:"/docs/querying-pyre",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/querying_pyre.md",tags:[],version:"current",frontMatter:{id:"querying-pyre",title:"Querying Pyre",sidebar_label:"Querying Pyre"},sidebar:"pyre",previous:{title:"Configuration",permalink:"/docs/configuration"},next:{title:"Pyre-Exclusive Features",permalink:"/docs/features"}},d={},p=[{value:"Supported Queries",id:"supported-queries",level:2},{value:"Attributes",id:"attributes",level:3},{value:"Callees",id:"callees",level:3},{value:"Defines",id:"defines",level:3},{value:"Dump class hierarchy",id:"dump-class-hierarchy",level:3},{value:"Global leaks",id:"global-leaks",level:3},{value:"Less or equal",id:"less-or-equal",level:3},{value:"Model Query",id:"model-query",level:3},{value:"Path of module",id:"path-of-module",level:3},{value:"Save server state",id:"save-server-state",level:3},{value:"Superclasses",id:"superclasses",level:3},{value:"Type",id:"type",level:3},{value:"Types in file",id:"types-in-file",level:3},{value:"Validate Taint Models",id:"validate-taint-models",level:3},{value:"API Details",id:"api-details",level:2},{value:"Location Guidelines",id:"location-guidelines",level:3},{value:"Batching Queries",id:"batching-queries",level:3},{value:"Caching",id:"caching",level:3}],u={toc:p};function c(e){var n=e.components,a=(0,l.Z)(e,o);return(0,r.mdx)("wrapper",(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("admonition",{type:"warning"},(0,r.mdx)("p",{parentName:"admonition"},"These interfaces are considered legacy code by our team. They are far from production-ready, will receive minimal maintenance effort in the short to medium term (for Pysa only) and will eventually be removed in the long term. It is ok if you want to rely on them for debugging or manual triaging purpose. But we would ",(0,r.mdx)("strong",{parentName:"p"},"strongly discourage")," relying on them to build any automation or product on top.")),(0,r.mdx)("p",null,"Pyre has a subcommand called ",(0,r.mdx)("inlineCode",{parentName:"p"},"query")," allows you to hook into a Pyre server and get type-related\ninformation without having to run a full type check."),(0,r.mdx)("p",null,"This allows you, for instance, to get the type of an expression at a certain line and column, check whether a type is a subtype of the other, or get the list of methods for a class."),(0,r.mdx)("p",null,"To get started, set up a server with ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre start"),". The rest of this page goes through the various query options with examples. You can also run ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre query help")," to see a full list of available queries to the Pyre server."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Note:")," The responses in the examples are prettified using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre query <query> | python -m json.tool")," pattern."),(0,r.mdx)("h2",{id:"supported-queries"},"Supported Queries"),(0,r.mdx)("h3",{id:"attributes"},"Attributes"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"attributes")," gives you the list of attributes for a class."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# a.py\nclass C:\n    a: int = 2\n    def foo(self) -> str:\n        return ""\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "attributes(a.C)"\n{\n    "response": {\n        "attributes": [\n            {\n                "annotation": "int",\n                "name": "a"\n            },\n            {\n                "annotation": "typing.Callable(a.C.foo)[[], str]",\n                "name": "foo"\n            }\n        ]\n    }\n}\n')),(0,r.mdx)("h3",{id:"callees"},"Callees"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"callees")," returns a list of all calls from a given function, including locations if using ",(0,r.mdx)("inlineCode",{parentName:"p"},"callees_from_location"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# a.py\ndef foo() -> None: pass\ndef bar() -> None:\n    foo()\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "callees(a.bar)"\n{\n    "response": {\n        "callees": [\n            {\n                "kind": "function",\n                "target": "a.foo"\n            }\n        ]\n    }\n}\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "callees_with_location(a.bar)"\n{\n    "response": {\n        "callees": [\n            {\n                "locations": [\n                    {\n                        "path": "a.py",\n                        "start": {\n                            "line": 6,\n                            "column": 5\n                        },\n                        "stop": {\n                            "line": 6,\n                            "column": 8\n                        }\n                    }\n                ],\n                "kind": "function",\n                "target": "a.foo"\n            }\n        ]\n    }\n}\n')),(0,r.mdx)("h3",{id:"defines"},"Defines"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"defines")," returns all function and method definitions for a given module or class."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# a.py\nclass C:\n    a: int = 2\n    def foo(self) -> str:\n        return ""\n\ndef bar() -> None: pass\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "defines(a.C)"\n{\n    "response": [\n        {\n            "name": "a.C.foo",\n            "parameters": [\n                {\n                    "name": "self",\n                    "annotation": null\n                }\n            ],\n            "return_annotation": "str"\n        }\n    ]\n}\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "defines(a)"\n{\n    "response": [\n        {\n            "name": "a.C.foo",\n            "parameters": [\n                {\n                    "name": "self",\n                    "annotation": null\n                }\n            ],\n            "return_annotation": "str"\n        },\n        {\n            "name": "a.bar",\n            "parameters": [],\n            "return_annotation": "None"\n        }\n    ]\n}\n')),(0,r.mdx)("h3",{id:"dump-class-hierarchy"},"Dump class hierarchy"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"dump_class_hierarchy()")," returns the entire class hierarchy as Pyre understands it; elides type variables."),(0,r.mdx)("h3",{id:"global-leaks"},"Global leaks"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"global_leaks([function1[, function2[, ...]]])")," gives you the list of mutations to global variables and class attributes within the bodies of the given callables. If no callables are provided to the query, it is a no-op."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# a.py\nclass A:\n    my_class_variable: int = 3\n\n    def foo(self) -> None:\n        pass\n\n# b/c.py\nfrom a import A\nfrom typing import Dict\n\nMY_GLOBAL: Dict[str, int] = {"a": 1}\n\ndef bar() -> None:\n    A.my_class_variable = 4\n\ndef baz() -> None:\n    MY_GLOBAL.setdefault("b", 2)\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "global_leaks(a.A.foo, b.c.bar, b.c.baz)"\n{\n  "response": {\n    "query_errors": [],\n    "global_leaks": [\n      {\n        "line": 8,\n        "column": 4,\n        "stop_line": 8,\n        "stop_column": 27,\n        "path": "/path/to/b/c.py",\n        "code": 3103,\n        "name": "Leak to a class variable",\n        "description": "Leak to a class variable [3103]: Data write to global variable `a.A` of type `typing.Type[a.A]`.",\n        "long_description": "Leak to a class variable [3103]: Data write to global variable `a.A` of type `typing.Type[a.A]`.",\n        "concise_description": "Leak to a class variable [3103]: Data write to global variable `A` of type `typing.Type[a.A]`.",\n        "define": "b.c.bar"\n      },\n      {\n        "line": 12,\n        "column": 4,\n        "stop_line": 12,\n        "stop_column": 24,\n        "path": "/path/to/b/c.py",\n        "code": 3101,\n        "name": "Leak to a mutable datastructure",\n        "description": "Leak to a mutable datastructure [3101]: Data write to global variable `b.c.MY_GLOBAL` of type `typing.Dict[str, int]`.",\n        "long_description": "Leak to a mutable datastructure [3101]: Data write to global variable `b.c.MY_GLOBAL` of type `typing.Dict[str, int]`.",\n        "concise_description": "Leak to a mutable datastructure [3101]: Data write to global variable `MY_GLOBAL` of type `typing.Dict[str, int]`.",\n        "define": "b.c.baz"\n      }\n    ]\n  }\n}\n')),(0,r.mdx)("p",null,"Five kinds of leaks are checked for, which can be found in ",(0,r.mdx)("inlineCode",{parentName:"p"},"source/analysis/analysisError.ml"),", under the ",(0,r.mdx)("inlineCode",{parentName:"p"},"GlobalLeaks")," module:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"Direct mutations to a global",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"The mutation methods checked for include any mutation methods on ",(0,r.mdx)("inlineCode",{parentName:"li"},"dict"),", ",(0,r.mdx)("inlineCode",{parentName:"li"},"list"),", or ",(0,r.mdx)("inlineCode",{parentName:"li"},"set"),", as well as ",(0,r.mdx)("inlineCode",{parentName:"li"},"__setitem__")," calls on any type.")))),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def foo() -> None:\n    MY_GLOBAL = 1  # leak\n    MY_LIST.append(1)  # leak\n    MY_DICT["a"] = 2  # leak\n    MY_SET |= {2}  # leak\n\n    MY_CUSTOM_GLOBAL.custom_mutation_method(5)  # no leak\n')),(0,r.mdx)("ol",{start:2},(0,r.mdx)("li",{parentName:"ol"},"Mutations of class attributes",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"The same cases as direct mutations to a global are checked, as well as ",(0,r.mdx)("inlineCode",{parentName:"li"},"__setattr__")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},"setattr(...)")," calls on any type.")))),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def foo() -> None:\n    MY_GLOBAL.x = 1  # leak\n    MY_GLOBAL.y.z.a.b = 1  # leak\n    MY_GLOBAL.some_list.append(3)  # leak\n    setattr(MY_GLOBAL, "b", 2)  # leak\n    MY_GLOBAL.__setattr__("c", 3)  # leak\n')),(0,r.mdx)("ol",{start:3},(0,r.mdx)("li",{parentName:"ol"},"Assignment of a global or its attributes into a local variable")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo() -> None:\n    my_local: int = MY_GLOBAL_INT  # leak\n    my_other_local: List[str] = MY_OTHER_GLOBAL.str_list  # leak\n")),(0,r.mdx)("ol",{start:4},(0,r.mdx)("li",{parentName:"ol"},"Passing a global or its attribtues as a parameter")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo() -> None:\n    my_other_function(MY_GLOBAL)  # leak\n    a = MyClass()\n    a.some_method(MY_GLOBAL.x)  # leak\n")),(0,r.mdx)("ol",{start:5},(0,r.mdx)("li",{parentName:"ol"},"Returning a global or its attributes from a function or method")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo() -> None:\n    return MY_GLOBAL  # leak\n\ndef bar() -> None:\n    return MY_GLOBAL.x  # leak\n")),(0,r.mdx)("h3",{id:"less-or-equal"},"Less or equal"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"less_or_equal")," returns whether the type on the left can be used when the type on the right is expected."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# a.py\nclass C:\n  pass\n\nclass D(C):\n  pass\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "less_or_equal(a.D, a.C)"\n{"response":{"boolean":true}}\n\n$ pyre query "less_or_equal(a.C, a.D)"\n{"response":{"boolean":true}}\n')),(0,r.mdx)("h3",{id:"model-query"},"Model Query"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"model_query")," returns the models generated by a given ModelQuery. Valid ",(0,r.mdx)("inlineCode",{parentName:"p"},"path")," inputs are absolute paths to directories containing a ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config")," file. One can find all valid ",(0,r.mdx)("inlineCode",{parentName:"p"},"path"),"s by using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"validate_taint_models")," command."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# a.py\ndef foo(x):\n    ...\ndef food(y):\n    ...\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# test.pysa\nModelQuery(\n    name = "get_foo_sources",\n    find = "functions",\n    where = [\n        name.matches("foo")\n    ],\n    model = [\n        Parameters(TaintSource[Test])\n    ]\n)\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "model_query(path=\'/absolute/path/to/test_pysa/directory\', query_name=\'get_foo_sources\')"\n{\n    "response": [\n        {\n            "callable": "test.foo",\n            "model": {\n                "kind": "model",\n                "data": {\n                    "callable": "test.foo",\n                    "sources": [\n                        {\n                            "port": "formal(x)",\n                            "taint":[\n                                {\n                                    "kinds":[{"kind":"Test"}],\n                                    "decl":null\n                                }\n                            ]\n                        }\n                    ]\n                }\n            }\n        },\n        {\n            "callable": "test.food",\n            "model": {\n                "kind": "model",\n                "data": {\n                    "callable": "test.food",\n                    "sources": [\n                        {\n                            "port": "formal(y)",\n                            "taint":[\n                                {\n                                    "kinds":[{"kind":"Test"}],\n                                    "decl":null\n                                }\n                            ]\n                        }\n                    ]\n                }\n            }\n        }\n    ]\n}\n')),(0,r.mdx)("admonition",{type:"caution"},(0,r.mdx)("p",{parentName:"admonition"},(0,r.mdx)("inlineCode",{parentName:"p"},"pyre query")," does not include external sources by default, which leads to discrepancies\nwith ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre analyze")," (i.e, Pysa). To avoid this problem, we recommend starting\na pyre server with the following parameters:"),(0,r.mdx)("pre",{parentName:"admonition"},(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},"$ pyre --no-saved-state start --skip-initial-type-check --wait-on-initialization --analyze-external-sources\n"))),(0,r.mdx)("h3",{id:"path-of-module"},"Path of module"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"path_of_module")," returns the full absolute path for a given module."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "path_of_module(module_name)"\n{\n    "response": {\n        "path": "/Users/user/my_project/module_name.py"\n    }\n}\n')),(0,r.mdx)("h3",{id:"save-server-state"},"Save server state"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"save_server_state")," saves the server's serialized state into the given ",(0,r.mdx)("inlineCode",{parentName:"p"},"path"),", which can the be used to start up the identical server without re-analyzing all project files."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "save_server_state(\'my_saved_state\')"\n{\n    "response": {\n        "message": "Saved state."\n    }\n}\n$ pyre stop\n$ pyre --load-initial-state-from my_saved_state start\n')),(0,r.mdx)("h3",{id:"superclasses"},"Superclasses"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"superclasses")," returns the superclasses of given class names."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "superclasses(int, str)"\n{\n    "response": [\n        {\n            "int": [\n                "complex",\n                "float",\n                "numbers.Complex",\n                "numbers.Integral",\n                "numbers.Number",\n                "numbers.Rational",\n                "numbers.Real",\n                "object",\n                "typing.Generic",\n                "typing.Protocol",\n                "typing.SupportsFloat"\n            ]\n        },\n        {\n            "str": [\n                "object",\n                "typing.Collection",\n                "typing.Container",\n                "typing.Generic",\n                "typing.Iterable",\n                "typing.Protocol",\n                "typing.Reversible",\n                "typing.Sequence"\n            ]\n        }\n    ]\n}\n')),(0,r.mdx)("h3",{id:"type"},"Type"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"type")," evaluates the type of the given expression."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "type([1 + 2, \'\'])"\n{\n    "response": {\n        "type": "typing.List[typing.Union[int, str]]"\n    }\n}\n')),(0,r.mdx)("h3",{id:"types-in-file"},"Types in file"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"types")," returns all the types for a file that Pyre has been able to resolve. Paths must be relative paths ",(0,r.mdx)("em",{parentName:"p"},"relative to the ",(0,r.mdx)("inlineCode",{parentName:"em"},"pyre_configuration")," for this file"),". It can be called on multiple files at once with\n",(0,r.mdx)("inlineCode",{parentName:"p"},"types('path1', 'path2', ...)"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# a.py\nclass C:\n  attribute = ""\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "types(path=\'a.py\')"\n{\n    "response": [\n        {\n            "path": "a.py",\n            "types": [\n                {\n                    "annotation": "str",\n                    "location": {\n                        "path": "a.py",\n                        "start": {\n                            "column": 16,\n                            "line": 2\n                        },\n                        "stop": {\n                            "column": 18,\n                            "line": 2\n                        }\n                    }\n                },\n                {\n                    "annotation": "str",\n                    "location": {\n                        "path": "a.py",\n                        "start": {\n                            "column": 4,\n                            "line": 2\n                        },\n                        "stop": {\n                            "column": 13,\n                            "line": 2\n                        }\n                    }\n                },\n                {\n                    "annotation": "typing.Type[a.C]",\n                    "location": {\n                        "path": "a.py",\n                        "start": {\n                            "column": 4,\n                            "line": 2\n                        },\n                        "stop": {\n                            "column": 13,\n                            "line": 2\n                        }\n                    }\n                }\n            ]\n        }\n    ]\n}\n')),(0,r.mdx)("h3",{id:"validate-taint-models"},"Validate Taint Models"),(0,r.mdx)("p",null,"The command ",(0,r.mdx)("inlineCode",{parentName:"p"},"validate_taint_models")," returns the absolute paths of all the directories in which Pysa recognises all the models their TARGETS file's environment."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "validate_taint_models()"\n{\n    "response": {\n        "message": "Models in `/data/users/$USER/valid/path/one, /data/users/$USER/valid/path/two` are valid."\n    }\n}\n')),(0,r.mdx)("h2",{id:"api-details"},"API Details"),(0,r.mdx)("h3",{id:"location-guidelines"},"Location Guidelines"),(0,r.mdx)("p",null,"We determine locations for expressions using the following guidelines:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Ignore leading and trailing whitespace, commas, comments, and wrapping parenthesis."),(0,r.mdx)("li",{parentName:"ul"},"Include whitespace, parenthesis or other noop tokens in the locations of compound expressions they are nested inside.",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Ex. ",(0,r.mdx)("inlineCode",{parentName:"li"},"(a).b")," will register two expressions, a at columns 1-2 (still following the guideline above), and ",(0,r.mdx)("inlineCode",{parentName:"li"},"a.b")," at columns 0-5"))),(0,r.mdx)("li",{parentName:"ul"},"Similarly, compound expression locations must encompass the locations of all of its components.",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Ex. ",(0,r.mdx)("inlineCode",{parentName:"li"},"a = b = 1")," will register the assignment ",(0,r.mdx)("inlineCode",{parentName:"li"},"a = 1")," at columns 0-9, with ",(0,r.mdx)("inlineCode",{parentName:"li"},"a")," at columns 0-1 and ",(0,r.mdx)("inlineCode",{parentName:"li"},"1")," at columns 8-9"),(0,r.mdx)("li",{parentName:"ul"},"The only exception are classes, which do not encompass their decorators"))),(0,r.mdx)("li",{parentName:"ul"},"All semantically meaningful tokens and reserved words are included in the node they define.",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Ex. ",(0,r.mdx)("inlineCode",{parentName:"li"},"await a")," will register the awaitable node at columns 0-7, and the included identifier ",(0,r.mdx)("inlineCode",{parentName:"li"},"a")," at columns 6-7"),(0,r.mdx)("li",{parentName:"ul"},"Ex. ",(0,r.mdx)("inlineCode",{parentName:"li"},"async def foo(): ...")," will register the define node at columns 0-20"),(0,r.mdx)("li",{parentName:"ul"},"Ex. ",(0,r.mdx)("inlineCode",{parentName:"li"},"foo(*args, **kwargs)")," will register args at columns 4-9 and kwargs at columns 11-19"),(0,r.mdx)("li",{parentName:"ul"},"Ex. ",(0,r.mdx)("inlineCode",{parentName:"li"},'"""string"""')," will register the string string at columns 0-12"))),(0,r.mdx)("li",{parentName:"ul"},"All implicit values in the AST contribute a length of 0 and point to the closest location to where an equivalent explicit value would live.",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Ex. ",(0,r.mdx)("inlineCode",{parentName:"li"},"a: int")," would register an Ellipsis object at columns 6-6"),(0,r.mdx)("li",{parentName:"ul"},"Ex. ",(0,r.mdx)("inlineCode",{parentName:"li"},"a[0]")," would register a at columns 0-1 and ",(0,r.mdx)("inlineCode",{parentName:"li"},"a.__getitem__")," at columns 0-1"),(0,r.mdx)("li",{parentName:"ul"},"Ex. ",(0,r.mdx)("inlineCode",{parentName:"li"},"a[:1]")," would register the first argument of slice to be ",(0,r.mdx)("inlineCode",{parentName:"li"},"None")," at columns 2-2, the second argument to be ",(0,r.mdx)("inlineCode",{parentName:"li"},"1")," at columns 3-4, and the third argument to be ",(0,r.mdx)("inlineCode",{parentName:"li"},"None")," at columns 4-4.")))),(0,r.mdx)("h3",{id:"batching-queries"},"Batching Queries"),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"batch")," command can be used to run several queries at once and return a map of responses. The list of queries to batch may include any combination of other valid queries except for ",(0,r.mdx)("inlineCode",{parentName:"p"},"batch")," itself."),(0,r.mdx)("p",null,"The response for a ",(0,r.mdx)("inlineCode",{parentName:"p"},"batch")," command will be a list of responses the same length as the number of queries getting batched, and the order of the responses will match the order of the queries."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'$ pyre query "batch(less_or_equal(int, str), join(int, str))"\n{\n    "response": [\n        {\n            "response": {\n                "boolean": false\n            }\n        },\n        {\n            "response": {\n                "type": "typing.Union[int, str]"\n            }\n        }\n    ]\n}\n')),(0,r.mdx)("h3",{id:"caching"},"Caching"),(0,r.mdx)("p",null,"Pyre rechecks each file when queried to generate the location-type mapping, caching results for re-queries of the same file. If you anticipate a large codemod where significant portions of the codebase will be queried, you may increase incremental performance by starting a temporary server with the flag: ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre start --store-type-check-resolution"),"."))}c.isMDXComponent=!0}}]);