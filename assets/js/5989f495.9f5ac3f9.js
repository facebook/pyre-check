"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[900],{15680:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>p,MDXProvider:()=>c,mdx:()=>y,useMDXComponents:()=>u,withMDXComponents:()=>d});var r=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},o.apply(this,arguments)}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),d=function(e){return function(t){var n=u(t.components);return r.createElement(e,o({},t,{components:n}))}},u=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),c=a,g=d["".concat(l,".").concat(c)]||d[c]||m[c]||o;return n?r.createElement(g,i(i({ref:t},p),{},{components:n})):r.createElement(g,i({ref:t},p))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=g;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},62315:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>p,default:()=>y,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var r,a=n(9668),o=n(21367),l=(n(96540),n(15680)),i=["components"],s={id:"pysa-explore",title:"Exploring Taint Models Interactively",sidebar_label:"Exploring Taint Models Interactively"},p=void 0,d={unversionedId:"pysa-explore",id:"pysa-explore",title:"Exploring Taint Models Interactively",description:"Overview",source:"@site/docs/pysa_explore.md",sourceDirName:".",slug:"/pysa-explore",permalink:"/docs/pysa-explore",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/pysa_explore.md",tags:[],version:"current",frontMatter:{id:"pysa-explore",title:"Exploring Taint Models Interactively",sidebar_label:"Exploring Taint Models Interactively"},sidebar:"pysa",previous:{title:"Debugging False Positives and False Negatives",permalink:"/docs/pysa-false-positives-negatives"},next:{title:"Coverage Increasing Strategies",permalink:"/docs/pysa-coverage"}},u={},c=[{value:"Overview",id:"overview",level:2},{value:"Basic Usage",id:"basic-usage",level:2}],m=(r="FbInternalOnly",function(e){return console.warn("Component "+r+" was not imported, exported, or provided by MDXProvider as global scope"),(0,l.mdx)("div",e)}),g={toc:c};function y(e){var t=e.components,n=(0,o.A)(e,i);return(0,l.mdx)("wrapper",(0,a.A)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,l.mdx)("h2",{id:"overview"},"Overview"),(0,l.mdx)("p",null,"After Pysa's analysis is complete, the tool will output a detailed JSON with its final view of the taint of callables in addition to the issues it finds. We provide a script to explore these taint models called ",(0,l.mdx)("inlineCode",{parentName:"p"},"explore_pysa_models.py"),", which can give you insight into why Pysa thinks there might or might not be taint for a given callable."),(0,l.mdx)("h2",{id:"basic-usage"},"Basic Usage"),(0,l.mdx)("p",null,"Before using the explore script, you should already have run Pysa on your codebase. For the purposes of this page, we will assume you stored it in ",(0,l.mdx)("inlineCode",{parentName:"p"},"/tmp/output_dir"),", e.g."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-bash"},"$ pyre analyze --save-results-to /tmp/output_dir\n")),(0,l.mdx)("p",null,"After the analysis succeeds, Pysa will write one or multiple taint output files ",(0,l.mdx)("inlineCode",{parentName:"p"},"/tmp/output_dir/taint-output.json"),", containing the taint of each callable in addition to the issues found. Let's load this JSON into our explore script:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-bash"},"$ python3 -i scripts/explore_pysa_models.py\n# Pysa Model Explorer\nAvailable commands:\n  index('/path/to/results-directory') Index all available models in the given taint output directory.\n  callables_containing('foo.bar')     Find all callables containing the given string.\n  callables_matching(r'foo\\..*')      Find all callables matching the given regular expression.\n  get_model('foo.bar')                Get the model for the given callable.\n  print_model('foo.bar')              Pretty print the model for the given callable.\n                                      Optional parameters:\n                                        kind='UserControlled'      Filter by taint kind.\n                                        caller_port='result'       Filter by caller port.\n                                        remove_sources=False\n                                        remove_sinks=False\n                                        remove_tito=False\n                                        remove_tito_positions=True\n                                        remove_features=True\n                                        remove_leaf_names=True\n  get_issues('foo.bar')               Get all issues within the given callable.\n  print_issues('foo.bar')             Pretty print the issues within the given callable.\n  print_json({'a': 'b'})              Pretty print json objects with syntax highlighting.\n")),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},">>> index('/tmp/output_dir')\nIndexing `/tmp/output_dir/taint-output.json`\nIndexed 307120 models\n")),(0,l.mdx)(m,{mdxType:"FbInternalOnly"},(0,l.mdx)("p",null,"Internally at Meta, we can use Bento to run the model explorer:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-bash"},"$ python3 ~/fbsource/fbcode/tools/pyre/facebook/scripts/in_path/pysa-explore-models\n")),(0,l.mdx)("p",null,"Bento can be installed with"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-bash"},"$ feature install bento\n")),(0,l.mdx)("p",null,"Note: if you are using the ",(0,l.mdx)("a",{parentName:"p",href:"fb/getting_started.md#shell-integrations-for-managing-the-frontend-and-backend"},"shell integration"),", you can simply run ",(0,l.mdx)("inlineCode",{parentName:"p"},"pysa-explore-models"),".")),(0,l.mdx)("p",null,"Once we've indexed our taint JSON, we're good to go! Let's investigate what models Pysa finds for HttpRequest. First, we'll need to get the full name of the relevant callables:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},">>> callables_containing('HttpRequest')\n['django.http.request.HttpRequest.__init__', 'django.http.request.HttpRequest.body', ...]\n>>> get_model('django.http.request.HttpRequest.__init_')\n{'callable': 'django.http.request.HttpRequest.__init__', 'sources': [], 'sinks': [], 'tito': [{'port': 'formal(self)', 'taint': [{'decl': None, 'leaves': [{'kind': 'LocalReturn', 'name': ''}]}]}]}\n")),(0,l.mdx)("p",null,"This (hard-to-parse) JSON is all that Pysa knows about the ",(0,l.mdx)("inlineCode",{parentName:"p"},"HttpRequest.__init__")," function. If you squint, you'll see that the model doesn't introduce any sources or sinks (as expected), but has taint-in-taint-out for the ",(0,l.mdx)("inlineCode",{parentName:"p"},"self")," parameter."),(0,l.mdx)("p",null,"Let's take a look at ",(0,l.mdx)("inlineCode",{parentName:"p"},"body"),", a slightly more interesting function. We'll also swap to using the ",(0,l.mdx)("inlineCode",{parentName:"p"},"print_model()")," function which will pretty print the output:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'>>> print_model(\'django.http.request.HttpRequest.body\')\n{\n  "callable": "django.http.request.HttpRequest.body",\n  "sources": [\n    {\n      "port": "result",\n      "taint": [\n        {\n          "decl": null,\n          "kinds": [\n            {\n              "kind": "UserControlled"\n            }\n          ]\n        },\n      ]\n    }\n  ],\n  "sinks": [],\n  ...\n')),(0,l.mdx)("p",null,"Much easier to read! This model shows that the ",(0,l.mdx)("inlineCode",{parentName:"p"},"body")," property of HttpRequests returns a UserControlled source."),(0,l.mdx)("p",null,"You can also use the ",(0,l.mdx)("inlineCode",{parentName:"p"},"get_issues"),", and corresponding pretty-printing ",(0,l.mdx)("inlineCode",{parentName:"p"},"print_issues")," functions to see all issues in a given callable."),(0,l.mdx)("p",null,"Note that the ",(0,l.mdx)("inlineCode",{parentName:"p"},"get_issues")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"get_models")," functions return Python objects that you can manipulate:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'>>> print_json(get_issues(\'foo.bar.log_errors\')[0]) # This is valid, will print first issue!\n...\n>>> print_json(get_model(\'django.http.request.HttpRequest.body\')["sources"]) # Pretty print only the sources.\n[\n  {\n    "port": "result",\n    "taint": [\n      {\n        "decl": null,\n        "kinds": [\n          {\n            "kind": "UserControlled"\n          }\n        ]\n      },\n    ]\n  }\n]\n')))}y.isMDXComponent=!0}}]);