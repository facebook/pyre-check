"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6432],{15680:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>p,MDXProvider:()=>c,mdx:()=>h,useMDXComponents:()=>m,withMDXComponents:()=>d});var a=n(96540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),d=function(e){return function(t){var n=m(t.components);return a.createElement(e,r({},t,{components:n}))}},m=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=m(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=m(n),c=o,y=d["".concat(i,".").concat(c)]||d[c]||u[c]||r;return n?a.createElement(y,s(s({ref:t},p),{},{components:n})):a.createElement(y,s({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=y;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"},3416:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>p,toc:()=>m});var a=n(9668),o=n(21367),r=(n(96540),n(15680)),i=["components"],s={id:"types-in-python",title:"Types in Python",sidebar_label:"Introduction"},l=void 0,p={unversionedId:"types-in-python",id:"types-in-python",title:"Types in Python",description:"Python's type system was specified in PEP 484. If you are new to Python's type system and want to learn the basics, we highly recommend you take a look at mypy's cheatsheet as well as their type system reference. The following discussion focuses on Pyre's approach to \"gradual typing\" and how you can get from an untyped codebase to a fully typed codebase.",source:"@site/docs/gradual_typing.md",sourceDirName:".",slug:"/types-in-python",permalink:"/docs/types-in-python",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/gradual_typing.md",tags:[],version:"current",frontMatter:{id:"types-in-python",title:"Types in Python",sidebar_label:"Introduction"},sidebar:"pyre",previous:{title:"Types in Python",permalink:"/docs/category/types-in-python"},next:{title:"Type Errors",permalink:"/docs/errors"}},d={},m=[{value:"Why Types?",id:"why-types",level:2},{value:"Gradual Typing",id:"gradual-typing",level:2},{value:"Strict Mode",id:"strict-mode",level:2},{value:"Strict-By-Default",id:"strict-by-default",level:3},{value:"How to move away from <code>Any</code>",id:"how-to-move-away-from-any",level:2},{value:"What if I want to use <code>Any</code>?",id:"what-if-i-want-to-use-any",level:3},{value:"What then?",id:"what-then",level:3},{value:"About <code>object</code>",id:"about-object",level:3},{value:"About <code>TypeVar</code>",id:"about-typevar",level:3},{value:"When Source Code is not Available",id:"when-source-code-is-not-available",level:2},{value:"Typeshed",id:"typeshed",level:3},{value:"Strategies for Increasing Coverage",id:"strategies-for-increasing-coverage",level:2},{value:"Upgrade",id:"upgrade",level:3},{value:"Automatic Type Inference",id:"automatic-type-inference",level:3}],c={toc:m};function u(e){var t=e.components,n=(0,o.A)(e,i);return(0,r.mdx)("wrapper",(0,a.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Python's type system was specified in ",(0,r.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0484/"},"PEP 484"),". If you are new to Python's type system and want to learn the basics, we highly recommend you take a look at ",(0,r.mdx)("a",{parentName:"p",href:"https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html"},"mypy's cheatsheet")," as well as their ",(0,r.mdx)("a",{parentName:"p",href:"https://mypy.readthedocs.io/en/stable/builtin_types.html"},"type system reference"),'. The following discussion focuses on Pyre\'s approach to "gradual typing" and how you can get from an untyped codebase to a fully typed codebase.'),(0,r.mdx)("h2",{id:"why-types"},"Why Types?"),(0,r.mdx)("h2",{id:"gradual-typing"},"Gradual Typing"),(0,r.mdx)("p",null,"Most Python code does not (yet) start out typed. PEP 484 specifies a ",(0,r.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Gradual_typing"},"gradual type system"),", which is built to allow you to ",(0,r.mdx)("em",{parentName:"p"},"gradually")," add annotations over time. It does so by"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"only reporting errors on functions that have an explicit return or parameter type annotation,"),(0,r.mdx)("li",{parentName:"ul"},"introducing an escape hatch: a special type ",(0,r.mdx)("inlineCode",{parentName:"li"},"Any")," that has all possible attributes and is both sub- and super-type of any other type,"),(0,r.mdx)("li",{parentName:"ul"},"and assuming that all untyped fuctions implicitly return ",(0,r.mdx)("inlineCode",{parentName:"li"},"Any"),".")),(0,r.mdx)("p",null,"For example,"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import List\n\ndef unannotated():        # implictly returns `Any`\n    return b"" + ""       # function body is not checked\n\ndef annotated() -> List:  # explicit return annotation means we type check `annotated`\n    any = unannotated()\n    any.attribute         # `Any` has all possible attributes\n    return 1              # Error: returning `int` but expecting `List`\n')),(0,r.mdx)("p",null,"In combination, these rules allow you to slowly annotate code without getting overwhelmed by type errors in one sitting. Incrementally adding more annotations will give you stronger safety and consistency guarantees in your codebase."),(0,r.mdx)("p",null,"In the example above, if you changed ",(0,r.mdx)("inlineCode",{parentName:"p"},"unannotated")," to return ",(0,r.mdx)("inlineCode",{parentName:"p"},"str"),", you would get a type error when accessing the attribute ",(0,r.mdx)("inlineCode",{parentName:"p"},"any.attribute")," in ",(0,r.mdx)("inlineCode",{parentName:"p"},"annotated"),"."),(0,r.mdx)("h2",{id:"strict-mode"},"Strict Mode"),(0,r.mdx)("p",null,"While ",(0,r.mdx)("inlineCode",{parentName:"p"},"Any")," is a necessary escape hatch when annotating large codebases over time, it can hide legitimate type errors. We've introduced ",(0,r.mdx)("em",{parentName:"p"},"strict mode")," in Pyre to address this problem. Strict mode can be toggled at a module level by introducing a ",(0,r.mdx)("inlineCode",{parentName:"p"},"# pyre-strict")," comment to the file. In strict mode, Pyre will"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"run on all functions, whether they are annotated or not,"),(0,r.mdx)("li",{parentName:"ul"},"error on functions, globals, or attributes that are missing annotations,"),(0,r.mdx)("li",{parentName:"ul"},"and error on annotations containing ",(0,r.mdx)("inlineCode",{parentName:"li"},"Any")," (with some exceptions to accommodate for common patterns).")),(0,r.mdx)("p",null,"In our previous example,"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# pyre-strict\nfrom typing import List\n\ndef unannotated():        # Error: missing return annotation\n    return b"" + ""       # Error: function body *is* checked\n\ndef annotated() -> List:  # Error: implicit `Any` for generic parameter to `List`\n    any = unannotated()\n    any.attribute         # Note: the type of `any` is still any.\n    return 1              # Error: returning `int` but expecting `List`\n')),(0,r.mdx)("p",null,"As you can see in the example, ",(0,r.mdx)("inlineCode",{parentName:"p"},"Any")," can still sneak into modules that are strict, but increasing strict coverage and fixing the surfaced errors will gradually eliminate them."),(0,r.mdx)("h3",{id:"strict-by-default"},"Strict-By-Default"),(0,r.mdx)("p",null,"Strict mode can also be set as the default in a ",(0,r.mdx)("a",{parentName:"p",href:"/docs/configuration"},"project configuration"),". To opt individual files out of strict mode, use ",(0,r.mdx)("inlineCode",{parentName:"p"},"# pyre-unsafe")," in place of ",(0,r.mdx)("inlineCode",{parentName:"p"},"# pyre-strict"),"."),(0,r.mdx)("h2",{id:"how-to-move-away-from-any"},"How to move away from ",(0,r.mdx)("inlineCode",{parentName:"h2"},"Any")),(0,r.mdx)("h3",{id:"what-if-i-want-to-use-any"},"What if I want to use ",(0,r.mdx)("inlineCode",{parentName:"h3"},"Any"),"?"),(0,r.mdx)("p",null,"It may be tempting to annotate a generic function parameter with ",(0,r.mdx)("inlineCode",{parentName:"p"},"Any"),". But while it is a convenient utility for quickly annotating untyped code, it has no place in a strict-mode codebase. The main problem with ",(0,r.mdx)("inlineCode",{parentName:"p"},"Any")," is that it unifies with every type - which effectively hides all potential type errors that could stem from incorrect usage of anything annotated with ",(0,r.mdx)("inlineCode",{parentName:"p"},"Any"),". It is not, therefore, a good idea to use it in generic code."),(0,r.mdx)("h3",{id:"what-then"},"What then?"),(0,r.mdx)("p",null,"We have two main methods for annotating generic code: ",(0,r.mdx)("inlineCode",{parentName:"p"},"object")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"TypeVar"),". As it turns out, it is not at all obvious which of them should be used where. However, the general ",(0,r.mdx)("strong",{parentName:"p"},"TL;DR")," is that ",(0,r.mdx)("inlineCode",{parentName:"p"},"object")," is an opaque superclass of all types, while ",(0,r.mdx)("inlineCode",{parentName:"p"},"TypeVar")," is for preserving a type across one or more function calls."),(0,r.mdx)("h3",{id:"about-object"},"About ",(0,r.mdx)("inlineCode",{parentName:"h3"},"object")),(0,r.mdx)("p",null,"The advantage of using ",(0,r.mdx)("inlineCode",{parentName:"p"},"object")," over ",(0,r.mdx)("inlineCode",{parentName:"p"},"Any")," is that while any type can be \u201cput inside\u201d it, it is an error to use it as any type other than ",(0,r.mdx)("inlineCode",{parentName:"p"},"object"),". This can be useful everywhere we need type erasure, like (de)serialization or generic heterogeneous containers where there is no obvious common supertype. Thanks to Python\u2019s runtime reflection, the original type can be recovered, e.g. through ",(0,r.mdx)("inlineCode",{parentName:"p"},"isinstance"),". Note that such checks are valid only for a short time, see ",(0,r.mdx)("a",{parentName:"p",href:"/docs/errors#optional-attributes"},"here"),"."),(0,r.mdx)("h3",{id:"about-typevar"},"About ",(0,r.mdx)("inlineCode",{parentName:"h3"},"TypeVar")),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"TypeVar"),"s are somewhat interesting beasts, as in a vacuum, they can behave both like ",(0,r.mdx)("inlineCode",{parentName:"p"},"Any")," and like ",(0,r.mdx)("inlineCode",{parentName:"p"},"object"),". Like ",(0,r.mdx)("inlineCode",{parentName:"p"},"object"),", they accept all types, but within a single typecheck (i.e. one line/function call/operation) they remember what type they were. This makes them useful for e.g. linking the parameters and return types of a function, or class attribute types with its method signatures. There are, however, a couple of caveats. It doesn\u2019t make sense to use a TypeVar on a function or method when it\u2019s only used in its parameters (just use the most general known supertype instead).\nAnother story is the difference between ",(0,r.mdx)("inlineCode",{parentName:"p"},"TypeVar"),"s\u2019 invariance, variance and contravariance, which is covered in ",(0,r.mdx)("a",{parentName:"p",href:"/docs/errors#covariance-and-contravariance"},"here"),"."),(0,r.mdx)("h2",{id:"when-source-code-is-not-available"},"When Source Code is not Available"),(0,r.mdx)("p",null,"We do not always have access to all the source code that contributes type information to our project: e.g. ",(0,r.mdx)("inlineCode",{parentName:"p"},"builtins")," is compiled native code, and other libraries may be using ",(0,r.mdx)("em",{parentName:"p"},"Cython"),". Other times, we may be working with Python code that is just too dynamic to be reasonably typed."),(0,r.mdx)("p",null,"To address these cases, Pyre will give precedence to type ",(0,r.mdx)("em",{parentName:"p"},"stub files")," with a ",(0,r.mdx)("inlineCode",{parentName:"p"},"*.pyi")," extension over source files when these are specified in the search path in the ",(0,r.mdx)("a",{parentName:"p",href:"/docs/configuration"},"project configuration")," or if they are located next to the implementation file.\nStub files have the same structure as implementation files but only contain class and function signatures:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# my_dynamic_module.pyi\ndef dynamic_function() -> int: ...   # Function body is omitted\n")),(0,r.mdx)("p",null,"If a ",(0,r.mdx)("inlineCode",{parentName:"p"},"__getattr__")," function is defined in the stub file as follows, Pyre will take it as a signal that the stub file is partially complete: accessing attributes whose name is not defined in the stub file will result in ",(0,r.mdx)("inlineCode",{parentName:"p"},"Any")," instead of a type error."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# my_stub.pyi\nfrom typing import Any\nfoo: int = 42\n# Parameter needs to be typed as `str` and return type needs to be `Any`\ndef __getattr__(name: str) -> Any: ...\n\n# my_source.py\nimport my_stub\nreveal_type(my_stub.foo)        # Reveals `int`\nreveal_type(my_stub.undefined)  # Reveals `Any`\n")),(0,r.mdx)("h3",{id:"typeshed"},"Typeshed"),(0,r.mdx)("h2",{id:"strategies-for-increasing-coverage"},"Strategies for Increasing Coverage"),(0,r.mdx)("p",null,"Pyre comes with tooling to make it easy to increase type coverage in your project."),(0,r.mdx)("h3",{id:"upgrade"},"Upgrade"),(0,r.mdx)("p",null,"When upgrading the type checker, new errors inevitably get surfaced. In order to keep a codebase clean through upgrades we've built ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre-upgrade"),", which automatically ",(0,r.mdx)("a",{parentName:"p",href:"/docs/errors#suppression"},"suppresses")," newly surfaced type errors. It takes Pyre's output and adds supression comments to the code explaining what's wrong so that developers can easily address the issues individually."),(0,r.mdx)("p",null,"You can run ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre-upgrade")," with"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},"(venv) $ pyre --output=json | pyre-upgrade fixme\n")),(0,r.mdx)("p",null,"or if you are using a local configuration"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},"(venv) $ pyre --output=json -l <project> | pyre-upgrade fixme\n")),(0,r.mdx)("h3",{id:"automatic-type-inference"},"Automatic Type Inference"),(0,r.mdx)("p",null,"We have found tools that automatically add type annotations to code useful to get started with a project. There are two general approaches to automatic type inference: static inference and dynamic inference from runtime information. Both approaches come with their own trade-offs and we have found a combination of the two to be useful."),(0,r.mdx)("p",null,"Pyre can do static type inference. You can run"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},"(venv) $ cd <path to project>; pyre infer -i\n")),(0,r.mdx)("p",null,"to automatically apply annotations."),(0,r.mdx)("p",null,"For dynamic inference we recommend you give ",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/Instagram/MonkeyType"},"MonkeyType")," a try."))}u.isMDXComponent=!0}}]);