"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6367],{3905:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>p,MDXProvider:()=>c,mdx:()=>h,useMDXComponents:()=>m,withMDXComponents:()=>d});var t=a(67294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},i.apply(this,arguments)}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=t.createContext({}),d=function(e){return function(n){var a=m(n.components);return t.createElement(e,i({},n,{components:a}))}},m=function(e){var n=t.useContext(p),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},c=function(e){var n=m(e.components);return t.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},y=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=m(a),c=r,y=d["".concat(o,".").concat(c)]||d[c]||u[c]||i;return a?t.createElement(y,l(l({ref:n},p),{},{components:a})):t.createElement(y,l({ref:n},p))}));function h(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=y;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}y.displayName="MDXCreateElement"},19764:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>m,contentTitle:()=>p,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var t,r=a(83117),i=a(80102),o=(a(67294),a(3905)),l=["components"],s={id:"errors",title:"Type Errors",sidebar_label:"Type Errors"},p=void 0,d={unversionedId:"errors",id:"errors",title:"Type Errors",description:"Common Issues",source:"@site/docs/errors.md",sourceDirName:".",slug:"/errors",permalink:"/docs/errors",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/errors.md",tags:[],version:"current",frontMatter:{id:"errors",title:"Type Errors",sidebar_label:"Type Errors"},sidebar:"pyre",previous:{title:"Introduction",permalink:"/docs/types-in-python"},next:{title:"Type Checker Features",permalink:"/docs/category/type-checker-features"}},m={},c=[{value:"Common Issues",id:"common-issues",level:2},{value:"Covariance and Contravariance",id:"covariance-and-contravariance",level:3},{value:"Contravariance",id:"contravariance",level:4},{value:"Optional Attributes",id:"optional-attributes",level:3},{value:"Third-Party Libraries",id:"third-party-libraries",level:3},{value:"Error Codes",id:"error-codes",level:2},{value:"0: Unused Ignore",id:"0-unused-ignore",level:3},{value:"2: Missing Parameter Annotation",id:"2-missing-parameter-annotation",level:3},{value:"3: Missing Return Annotation",id:"3-missing-return-annotation",level:3},{value:"4: Missing Attribute Annotation",id:"4-missing-attribute-annotation",level:3},{value:"5: Missing Global Annotation",id:"5-missing-global-annotation",level:3},{value:"6: Incompatible Parameter Type",id:"6-incompatible-parameter-type",level:3},{value:"7: Incompatible Return Type",id:"7-incompatible-return-type",level:3},{value:"8: Incompatible Attribute Type",id:"8-incompatible-attribute-type",level:3},{value:"9: Incompatible Variable Type",id:"9-incompatible-variable-type",level:3},{value:"10: Unbound Name",id:"10-unbound-name",level:3},{value:"11, 31: Undefined or Invalid Type",id:"11-31-undefined-or-invalid-type",level:3},{value:"Type Aliases",id:"type-aliases",level:4},{value:"ParamSpec",id:"paramspec",level:4},{value:"12: Incompatible Awaitable Type",id:"12-incompatible-awaitable-type",level:3},{value:"13: Uninitialized Attribute",id:"13-uninitialized-attribute",level:3},{value:"Dataclass-like classes",id:"dataclass-like-classes",level:4},{value:"14,15: Behavioral Subtyping",id:"1415-behavioral-subtyping",level:3},{value:"Common Reasons",id:"common-reasons",level:4},{value:"16: Missing Attributes",id:"16-missing-attributes",level:3},{value:"Explicitly Declare the Attribute",id:"explicitly-declare-the-attribute",level:4},{value:"Implicitly Declare the Attribute",id:"implicitly-declare-the-attribute",level:4},{value:"Common Reasons",id:"common-reasons-1",level:4},{value:"17: Incompatible Constructor Annotation",id:"17-incompatible-constructor-annotation",level:3},{value:"19: Too Many Arguments",id:"19-too-many-arguments",level:3},{value:"20: Missing Argument",id:"20-missing-argument",level:3},{value:"21: Undefined Name, Undefined Import",id:"21-undefined-name-undefined-import",level:3},{value:"Namespace Package Modules",id:"namespace-package-modules",level:4},{value:"22: Redundant Cast",id:"22-redundant-cast",level:3},{value:"23: Unable to Unpack",id:"23-unable-to-unpack",level:3},{value:"24: Invalid Type Parameters",id:"24-invalid-type-parameters",level:3},{value:"&quot;Generic type expects X type parameters ...&quot;",id:"generic-type-expects-x-type-parameters-",level:4},{value:"&quot;Non-generic type cannot take type parameters ...&quot;",id:"non-generic-type-cannot-take-type-parameters-",level:4},{value:"&quot;Type parameter violates constraints ...&quot;",id:"type-parameter-violates-constraints-",level:4},{value:"26: Typed Dictionary Access With Non-Literal",id:"26-typed-dictionary-access-with-non-literal",level:3},{value:"27: Typed Dictionary Key Not Found",id:"27-typed-dictionary-key-not-found",level:3},{value:"28: Unexpected Keyword",id:"28-unexpected-keyword",level:3},{value:"29: Call Error",id:"29-call-error",level:3},{value:"30, 36: Terminating Analysis, Mutually Recursive Type Variables",id:"30-36-terminating-analysis-mutually-recursive-type-variables",level:3},{value:"Overly-complex Functions",id:"overly-complex-functions",level:4},{value:"Other Analysis Failures",id:"other-analysis-failures",level:4},{value:"31: Invalid Type",id:"31-invalid-type",level:3},{value:"32: Invalid Argument",id:"32-invalid-argument",level:3},{value:"33: Prohibited Any",id:"33-prohibited-any",level:3},{value:"34: Invalid Type Variable",id:"34-invalid-type-variable",level:3},{value:"Decorator Factories",id:"decorator-factories",level:4},{value:"35: Illegal Annotation Target",id:"35-illegal-annotation-target",level:3},{value:"39: Invalid Inheritance",id:"39-invalid-inheritance",level:3},{value:"40: Invalid Override",id:"40-invalid-override",level:3},{value:"41: Invalid Assignment",id:"41-invalid-assignment",level:3},{value:"42: Missing Overload Implementation",id:"42-missing-overload-implementation",level:3},{value:"43: Incompatible Overload Implementation",id:"43-incompatible-overload-implementation",level:3},{value:"45: Invalid Class Instantiation",id:"45-invalid-class-instantiation",level:3},{value:"46: Invalid Type Variance",id:"46-invalid-type-variance",level:3},{value:"47: Invalid Method Signature",id:"47-invalid-method-signature",level:3},{value:"48: Invalid Exception",id:"48-invalid-exception",level:3},{value:"49: Unsafe Cast",id:"49-unsafe-cast",level:3},{value:"51: Unused Local Mode",id:"51-unused-local-mode",level:3},{value:"52: Private Protocol Property",id:"52-private-protocol-property",level:3},{value:"53: Missing Annotation For Captured Variables",id:"53-missing-annotation-for-captured-variables",level:3},{value:"54: Invalid TypedDict Operation",id:"54-invalid-typeddict-operation",level:3},{value:"55: TypedDict Initialization Error",id:"55-typeddict-initialization-error",level:3},{value:"56: Invalid Decoration",id:"56-invalid-decoration",level:3},{value:"&quot;Pyre was not able to infer the type of the decorator ...&quot;",id:"pyre-was-not-able-to-infer-the-type-of-the-decorator-",level:4},{value:"&quot;Pyre was not able to infer the type of argument ...&quot;",id:"pyre-was-not-able-to-infer-the-type-of-argument-",level:4},{value:"&quot;Decorator factory `X` could not be called&quot;",id:"decorator-factory-x-could-not-be-called",level:4},{value:"&quot;Decorator `X` could not be called&quot;",id:"decorator-x-could-not-be-called",level:4},{value:"&quot;While applying decorator factory ...&quot;",id:"while-applying-decorator-factory-",level:4},{value:"&quot;While applying decorator ...&quot;",id:"while-applying-decorator-",level:4},{value:"57: Incompatible Async Generator Return Type",id:"57-incompatible-async-generator-return-type",level:3},{value:"58: Unsupported Operand",id:"58-unsupported-operand",level:3},{value:"59: Duplicate Type Variables",id:"59-duplicate-type-variables",level:3},{value:"60: Unable to Concatenate Tuple",id:"60-unable-to-concatenate-tuple",level:3},{value:"&quot;Expected to unpack an iterable ...&quot;",id:"expected-to-unpack-an-iterable-",level:4},{value:"&quot;Concatenation not yet supported for multiple variadic tuples ...&quot;",id:"concatenation-not-yet-supported-for-multiple-variadic-tuples-",level:4},{value:"61: Uninitialized Local",id:"61-uninitialized-local",level:3},{value:"Not initialized in all branches of condition",id:"not-initialized-in-all-branches-of-condition",level:4},{value:"Initialized only inside a <code>for</code> loop",id:"initialized-only-inside-a-for-loop",level:4},{value:"Initialized in <code>try</code> block",id:"initialized-in-try-block",level:4},{value:"62: Non-literal string",id:"62-non-literal-string",level:3},{value:"63: Suppression Comment Without Error Code",id:"63-suppression-comment-without-error-code",level:3},{value:"64: Inconsistent Method Resolution Order",id:"64-inconsistent-method-resolution-order",level:3},{value:"65: Duplicate Parameter",id:"65-duplicate-parameter",level:3},{value:"66: Invalid Exception Handler",id:"66-invalid-exception-handler",level:3},{value:"67: Invalid Exception Group Handler",id:"67-invalid-exception-group-handler",level:3},{value:"68: Invalid Type Guard",id:"68-invalid-type-guard",level:3},{value:"69: Invalid Positional-Only Parameter",id:"69-invalid-positional-only-parameter",level:3},{value:"70: Assert Type",id:"70-assert-type",level:3},{value:"71: Typed Dictionary Isinstance",id:"71-typed-dictionary-isinstance",level:3},{value:"72: Tuple Delete",id:"72-tuple-delete",level:3},{value:"73: Tuple Out of Bounds",id:"73-tuple-out-of-bounds",level:3},{value:"74: Named Tuple Default Fields",id:"74-named-tuple-default-fields",level:3},{value:"Suppression",id:"suppression",level:2},{value:"Suppressing Individual Errors",id:"suppressing-individual-errors",level:3},{value:"Suppressing Errors within Format Strings",id:"suppressing-errors-within-format-strings",level:3},{value:"Suppressing All Errors",id:"suppressing-all-errors",level:3},{value:"Suppressing Errors Across Files",id:"suppressing-errors-across-files",level:3},{value:"Debugging",id:"debugging",level:2}],u=(t="Internal",function(e){return console.warn("Component "+t+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.mdx)("div",e)}),y={toc:c};function h(e){var n=e.components,a=(0,i.Z)(e,l);return(0,o.mdx)("wrapper",(0,r.Z)({},y,a,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("h2",{id:"common-issues"},"Common Issues"),(0,o.mdx)("h3",{id:"covariance-and-contravariance"},"Covariance and Contravariance"),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"},"Variance")," is tricky and a common source of confusion for people new to Python's type system."),(0,o.mdx)("p",null,"Pyre will error when, for instance, a ",(0,o.mdx)("inlineCode",{parentName:"p"},"List[int]")," is passed in when a ",(0,o.mdx)("inlineCode",{parentName:"p"},"List[float]")," is expected, as in the following example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def to_seconds(milliseconds: List[float]) -> List[int]:\n  return [int(x/1000.0) for x in milliseconds]\n\nmy_list: List[int] = [1]\nmy_list = to_seconds(my_list) # Pyre errors here!\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUnbound name [10]: Name `List` is used but not defined in the current scope.\n")),(0,o.mdx)("p",null,"This code works perfectly fine at runtime, and we may think that since ",(0,o.mdx)("inlineCode",{parentName:"p"},"int")," is a subtype of ",(0,o.mdx)("inlineCode",{parentName:"p"},"float")," this should not be a problem for the type checker either. However, consider the following code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def halve_first_element(list: List[float]) -> None:\n  list[0] /= 2\n\ndef function_taking_int(int: int) -> None:\n    return None\n\nmy_list: List[int] = [1]\nhalve_first_element(my_list)\nfunction_taking_int(my_list[0]) # Oh no, my_list[0] is 0.5!\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible parameter type [6]: In call `list.__setitem__`, for 2nd positional argument, expected `int` but got `float`.\n")),(0,o.mdx)("p",null,"If we allowed passing in ",(0,o.mdx)("inlineCode",{parentName:"p"},"my_list")," to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"halve_first_element")," function here, the above code would type check. It's perfectly valid from the perspective of the callee to modify the list's element to be a float, as it was annotated as taking a list of floats, but because this list escapes the scope of the callee, we can't allow this in the type checker."),(0,o.mdx)("p",null,"To work around this, we can signal to the type checker that the parameter can't be modified. Here's how you can tell the type checker that you won't change the container in your function:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import *\n# I can't modify milliseconds here, so it's safe to pass a Iterable[int].\ndef to_seconds(milliseconds: Iterable[float]) -> List[int]:\n  return [int(x/1000.0) for x in milliseconds]\n\nmy_list: List[int] = [1]\nmy_list = to_seconds(my_list) # Type checks!\n")),(0,o.mdx)("p",null,"Most commonly used generic containers have immutable variants, and I would encourage you to use them for function parameters whenever you don't need to modify a container in your function.\nHere are some immutable variants for commonly used containers:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"typing.List \u2192 typing.Sequence (if you need random access via my_list[id])\ntyping.List \u2192 typing.Iterable (if you're just iterating over the list in a loop and want to support sets as well)\ntyping.Dict \u2192 typing.Mapping\ntyping.Set \u2192 typing.AbstractSet\n")),(0,o.mdx)("p",null,"Invariance, combined with type inference, comes with a few gotchas. When you write an expression, Pyre infers the most precise type possible. For instance, Pyre infers the ",(0,o.mdx)("inlineCode",{parentName:"p"},"List[int]")," type for ",(0,o.mdx)("inlineCode",{parentName:"p"},"[1, 2]"),", even though ",(0,o.mdx)("inlineCode",{parentName:"p"},"List[float]")," would be a perfectly valid type here. This can cause issues, as in the following example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def zeroes(number_of_elements: int) -> List[float]:\n  a = [0] * number_of_elements\n  return a # Pyre errors here!\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible return type [7]: Expected `List[float]` but got `List[int]`.\n")),(0,o.mdx)("p",null,"What happened above is that Pyre inferred a type of ",(0,o.mdx)("inlineCode",{parentName:"p"},"List[int]")," for a, and invariance kicked in. You can work around this by adding an explicit annotation when declaring a:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def zeroes(number_of_elements: int) -> List[float]:\n  a: List[float] = [0.0] * number_of_elements\n  return a # Type checks!\n")),(0,o.mdx)("h4",{id:"contravariance"},"Contravariance"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"Callable"),", on the other hand, is ",(0,o.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Contravariant_method_parameter_type"},"contravariant")," in its parameter types. This means that, when checking if ",(0,o.mdx)("inlineCode",{parentName:"p"},"Callable[[A], None]")," is compatible with ",(0,o.mdx)("inlineCode",{parentName:"p"},"Callable[[B], None]"),", we check if ",(0,o.mdx)("inlineCode",{parentName:"p"},"B")," is compatible with ",(0,o.mdx)("inlineCode",{parentName:"p"},"A"),", not the other way around. This is because the former should be capable of accepting any arguments accepted by the latter."),(0,o.mdx)("p",null,"For example, a function of type ",(0,o.mdx)("inlineCode",{parentName:"p"},"Callable[[Base], int]")," may be given an argument of type ",(0,o.mdx)("inlineCode",{parentName:"p"},"Child2"),". But if we passed in a function of type ",(0,o.mdx)("inlineCode",{parentName:"p"},"Callable[[Child1], int]"),", this could fail at runtime:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Base: pass\n\nclass Child1(Base):\n    size: int = 42\n\n# No size field.\nclass Child2(Base): pass\n\ndef print_child2_size(get_size: Callable[[Base], int]) -> None:\n    child2 = Child2()\n    size = get_size(child2)\n    print(size)\n\ndef size_of_child1(child1: Child1) -> int:\n    return child1.size\n\nprint_child2_size(size_of_child1) # BAD!\n\n# At runtime:\n# AttributeError: 'Child2' object has no attribute 'size'\n")),(0,o.mdx)("p",null,"To prevent such errors, Pyre raises a type error when violating contravariance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible parameter type [6]: Expected `typing.Callable[[Base], int]` for 1st positional only parameter to call `print_child2_size` but got `typing.Callable(size_of_child1)[[Named(child1, Child1)], int]`.\n")),(0,o.mdx)("h3",{id:"optional-attributes"},"Optional Attributes"),(0,o.mdx)("p",null,"A common pattern in Python is to check whether an attribute is ",(0,o.mdx)("inlineCode",{parentName:"p"},"None")," before accessing its value. E.g."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Optional\n\nclass Data:\n  field: Optional[int]\n\ndef process_field(input: int) -> None:\n  ...\n\ndef process_data(data: Data) -> None:\n  if data.field is not None:\n    # ... interleaving logic\n    process_field(data.field)\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible parameter type [6]: expected int but got Optional[int]\n")),(0,o.mdx)("p",null,"The above fails to type-check because Pyre cannot guarantee that ",(0,o.mdx)("inlineCode",{parentName:"p"},"data.field")," remains not ",(0,o.mdx)("inlineCode",{parentName:"p"},"None")," if the interleaving logic between the explicit check and the later reference contains anything that may have side effects, like function calls."),(0,o.mdx)("p",null,"An interleaving call could set ",(0,o.mdx)("inlineCode",{parentName:"p"},"field")," back to ",(0,o.mdx)("inlineCode",{parentName:"p"},"None"),", since it's a non local variable and is mutable. Therefore any calls between the None check and the access will invalidate the \"not ",(0,o.mdx)("inlineCode",{parentName:"p"},"None"),'" refinement. If ',(0,o.mdx)("inlineCode",{parentName:"p"},"data.field")," is defined as a class property or if the parent class has overridden ",(0,o.mdx)("inlineCode",{parentName:"p"},"__getattr__"),", then all bets are off even if there are no interleaving calls."),(0,o.mdx)("p",null,"The preferred way to make this code type-check is to either move the check closer to the access, or to mark the attribute ",(0,o.mdx)("inlineCode",{parentName:"p"},"Final")," if it is not meant to be reassigned to, and you can guarantee to the type checker that no interleaving side effects can modify this attribute."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Final, Optional\n\nclass Data:\n  # Needs to be assigned in the constructor and cannot be changed afterwards.\n  field: Final[Optional[int]] = 1\n")),(0,o.mdx)("p",null,"It is always safe to refine attributes when their types are ",(0,o.mdx)("inlineCode",{parentName:"p"},"Final"),"."),(0,o.mdx)("p",null,"Alternatively, it is also safe to assign the attribute to a local variable before accessing its value:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def process_data(data: Data) -> None:\n  field = data.field\n  if field is not None:\n    # ... interleaving logic\n    process_field(field)\n")),(0,o.mdx)("p",null,"or using Python 3.8's assignment expressions:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def process_data(data: Data) -> None:\n    if (field := data.field) is not None:\n        # ... interleaving logic\n        process_field(field)\n")),(0,o.mdx)("h3",{id:"third-party-libraries"},"Third-Party Libraries"),(0,o.mdx)("p",null,"Not all third-party libraries come with Python code that Pyre can analyze (e.g. ",(0,o.mdx)("inlineCode",{parentName:"p"},"Cython")," modules), and some libraries contain source code without annotations. This will often show up in the form of undefined attribute errors:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"Undefined attribute [16]: Module <library> has no attribute <some attribute>.\n")),(0,o.mdx)("p",null,"Since it is not always possible to annotate code, PEP 484 specifies a format for ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0484/#stub-files"},"stub files")," with a ",(0,o.mdx)("inlineCode",{parentName:"p"},".pyi")," extension. Pyre will look for stub files in ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/python/typeshed"},"typeshed"),", or next to your source code. You can also provide additional paths to Pyre to look for stubs (see ",(0,o.mdx)("a",{parentName:"p",href:"/docs/configuration"},"Configuration"),")."),(0,o.mdx)(u,{mdxType:"Internal"}),(0,o.mdx)("h2",{id:"error-codes"},"Error Codes"),(0,o.mdx)("p",null,"Different errors raised by Pyre have different error codes. E.g. in"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-bash"},"(venv) $ pyre\n \u019b Found 1 type error!\ntest.py:1:0 Incompatible variable type [9]: a is declared to have type `int` but is used as type `str`.\n")),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"9")," in the brackets indicates that we raised an error with code 9."),(0,o.mdx)("h3",{id:"0-unused-ignore"},"0: Unused Ignore"),(0,o.mdx)("p",null,"Pyre fixmes and ignores allow you to ignore specific type errors by their code until you are able to fix them. In order to avoid outdated fixme comments in your project, Pyre will also error when a fixme is no longer needed. Removing the fixme comment will resolve the error."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# pyre-fixme[7] # unused ignore\ndef foo() -> int:\n  return 1\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUnused ignore [0]: The `pyre-ignore[7]` or `pyre-fixme[7]` comment is not suppressing type errors, please remove it.\n")),(0,o.mdx)("h3",{id:"2-missing-parameter-annotation"},"2: Missing Parameter Annotation"),(0,o.mdx)("p",null,"If strict mode is turned on, Pyre will error when a function parameter is either annotated with a type that contains ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Any")," or not annotated with any type at all (in which case Pyre will treat it as ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Any")," by default). It will also error when a method parameter is not annotated, unless that parameter is the first parameter of a bound or static method (i.e. ",(0,o.mdx)("inlineCode",{parentName:"p"},"self"),", whose type pyre can infer)."),(0,o.mdx)("p",null,"We enforce typed argument because ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Any")," can hide type errors that will happen at runtime:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Any\n\ndef say_hello(name) -> None:\n    print("Hello " + name)\n\n\n# This line will raise at runtime, but no type error since `say_hello`s `name` has type `Any`.\nsay_hello(42)\n')),(0,o.mdx)("p",null,"You can silence this by adding a non-",(0,o.mdx)("inlineCode",{parentName:"p"},"Any")," annotation to all parameters of functions and methods (other than ",(0,o.mdx)("inlineCode",{parentName:"p"},"self")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls")," for bound and class methods, which you may omit)."),(0,o.mdx)("h3",{id:"3-missing-return-annotation"},"3: Missing Return Annotation"),(0,o.mdx)("p",null,"If strict mode is turned on, Pyre will error when a function is either annotated with a return type that contains ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Any"),", or is not annotated with any return type at all (in which case Pyre will treat it as returning ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Any")," by default)."),(0,o.mdx)("p",null,"This is bad because a return type of ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Any")," may potentially hiding legitimate type errors that may happen at runtime:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Any\n\ndef f():\n  return 42\n\nprint("a" + f())\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nMissing return annotation [3]: Returning `int` but no return type is specified.\n")),(0,o.mdx)("p",null,"The best way to silence this error is to add non-",(0,o.mdx)("inlineCode",{parentName:"p"},"Any")," return annotation to every function."),(0,o.mdx)("h3",{id:"4-missing-attribute-annotation"},"4: Missing Attribute Annotation"),(0,o.mdx)("p",null,"In strict mode, Pyre will error when an attribute does not have an annotation."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo() -> str:\n    return "Hello, World!"\nclass A:\n    b = foo() # Missing attribute annotation\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nMissing attribute annotation [4]: Attribute `b` of class `A` has no type specified.\n")),(0,o.mdx)("p",null,"Adding a type annotation will resolve this error:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo() -> str:\n    return "Hello, World!"\nclass A:\n    b: str = foo()\n')),(0,o.mdx)("p",null,"This error can also occur when pyre is inferring attribute types from constructors.\nFor example, here we know that ",(0,o.mdx)("inlineCode",{parentName:"p"},"b")," is an int based on the parameter annotation in ",(0,o.mdx)("inlineCode",{parentName:"p"},"__init__"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n    def __init__(self, b: int) -> None:\n        self.b = b\n")),(0,o.mdx)("p",null,"But here we need a annotations because we can't just propagate an argument annotation:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n    def __init__(self, arg: int) -> None:\n        self.a = arg + 5\n        self.b = arg + 5\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nMissing attribute annotation [4]: Attribute `a` of class `A` has type `int` but no type is specified.\nMissing attribute annotation [4]: Attribute `b` of class `A` has type `int` but no type is specified.\n")),(0,o.mdx)("p",null,"We can fix this by making the annotation explicit, either in the class body or\nin ",(0,o.mdx)("inlineCode",{parentName:"p"},"__init__"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n    a: int\n    def __init__(self, arg: int) -> None:\n        self.a = arg + 5\n        self.b: int = arg + 5\n")),(0,o.mdx)("h3",{id:"5-missing-global-annotation"},"5: Missing Global Annotation"),(0,o.mdx)("p",null,"If strict mode is turned on, Pyre will error when a globally accessible variable is not annotated. If pyre was able to infer a type for the\nvariable, it will emit this type in the error message. The fix is usually to add an annotation to the variable."),(0,o.mdx)("p",null,"Note: This error has also arisen when there is some ambiguity of whether a declaration is a global expression or a type alias, in these cases pyre assumes it is an expression. Adding a ",(0,o.mdx)("inlineCode",{parentName:"p"},": TypeAlias")," annotation lets pyre know that it is a type alias and solves the problem."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing_extensions import TypeAlias\n\n# This declaration would result in an error\nMyTypeAlias = Dict[str, "AnotherTypeAlias"]\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nMissing global annotation [5]: Globally accessible variable `MyTypeAlias` has no type specified.\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing_extensions import TypeAlias\n# This declaration ensures that pyre knows MyTypeAlias is a type alias\nMyTypeAlias: TypeAlias = Dict[str, "AnotherTypeAlias"]\n')),(0,o.mdx)("h3",{id:"6-incompatible-parameter-type"},"6: Incompatible Parameter Type"),(0,o.mdx)("p",null,"Pyre will error if an argument passed into a function call does not match the expected parameter type of that function."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def takes_int(x: int) -> None:\n  pass\n\ndef f(x: Optional[int]) -> None:\n  takes_int(x) # Incompatible parameter type error\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible parameter type [6]: In call `takes_int`, for 1st positional argument, expected `int` but got `Optional[int]`.\n")),(0,o.mdx)("p",null,"If you are seeing errors with invariant containers where some ",(0,o.mdx)("inlineCode",{parentName:"p"},"Container[T]")," is expected but you are passing ",(0,o.mdx)("inlineCode",{parentName:"p"},"Container[S]")," where ",(0,o.mdx)("inlineCode",{parentName:"p"},"S < T"),", please see ",(0,o.mdx)("a",{parentName:"p",href:"/docs/errors#covariance-and-contravariance"},"Covariance and Contravariance"),"."),(0,o.mdx)("h3",{id:"7-incompatible-return-type"},"7: Incompatible Return Type"),(0,o.mdx)("p",null,"Pyre will error when the value returned from a function does not match the annotation."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo() -> int:\n  return "" # incompatible return type\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible return type [7]: Expected `int` but got `str`.\n")),(0,o.mdx)("p",null,"Updating the return annotation, or the value returned from the function will resolve this error."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo() -> str:\n  return "" # compatible: No error\n')),(0,o.mdx)("h3",{id:"8-incompatible-attribute-type"},"8: Incompatible Attribute Type"),(0,o.mdx)("p",null,"Pyre will error if a value is assigned to an attribute that does not match the annotated type of that attribute."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'class Foo:\n  x: int = 0\n\ndef f(foo: Foo) -> None:\n  foo.x = "abc" # Incompatible attribute type error\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible attribute type [8]: Attribute `x` declared in class `Foo` has type `int` but is used as type `str`.\n")),(0,o.mdx)("p",null,"If you are seeing errors with invariant containers where some ",(0,o.mdx)("inlineCode",{parentName:"p"},"Container[T]")," is expected but you are passing ",(0,o.mdx)("inlineCode",{parentName:"p"},"Container[S]")," where ",(0,o.mdx)("inlineCode",{parentName:"p"},"S < T"),", please see ",(0,o.mdx)("a",{parentName:"p",href:"/docs/errors#covariance-and-contravariance"},"Covariance and Contravariance"),"."),(0,o.mdx)("h3",{id:"9-incompatible-variable-type"},"9: Incompatible Variable Type"),(0,o.mdx)("p",null,"Pyre will error when assigning incompatible types to local variables and parameters that were explicitly annotated."),(0,o.mdx)("p",null,"That is, the following will error:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def f(x: int) -> None:\n  x = "" # Incompatible variable type error\n  y: int = 1\n  y = "" # Incompatible variable type error\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible variable type [9]: x is declared to have type `int` but is used as type `str`.\nIncompatible variable type [9]: y is declared to have type `int` but is used as type `str`.\n")),(0,o.mdx)("p",null,"The rationale here is that it's surprising for an explicitly annotated variable to have an\nincompatible type later on in the same function."),(0,o.mdx)("p",null,"If you are constructing an object that is generic over an invariant type, you may run into an error:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import TypeVar\n\n_T = TypeVar('_T')\n\nclass Foo(Generic[_T]):\n    def __init__(self, x: _T) -> None: ...\n\ndef f() -> None:\n    foo: Foo[Optional[int]] = Foo(x=1) # Incompatible variable type error\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible variable type [9]: foo is declared to have type `Foo[Optional[int]]` but is used as type `Foo[int]`.\n")),(0,o.mdx)("p",null,"This is due to the fact that ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo[X]")," is not less than ",(0,o.mdx)("inlineCode",{parentName:"p"},"Foo[Y]")," even if ",(0,o.mdx)("inlineCode",{parentName:"p"},"X < Y")," when the type variable is invariant.\nYou can declare your intention to initialize the object with a wider type than is given to fix this error:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import TypeVar\n\n_T = TypeVar('_T')\n\nclass Foo(Generic[_T]):\n    def __init__(self, x: _T) -> None: ...\n\ndef f() -> None:\n    foo: Foo[Optional[int]] = Foo[Optional[int]](x=1)\n")),(0,o.mdx)("h3",{id:"10-unbound-name"},"10: Unbound Name"),(0,o.mdx)("p",null,"Pyre produces an Unbound Name error when your code access a variable (local or global) that pyre believes is not defined."),(0,o.mdx)("p",null,"In most cases code that does this is invalid and will always fail. For example this code will always fail at runtime:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def f() -> int:\n    return x  # use of an unbound name x\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUnbound name [10]: Name `x` is used but not defined in the current scope.\n")),(0,o.mdx)("p",null,"There are some cases where python code that works fine at runtime could produce this error, for example if a function implicitly sets a module-level global variable that is not declared in the toplevel. Pyre will not accept this because module-level globals require type annotations, and if they have no declaration there is nowhere to put the annotation:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def set_x() -> None:\n    global x\n    x = 42\n\ndef use_x() -> None:\n    print(x)\n\n\n# this code will run fine, but pyre cannot analyze the type or use of the\n# implicitly-defined global x and will complain about an unbound name.\nset_x()\nuse_x()\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUnbound name [10]: Name `x` is used but not defined in the current scope.\n")),(0,o.mdx)("p",null,"You can fix this by explicitly adding a declaration of the top-level variable ",(0,o.mdx)("inlineCode",{parentName:"p"},"x"),", for example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x : Optional[int] = None\n\ndef set_x() -> None:\n    global x\n    x = 42\n\ndef use_x() -> None:\n    print(x)\n\n\n# this code will run fine\nset_x()\nuse_x()\n")),(0,o.mdx)("h3",{id:"11-31-undefined-or-invalid-type"},"11, 31: Undefined or Invalid Type"),(0,o.mdx)("p",null,"Pyre recognizes class names as valid annotations. Most basic types are imported from the ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing")," module or are already available from builtins like ",(0,o.mdx)("inlineCode",{parentName:"p"},"str"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"int"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"bool"),", etc. You can also define your own type alias on the global scope, which can be used as annotations:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing_extensions import TypeAlias\n\nINT_OR_STR: TypeAlias = Union[int, str]\n")),(0,o.mdx)("p",null,"If you use a name as an annotation that is not a valid type or valid alias, you will see this error:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Callable, List\nfrom typing_extensions import Final, Literal\n\nGLOBAL_VALUE = "string"\n\ndef f0() -> GLOBAL_VALUE: ... # Error! `GLOBAL_VALUE` is a value, not a type.\n\ndef f1() -> type(GLOBAL_VALUE): ...   # Error! Static type annotations cannot be dynamically computed.\n\ndef f2() -> [int]: ...  # Error! `[int]` is not a valid type. If you mean a list of int, use `typing.List[int]`.\n\ndef f3() -> (int, str): ...  # Error! `(int, str)` is not a valid type. If you mean a pair of int and str, use `typing.Tuple[int, str]`.\n\ndef f4() -> Callable[[int]]: ...  # Error! `Callable[[int]]` is not a valid type because the return type of the callable is missing. Good example: `Callable[[int], int]`.\n\ndef f5() -> Callable[int, int]: ...  # Error! `Callable[int, int]` is not a valid type. The parameter types of the callable must be enclosed in square brackets. Good example: `Callable[[int], int]`.\n\ndef f6() -> List[Final[int]]: ...  # Error! `Final` may only be used as the outermost type in annotations. See PEP 591.\n\ndef f7() -> Literal[GLOBAL_VALUE]: ...  # Error! Only literals are allowed as parameters for `Literal`. See PEP586. Good example: `Literal[42]` or `Literal["string"]`.\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUndefined or invalid type [11]: Annotation `GLOBAL_VALUE` is not defined as a type.\nInvalid type [31]: Expression `type(GLOBAL_VALUE)` is not a valid type.\nInvalid type [31]: Expression `[int]` is not a valid type.\nInvalid type [31]: Expression `(int, str)` is not a valid type.\nInvalid type [31]: Expression `typing.Callable[[int]]` is not a valid type.\nInvalid type [31]: Expression `typing.Callable[(int, int)]` is not a valid type.\nInvalid type [31]: Expression `GLOBAL_VALUE` is not a literal value.\n")),(0,o.mdx)("p",null,"You can fix this error by verifying that your annotation is"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},"statically determined."),(0,o.mdx)("li",{parentName:"ol"},"properly imported from ",(0,o.mdx)("inlineCode",{parentName:"li"},"typing")," if applicable."),(0,o.mdx)("li",{parentName:"ol"},"properly defined in the module you are importing from. If the module you are importing from has a ",(0,o.mdx)("a",{parentName:"li",href:"/docs/errors#third-party-libraries"},"stub file"),", you should check the definition there."),(0,o.mdx)("li",{parentName:"ol"},"properly adhere to the additional rules of special types (e.g. ",(0,o.mdx)("inlineCode",{parentName:"li"},"Callable"),", ",(0,o.mdx)("inlineCode",{parentName:"li"},"Final"),", and ",(0,o.mdx)("inlineCode",{parentName:"li"},"Literal"),").")),(0,o.mdx)("h4",{id:"type-aliases"},"Type Aliases"),(0,o.mdx)("p",null,"For type aliases, check that your type alias is defined"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},"with a valid type on the RHS. If you provide an annotation for the TypeAlias assignment, it must be ",(0,o.mdx)("inlineCode",{parentName:"li"},"typing_extensions.TypeAlias"),"."),(0,o.mdx)("li",{parentName:"ol"},"on the global scope, not nested inside a function or class.")),(0,o.mdx)("h4",{id:"paramspec"},"ParamSpec"),(0,o.mdx)("p",null,"For ",(0,o.mdx)("inlineCode",{parentName:"p"},"ParamSpec"),", check that you have used both ",(0,o.mdx)("inlineCode",{parentName:"p"},"*args: P.args")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"**kwargs: P.kwargs")," in your function's parameters:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Callable\n\nfrom pyre_extensions import ParameterSpecification\n\nP = ParameterSpecification("P")\n\n# Error because `**kwargs: P.kwargs` is missing.\ndef bad1(f: Callable[P, int], *args: P.args) -> int:\n    return f(*args)\n\n# Error because `*args: P.args` is missing.\ndef bad2(f: Callable[P, int], **kwargs: P.kwargs) -> int:\n    return f(**kwargs)\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUndefined or invalid type [11]: Annotation `P.args` is not defined as a type.\nCall error [29]: `typing.Callable[P, int]` cannot be safely called because the types and kinds of its parameters depend on a type variable.\nUndefined or invalid type [11]: Annotation `P.kwargs` is not defined as a type.\n")),(0,o.mdx)("p",null,"No type error if you have used both ",(0,o.mdx)("inlineCode",{parentName:"p"},"*args: P.args")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"**kwargs: P.kwargs")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Callable\n\nfrom pyre_extensions import ParameterSpecification\n\nP = ParameterSpecification("P")\n\n# OK\ndef good(f: Callable[P, int], *args: P.args, **kwargs: P.kwargs) -> int:\n    return f(*args, **kwargs)\n')),(0,o.mdx)("h3",{id:"12-incompatible-awaitable-type"},"12: Incompatible Awaitable Type"),(0,o.mdx)("p",null,"In strict mode, pyre will verify that all calls to ",(0,o.mdx)("inlineCode",{parentName:"p"},"await")," are on awaitable values, to ensure that you cannot get a runtime error awaiting an object that is not a coroutine."),(0,o.mdx)("p",null,"A common situation where working code will produce this error is when pyre cannot statically verify that an awaitable is non-Null, for example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"import asyncio\n\nasync def f(flag: bool) -> None:\n    if flag:\n        task = asyncio.create_task(asyncio.sleep(1))\n    else:\n        task = None\n    await task  # would throw a ValueError if flag were false\n\nasyncio.run(f(True))\n")),(0,o.mdx)("p",null,"In this example, ",(0,o.mdx)("inlineCode",{parentName:"p"},"task")," will always be a valid awaitable unless some other module overwrites the global ",(0,o.mdx)("inlineCode",{parentName:"p"},"flag"),", but pyre cannot prove that this does not happen. The error we get has the message"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nExpected an awaitable but got `typing.Optional[asyncio.tasks.Task[None]]`\n")),(0,o.mdx)("p",null,"You can fix this error by ensuring that the awaited object has an awaitable type. In the case of optional values, you can use refinement to rule out ",(0,o.mdx)("inlineCode",{parentName:"p"},"None"),". The example above can be fixed by tweaking the definition of ",(0,o.mdx)("inlineCode",{parentName:"p"},"main"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"async def f(flag: bool) -> None:\n    if flag:\n        task = asyncio.create_task(asyncio.sleep(1))\n    else:\n        task = None\n    if task is not None:\n      await task\n")),(0,o.mdx)("h3",{id:"13-uninitialized-attribute"},"13: Uninitialized Attribute"),(0,o.mdx)("p",null,"In strict mode, pyre will throw an error for class attributes which are declared without default values if they are not initialized in a constructor, for example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n    x : int\n\n    def __init__(self) -> None:\n        pass\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUninitialized attribute [13]: Attribute `x` is declared in class `A` to have type `int` but is never initialized.\n")),(0,o.mdx)("p",null,"For a case like this, you can fix the error either by setting a default value like ",(0,o.mdx)("inlineCode",{parentName:"p"},"x : int = 0")," at the class level, or by setting ",(0,o.mdx)("inlineCode",{parentName:"p"},"x")," in the constructor e.g. ",(0,o.mdx)("inlineCode",{parentName:"p"},"self.x = 0"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n    x: int = 0\n    def __init__(self) -> None:\n        pass\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n    x: int\n\n    def __init__(self, x: int = 0) -> None:\n        self.x = x\n")),(0,o.mdx)("h4",{id:"dataclass-like-classes"},"Dataclass-like classes"),(0,o.mdx)("p",null,'One case where this can occur is when using a library providing a "dataclass-like" decorator that, for example, autogenerates a constructor setting attributes.'),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from dataclasses import dataclass\n\n@dataclass\nclass A:\n    x: int\n")),(0,o.mdx)("p",null,"Pyre currently knows that that uninitialized attributes of classes wrapped in ",(0,o.mdx)("inlineCode",{parentName:"p"},"dataclass")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs")," decorators will generate constructors that set the attributes. But it does not understand many custom libraries that do similar things, for example test frameworks, or new decorators that wrap the dataclass decorator and add more logic."),(0,o.mdx)("p",null,"There is not currently a way to fix this other than via ",(0,o.mdx)("inlineCode",{parentName:"p"},"pyre-ignore")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"pyre-fixme")," directives. The python typing community is aware of this problem but has not yet settled on a solution, you can see discussion ",(0,o.mdx)("a",{parentName:"p",href:"https://mail.python.org/archives/list/typing-sig@python.org/thread/TXL5LEHYX5ZJAZPZ7YHZU7MVFXMVUVWL/"},"here"),"."),(0,o.mdx)("h3",{id:"1415-behavioral-subtyping"},"14,15: Behavioral Subtyping"),(0,o.mdx)("p",null,"Method overrides should follow\n",(0,o.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle"},"Liskov's substitution principle"),".\nIn short, parameter types can't be more restrictive and return types\ncan't be more permissive in overridden methods. To see why, consider the following example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def width(image: Image) -> float:\n    return image.width()\n")),(0,o.mdx)("p",null,"Say we now have different implementations of our ",(0,o.mdx)("inlineCode",{parentName:"p"},"Image")," class, one of which\nviolates the substitution principle:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Image:\n    def width() -> float: pass\n\nclass JpegImage(Image):\n    def width() -> int: return 10  # this is fine\n\nclass ComplexImage(Image):\n    def width() -> complex: return 1j\n\ndef foo() -> None:\n    image: Image = ComplexImage()\n    print(int(image.width()))\n")),(0,o.mdx)("p",null,"The above code fails at runtime with ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeError: can't convert complex to int"),". The case for parameters follows analogously."),(0,o.mdx)("h4",{id:"common-reasons"},"Common Reasons"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"Could not find parameter y in overriding signature."),": Check if the overriding function can accept all arguments that the overridden function can."),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Base:\n    def foo(self, x: int, y: str) -> None:\n        pass\n\nclass Child(Base):\n    def foo(self, x: int) -> None:\n        pass\n"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"Type Foo is not a subtype of the overridden attribute type Bar"),":"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'class Base:\n    a: int = 0\n\nclass Child(Base):\n    a: str = ""\n\ndef foo() -> None:\n    base: Base = Child()\n    base.a + 1\n')),(0,o.mdx)("p",{parentName:"li"},"This would fail at runtime with ",(0,o.mdx)("inlineCode",{parentName:"p"},'TypeError: can only concatenate str (not "int") to str'),".")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"Returned type Foo is not a subtype of the overridden return Bar."),": Check for reasons like ",(0,o.mdx)("a",{parentName:"p",href:"/docs/errors#covariance-and-contravariance"},"invariance"),"."))),(0,o.mdx)("h3",{id:"16-missing-attributes"},"16: Missing Attributes"),(0,o.mdx)("p",null,"Your code is most likely trying to access an attribute that Pyre does not know about.\nPyre has various ways of inferring what is an attribute of an object:"),(0,o.mdx)("h4",{id:"explicitly-declare-the-attribute"},"Explicitly Declare the Attribute"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Derp:\n    my_attribute: int = 1\n\n    @property\n    def my_property(self) -> int: ...\n")),(0,o.mdx)("h4",{id:"implicitly-declare-the-attribute"},"Implicitly Declare the Attribute"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Derp:\n    def __init__(self, foo: str) -> None:\n        self.my_attribute: int = 1\n\n        # The `foo` attribute is inferred to have type `str` because the\n        # parameter `foo` has type `str`.\n        self.foo = foo\n")),(0,o.mdx)("p",null,"Pyre does one level of inlining to infer implicit parameters\nWe suggest you do not heavily rely on this feature as it is not sound and makes our code brittle.\nSupport for this is temporary."),(0,o.mdx)("h4",{id:"common-reasons-1"},"Common Reasons"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"Optional type has no attribute foo."),": See ",(0,o.mdx)("a",{parentName:"p",href:"/docs/errors#optional-attributes"},"Optional attributes"),".")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"Foo has no attribute bar."),": Check if you have explicitly provided the type for ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar")," either in the constructor or as a class attribute.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"Module foo has no attribute bar"),": Check if the library has ",(0,o.mdx)("a",{parentName:"p",href:"/docs/errors#third-party-libraries"},"stubs"),". If so, you may need to add the function, class, or global variable to the stub.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"A library class has an attribute but it is not recognized by Pyre: Check if the library has ",(0,o.mdx)("a",{parentName:"p",href:"/docs/errors#third-party-libraries"},"stubs"),". If so, you may need to add the attribute to the class in the stub.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Your class has dynamic attributes: Consider using ",(0,o.mdx)("inlineCode",{parentName:"p"},"__getattr__")," in a ",(0,o.mdx)("a",{parentName:"p",href:"/docs/types-in-python#when-source-code-is-not-available"},"stub")," so that Pyre doesn't complain about those attributes."))),(0,o.mdx)("h3",{id:"17-incompatible-constructor-annotation"},"17: Incompatible Constructor Annotation"),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0484/#the-meaning-of-annotations"},"PEP 484")," specifies that ",(0,o.mdx)("inlineCode",{parentName:"p"},"__init__")," method of any class must be annotated to return ",(0,o.mdx)("inlineCode",{parentName:"p"},"None"),". Pyre will emit an error if the user's annotation does not conform to the specification."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'# pyre-strict\n\nclass A:\n    def __init__(self) -> "A":  # Error 17: Invalid return annotation of `__init__`.\n        ...\n\nclass B:\n    def __init__(self) -> None:  # OK\n        ...\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIncompatible constructor annotation [17]: `__init__` is annotated as returning `A`, but it should return `None`.\n")),(0,o.mdx)("h3",{id:"19-too-many-arguments"},"19: Too Many Arguments"),(0,o.mdx)("p",null,"Pyre verifies that you pass a legal number of arguments to functions."),(0,o.mdx)("p",null,"The most obvious way to encounter this error is to just pass too many arguments to a function:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def f(x: int) -> int:\n    return x\n\nf(5, 6)  # this would throw a TypeError at runtime, and pyre complains\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nToo many arguments [19]: Call `f` expects 1 positional argument, 2 were provided.\n")),(0,o.mdx)("p",null,"To fix this, make sure you pass the correct number of parameters. In some cases you may encounter this error if you intended to use a variadic argument (",(0,o.mdx)("inlineCode",{parentName:"p"},"*args"),") or to set a default value."),(0,o.mdx)("p",null,"Pyre will also throw this error if you pass too many positional arguments to\na function that uses python's ability restrict arguments to be keyword-only\nspecified by ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-3102/"},"PEP 3102"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def f(*, x: int) -> int:\n    return x\n\nf(5)  # As before, this throws a TypeError because x is positional-only\nf(x=5)  # this line will typecheck and run without error\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nToo many arguments [19]: Call `f` expects 0 positional arguments, 1 was provided.\n")),(0,o.mdx)("h3",{id:"20-missing-argument"},"20: Missing Argument"),(0,o.mdx)("p",null,"Pyre verifies that function calls provide all the expected arguments, so it will complain about code like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def f(x: int) -> ing:\n    return x\n\nf()\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nMissing argument [20]: Call `f` expects argument `x`.\n")),(0,o.mdx)("p",null,"To fix this, make sure all required arguments are provided."),(0,o.mdx)("h3",{id:"21-undefined-name-undefined-import"},"21: Undefined Name, Undefined Import"),(0,o.mdx)("p",null,"This is usually caused by failing to import the proper module."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from my_module import my_function\n\nmy_function()\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUndefined import [21]: Could not find a module corresponding to import `my_module`.\n")),(0,o.mdx)("p",null,'Pyre will raise error 21 instead ("Undefined import") when the import statement is present, but the module to be imported could not be found in the search path.\nIf the module provides stub files, please provide their location via the ',(0,o.mdx)("inlineCode",{parentName:"p"},"--search-path")," commandline parameter."),(0,o.mdx)("h4",{id:"namespace-package-modules"},"Namespace Package Modules"),(0,o.mdx)("p",null,"One case where you may run into undefined imports on code that works at runtime is when importing namespace modules.\nThe CPython runtime allows you to import a directory that is on your ",(0,o.mdx)("inlineCode",{parentName:"p"},"PYTHONPATH"),", even if it contains no ",(0,o.mdx)("inlineCode",{parentName:"p"},"__init__.py"),"; this behavior is defined in ",(0,o.mdx)("a",{parentName:"p",href:"https://peps.python.org/pep-0420/"},"PEP 420")," and the module is called a namespace package.\nIn order to make Pyre both fast and consistent on incremental updates, in Pyre we only allow importing namespace packages that have at least one python file as a direct child."),(0,o.mdx)("p",null,"So, for example, if I have a directory tree with just ",(0,o.mdx)("inlineCode",{parentName:"p"},"a/b/c.py")," then Pyre will allow ",(0,o.mdx)("inlineCode",{parentName:"p"},"import a.b.c")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"import a.b")," but not ",(0,o.mdx)("inlineCode",{parentName:"p"},"import a"),".\nA namespace package module can never contain useful types or code so it is rare to directly import it, but in special cases it might be useful (for example to access the ",(0,o.mdx)("inlineCode",{parentName:"p"},"__name__")," attribute).\nIn these cases, you'll need to suppress Pyre errors."),(0,o.mdx)("h3",{id:"22-redundant-cast"},"22: Redundant Cast"),(0,o.mdx)("p",null,"Pyre will warn when you attempt to use ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.cast")," to cast a variable to a type that the type checker already knows that variable has. This is because ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.cast")," is purely a tool for communicating with the static type checker, and will not provide any runtime guarantees. Therefore a redundant cast provides no value and is likely a mistake."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import cast\ndef foo(x: int) -> None:\n    y = cast(int, x)\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nRedundant cast [22]: The value being cast is already of type `int`.\n")),(0,o.mdx)("p",null,"If you are trying to document the type of the variable, you can provide an explicit annotation where it is declared. If you are trying to add a sanity check at runtime that the type of a variable is what you already believe it must be, use ",(0,o.mdx)("inlineCode",{parentName:"p"},"isinstance"),"."),(0,o.mdx)("h3",{id:"23-unable-to-unpack"},"23: Unable to Unpack"),(0,o.mdx)("p",null,"Pyre will warn you when trying to assign a value to a tuple with the wrong number of items."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo() -> None:\n    a, b = (1, 2, 3)\n    x, y = 42\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUnable to unpack [23]: Unable to unpack 3 values, 2 were expected.\nUnable to unpack [23]: Unable to unpack `int` into 2 values.\n")),(0,o.mdx)("p",null,"Common reasons:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Trying to assign an ",(0,o.mdx)("inlineCode",{parentName:"p"},"Optional")," value to a tuple:"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def bar() -> None:\n    x = None\n    if 2 + 2 == 4:\n        x = ("a", "b")\n\n    a, b = x\n')),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUnable to unpack [23]: Unable to unpack `typing.Optional[typing.Tuple[str, str]]` into 2 values.\n"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Unpacking an incorrect number of elements when looping over a list:"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"for a, b in [1, 2, 3]:\n    print(a, b)\n\n$ pyre\nUnable to unpack [23]: Unable to unpack `int` into 2 values.\n")))),(0,o.mdx)("h3",{id:"24-invalid-type-parameters"},"24: Invalid Type Parameters"),(0,o.mdx)("p",null,"Pyre will error if a generic type annotation is given with unexpected type parameters."),(0,o.mdx)("h4",{id:"generic-type-expects-x-type-parameters-"},'"Generic type expects X type parameters ..."'),(0,o.mdx)("p",null,"Either too few or too many type parameters were provided for the container type. For example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x: List[int, str] = [] # Invalid type parameters error\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nInvalid type parameters [24]: Generic type `list` expects 1 type parameter, received 2, use `typing.List[<element type>]` to avoid runtime subscripting errors.\n")),(0,o.mdx)("p",null,"In this case, ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.List")," is a generic type taking exactly one type parameter. If we pass a single parameter, this resolves the issue."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x: List[Union[int, str]] = [] # No error\n")),(0,o.mdx)("p",null,"If you do not know or do not want to specify the type parameters, use ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Any")," but still ensure the arity is correct."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x: List = [] # Invalid type parameters error\nx: List[Any] = [] # No error\n")),(0,o.mdx)("p",null,"Note: You may see a suggestion to use ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.List")," instead of builtins ",(0,o.mdx)("inlineCode",{parentName:"p"},"list")," as the type annotation when providing type parameters. This is to avoid runtime errors, because the builtin ",(0,o.mdx)("inlineCode",{parentName:"p"},"list")," does not support subscripting and ",(0,o.mdx)("inlineCode",{parentName:"p"},"list[int]")," is therefore not runtime-friendly."),(0,o.mdx)("h4",{id:"non-generic-type-cannot-take-type-parameters-"},'"Non-generic type cannot take type parameters ..."'),(0,o.mdx)("p",null,"Type parameters are only meaningful if the container type is generic. Passing in the type parameter binds the provided parameter type to the generic in the container class. For example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Container:\n    def add(self,element: int) -> None: ...\n    def get_element(self) -> int: ...\n\nx: Container[int] = Container() # Invalid type parameter error\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nInvalid type parameters [24]: Non-generic type `Container` cannot take parameters.\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Container(Generic[T]):\n    def add(self,element: T) -> None: ...\n    def get_element(self) -> T: ...\n\nx: Container[int] = Container()\nx.get_element() # returns int\n\ny: Container[str] = Container()\ny.get_element() # returns str\n")),(0,o.mdx)("h4",{id:"type-parameter-violates-constraints-"},'"Type parameter violates constraints ..."'),(0,o.mdx)("p",null,"If a container class is generic over a type variable with given type bounds, any type parameter used must comply with those type bounds. For example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import TypeVar, Union, Generic\n\nT = TypeVar('T', bound=Union[int, bool])\n\nclass Container(Generic[T]):\n    def add(self, element: T) -> None: ...\n    def get_element(self) -> T: ...\n\nx: Container[int] = Container() # No error\n\ny: Container[str] = Container() # Invalid type parameter error\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nInvalid type parameters [24]: Type parameter `str` violates constraints on `Variable[T (bound to typing.Union[bool, int])]` in generic type `Container`.\n")),(0,o.mdx)("h3",{id:"26-typed-dictionary-access-with-non-literal"},"26: Typed Dictionary Access With Non-Literal"),(0,o.mdx)("p",null,"In python, ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0589/#id21"},"typed dictionaries can only be accessed using literal strings")," that can be statically verified as valid. As a result, code like this will not typecheck even though it works at runtime, because we cannot statically verify that ",(0,o.mdx)("inlineCode",{parentName:"p"},"key")," in ",(0,o.mdx)("inlineCode",{parentName:"p"},"print_value")," is a valid ",(0,o.mdx)("inlineCode",{parentName:"p"},"Shape")," key:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypedDict\n\nclass Shape(TypedDict):\n    sides: int\n    color: str\n\nshape: Shape = {"sides": 4, "color": "blue"}\n\nprint(shape["sides"])  # this is fine because "sides" is a literal\n\nfor key in ["sides", "color"]:\n    print(key, shape[key])  # pyre will complain here because it can\'t prove `key` is valid\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nTypedDict accessed with a non-literal [26]: TypedDict key must be a string literal. Expected one of ('color', 'sides').\n")),(0,o.mdx)("p",null,"The example above shows a situation where you might hit this error: when you want to iterate over the fields of a typed dict. A suggested fix is to use type-safe operations like ",(0,o.mdx)("inlineCode",{parentName:"p"},"dictionary.items")," instead. For example the following code produces the same results but type checks:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'\nclass Shape(TypedDict):\n    sides: int\n    color: str\n\nshape: Shape = {"sides": 4, "color": "blue"}\n\nprint(shape["sides"])  # this is fine because "sides" is a literal\n\nfor key, value  in shape.items():\n    print(key, value) # no error\n')),(0,o.mdx)("p",null,"In other cases where you need to access a ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypedDict")," using a variable as a key, you can use ",(0,o.mdx)("inlineCode",{parentName:"p"},"dictionary.get(key)"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypedDict\n\nclass Shape(TypedDict):\n    sides: int\n    color: str\n\nshape: Shape = {"sides": 4, "color": "blue"}\n\nprint(shape["sides"])  # this is fine because "sides" is a literal\n\nfor key in ["sides", "color"]:\n    print(key, shape.get(key)) # no error\n')),(0,o.mdx)("h3",{id:"27-typed-dictionary-key-not-found"},"27: Typed Dictionary Key Not Found"),(0,o.mdx)("p",null,"If you try to access a typed dictionary with a string literal that pyre knows is not a valid key, pyre will emit an error:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypedDict\n\nclass Shape(TypedDict):\n    sides: int\n    color: str\n\ndef f(shape: Shape) -> None:\n    print(shape["location"])  # error here\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nTypedDict accessed with a missing key [27]: TypedDict `Shape` has no key `location`.\n")),(0,o.mdx)("p",null,"A possible fix: pyre considers instances of any ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypedDict")," with additional fields to be a subtype of ",(0,o.mdx)("inlineCode",{parentName:"p"},"Shape"),", so in many cases you could handle the need for a ",(0,o.mdx)("inlineCode",{parentName:"p"},"location")," field in some ",(0,o.mdx)("inlineCode",{parentName:"p"},"Shape")," dicts by creating a new type as follows:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypedDict\n\nclass Shape(TypedDict):\n    sides: int\n    color: str\n\nclass ShapeWithLocation(TypedDict):\n    sides: int\n    color: str\n    location: str\n\ndef f(shape: ShapeWithLocation) -> None:\n    print(shape["location"])  # okay\n    g(shape)  # also okay: ShapeWithLocation is a subtype of Shape\n\ndef g(shape: Shape) -> None:\n    print(shape)\n')),(0,o.mdx)("h3",{id:"28-unexpected-keyword"},"28: Unexpected Keyword"),(0,o.mdx)("p",null,"Pyre will error if attempting to pass an argument by name and there are no parameters with a matching name. For example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo(integer: int, string: str) -> None: ...\n\nfoo(1, "one")  # no error\nfoo(string="one", integer=1)  # no error\nfoo(integer=1, undefined="one")  # type error\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nUnexpected keyword [28]: Unexpected keyword argument `undefined` to call `foo`.\n")),(0,o.mdx)("h3",{id:"29-call-error"},"29: Call Error"),(0,o.mdx)("p",null,"Pyre will emit an error on seeing a call of one of the following types:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("p",{parentName:"li"},"The called object is not a function. This means that its inferred type is not Callable and it is not an instance of a class which implements a ",(0,o.mdx)("inlineCode",{parentName:"p"},"__call__")," method. This could happen due to user error (the object is indeed not a function) or due to an incorrect or incomplete type stub for the object's class causing pyre to infer the wrong type.")),(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("p",{parentName:"li"},"The call cannot be safely typed since the types and kinds of its parameters depend on a type variable. This is seen when the callable is typed using a ParameterSpecification type variable and the ",(0,o.mdx)("inlineCode",{parentName:"p"},"*args")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"**kwargs")," are not passed into the call correctly, i.e. together and in order. (For more details see ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0612/#the-components-of-a-paramspec"},"PEP 612"),")"))),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from pyre_extensions import ParameterSpecification\nfrom typing import Callable\n\nP = ParameterSpecification("P")\n\ndef decorator(f: Callable[P, int]) -> Callable[P, None]:\n\n    def foo(*args: P.args, **kwargs: P.kwargs) -> None:\n        f(*args, **kwargs)    # Accepted, should resolve to int\n        f(*args)              # Rejected : error here\n        f(*kwargs, **args)    # Rejected : error here\n        f(1, *args, **kwargs) # Accepted\n\n    return foo\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nCall error [29]: `typing.Callable[sandbox.P, int]` cannot be safely called because the types and kinds of its parameters depend on a type variable.\nCall error [29]: `typing.Callable[sandbox.P, int]` cannot be safely called because the types and kinds of its parameters depend on a type variable.\n")),(0,o.mdx)("h3",{id:"30-36-terminating-analysis-mutually-recursive-type-variables"},"30, 36: Terminating Analysis, Mutually Recursive Type Variables"),(0,o.mdx)("h4",{id:"overly-complex-functions"},"Overly-complex Functions"),(0,o.mdx)("p",null,"In very rare cases where a function has a lot of ",(0,o.mdx)("inlineCode",{parentName:"p"},"if")," branches or ",(0,o.mdx)("inlineCode",{parentName:"p"},"for"),"-loops, Pyre may raise an error saying that is unable to analyze the function fully. Analyzing extremely complex functions in depth can be costly, so Pyre only does so up to a limit. This means that it won't infer precise types for some variables and won't catch errors related to their usage. For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def my_function() -> None:\n    u = 42\n\n    if foo():\n        x1 = bar()\n        if x1:\n            x2 = baz()\n            if x2:\n                # <more branches of code>\n        else:\n            # <more branches>\n\n        if foo2():\n            # <code>\n\n        if foo3():\n            # <even more branches>\n        # <and even more branches>\n\n$ pyre\nAnalysis failure [30]: Pyre gave up inferring types for some variables because function `foo` was too complex.\nPlease simplify the function by factoring out some if-statements or for-loops.\n")),(0,o.mdx)("p",null,"To remedy this, factor out some of the branching code into separate functions out that each function has a limited amount of branching logic:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def do_stuff() -> None:\n    if foo():\n        # <code>\n\n    if foo():\n        # <even more branches>\n\n    # <and even more branches>\n\ndef bar() -> None:\n    u = 42\n\n    if foo():\n        x1 = bar()\n        if x1:\n            x2 = baz()\n            if x2:\n                # <more branches of code>\n        else:\n            # <more branches>\n\n        do_stuff()\n")),(0,o.mdx)("h4",{id:"other-analysis-failures"},"Other Analysis Failures"),(0,o.mdx)("p",null,"These errors usually indicates a bug in Pyre. Please open an issue on ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/pyre/issues"},"Github"),"."),(0,o.mdx)("h3",{id:"31-invalid-type"},"31: Invalid Type"),(0,o.mdx)("p",null,"This indicates that you are using some expression that pyre does not understand as a type."),(0,o.mdx)("p",null,"Some situations where you might run into this:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Using a list of types rather than ",(0,o.mdx)("inlineCode",{parentName:"p"},"List[type]"),":"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'x: [str] = ["a string"]\n')),(0,o.mdx)("p",{parentName:"li"},"You can fix this by using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"List")," type:"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'x: List[str] = ["a string"]\n'))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Using a constructor call rather than a bare class name:"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n    ...\n\na: A() = A()\n")),(0,o.mdx)("p",{parentName:"li"},"You can fix this by using a bare type name:"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"a: A = A()\n")))),(0,o.mdx)("h3",{id:"32-invalid-argument"},"32: Invalid Argument"),(0,o.mdx)("p",null,"This error usually means you are using a variable in a way that is incompatible with its structure, either as an argument to a function call or as part of a data structure."),(0,o.mdx)("p",null,'This could be from using an invalid variadic parameter (informally a "splat"):'),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x: int = 5\n\nprint(*x)   # invalid use of x, which is not iterable\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nInvalid argument [32]: Unpacked argument `x` must have an unpackable type but has type `typing_extensions.Literal[5]`.\n")),(0,o.mdx)("p",null,'or using an invalid keyword parameter (informally a "double-splat"):'),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Dict\n\nx: int = 5\n\nd: Dict[int, int] = {**x}  # invalid use of x, which is not a mapping\n\ndict(**d)  # invalid use of d; function kwargs must be a mapping with string keys\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nInvalid argument [32]: Keyword argument `x` has type `typing_extensions.Literal[5]` but must be a mapping.\nInvalid argument [32]: Keyword argument `d` has type `Dict[int, int]` but must be a mapping with string keys.\n")),(0,o.mdx)("p",null,"It's also possible to hit this error code on constraint mismatches when using tuple variadic variables as specified in ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0646/"},"PEP 646"),", which are an advanced feature of pyre."),(0,o.mdx)("h3",{id:"33-prohibited-any"},"33: Prohibited Any"),(0,o.mdx)("p",null,"Pyre will warn on any usage of ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Any")," when run in ",(0,o.mdx)("a",{parentName:"p",href:"/docs/types-in-python#strict-mode"},"strict mode"),". ",(0,o.mdx)("inlineCode",{parentName:"p"},"Any")," is an escape hatch that hides type errors and introduces potential type inconsistencies which Pyre strict is designed to make explicit."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"import typing\nfrom typing import Any, Dict\n\ndef foo() -> None:\n    x: typing.Any = 1\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nProhibited any [33]: Expression `x` has type `int`; given explicit type cannot be `Any`.\n")),(0,o.mdx)("p",null,"To resolve this error, replace ",(0,o.mdx)("inlineCode",{parentName:"p"},"Any")," with any other annotation. Using builtins ",(0,o.mdx)("inlineCode",{parentName:"p"},"object")," is acceptable if you are looking for a supertype of all classes."),(0,o.mdx)("h3",{id:"34-invalid-type-variable"},"34: Invalid Type Variable"),(0,o.mdx)("p",null,'Type variables can only be used as types when they have already been placed "in scope".\nA type variable can be placed into scope via:'),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Generic class declarations",(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"for example, ",(0,o.mdx)("inlineCode",{parentName:"li"},"class C(Generic[T]):")," puts ",(0,o.mdx)("inlineCode",{parentName:"li"},"T")," into scope for the body of the class"))),(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("strong",{parentName:"li"},"parameter")," types of a generic function",(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"for example, ",(0,o.mdx)("inlineCode",{parentName:"li"},"def foo(x: T)")," puts ",(0,o.mdx)("inlineCode",{parentName:"li"},"T")," into scope for the body and return type annotation of the function")))),(0,o.mdx)("p",null,"For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import List\n\nclass Base:\n    foo: List[T] = []\n\n$ pyre\nInvalid type variable [34]: The current class isn't generic with respect to the type variable `Variable[T]`.\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(x: int) -> List[T]:\n    return [x, x]\n\n$ pyre\nInvalid type variable [34]: The type variable `Variable[T]` isn't present in the function's parameters.\n")),(0,o.mdx)("p",null,"Suggested fix:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Generic, List\n\nclass Base(Generic[T]):\n    foo: List[T] = []\n\nbase: Base[int]\n\ndef foo(x: T) -> List[T]:\n    return [x, x]\n")),(0,o.mdx)("h4",{id:"decorator-factories"},"Decorator Factories"),(0,o.mdx)("p",null,"One common error is when defining a generic decorator factory. The Python type system doesn't currently place ",(0,o.mdx)("inlineCode",{parentName:"p"},"T")," into scope within a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Callable")," type. So, it considers ",(0,o.mdx)("inlineCode",{parentName:"p"},"T")," to be a type variable from the outer scope. This can lead to errors for apparently valid code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Callable, TypeVar\n\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n\ndef my_decorator_factory(message: str) -> Callable[[Callable[[T], R]], Callable[[T], R]]:\n\n    def _decorator(f: Callable[[T], R]) -> Callable[[T], R]:\n\n        def _inner(x: T) -> R:\n            print(message)\n            return f(x)\n\n        return _inner\n\n    return _decorator\n\n$ pyre\nInvalid type variable [34]: The type variable `Variable[R]` isn't present in the function's parameters.\nInvalid type variable [34]: The type variable `Variable[T]` isn't present in the function's parameters.\n")),(0,o.mdx)("p",null,"Suggested fix: Use a callback protocol to define the return type."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Callable, Protocol, TypeVar\n\nT = TypeVar("T")\nR = TypeVar("R")\n\nclass MyCallableProtocol(Protocol):\n    def __call__(self, f: Callable[[T], R]) -> Callable[[T], R]: ...\n\ndef my_decorator_factory(message: str) -> MyCallableProtocol:\n\n    def _decorator(f: Callable[[T], R]) -> Callable[[T], R]:\n\n        def _inner(x: T) -> R:\n            print(message)\n            return f(x)\n\n        return _inner\n\n    return _decorator\n')),(0,o.mdx)("p",null,"If you are using a ",(0,o.mdx)("inlineCode",{parentName:"p"},"ParamSpec")," in your decorator, use the following:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Any, Callable, Coroutine, Protocol, TypeVar\nfrom pyre_extensions import ParameterSpecification\nimport asyncio\n\nR = TypeVar("R")\nP = ParameterSpecification("P")\n\nclass MyCallableProtocol(Protocol):\n    def __call__(self, f: Callable[P, Coroutine[object, object, R]]) -> Callable[P, Coroutine[object, object, R]]: ...\n\ndef my_decorator_factory(message: str) -> MyCallableProtocol:\n    def _decorator(f: Callable[P, Coroutine[object, object, R]]) -> Callable[P, Coroutine[object, object, R]]:\n\n        async def _inner(*args: P.args, **kwargs: P.kwargs) -> R:\n            print(message)\n            return await f(*args, **kwargs)\n\n        return _inner\n\n    return _decorator\n\n@my_decorator_factory("hello!")\nasync def foo() -> int:\n    return 1\n\nasyncio.run(foo())\n')),(0,o.mdx)("p",null,"Note: Support for such callables is currently ",(0,o.mdx)("strong",{parentName:"p"},"experimental")," and varies from one typechecker to another. This behavior may change in the future."),(0,o.mdx)("h3",{id:"35-illegal-annotation-target"},"35: Illegal Annotation Target"),(0,o.mdx)("p",null,"Pyre will error when a type annotation is applied to something that can't be annotated. This could happen when:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("p",{parentName:"li"},"A variable is re-annotated after first declaration or an explicity annotated function parameter is re-annotated within the function body. This is not allowed as re-annotating variables reduces readability and causes the annotation of a variable to depend on the position in control flow."),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def transformation(p: int) -> str:\n    return str(p + 1)\n\ndef foo(x: int) -> None:\n    y: int = x + 2\n    z = x + 3\n\n    # Each of the following will produce an error\n    x: str = transformation(x)\n    y: str = transformation(y)\n    z: int = 4\n")),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIllegal annotation target [35]: Target `x` cannot be annotated after it is first declared.\nIllegal annotation target [35]: Target `y` cannot be annotated after it is first declared.\nIllegal annotation target [35]: Target `z` cannot be annotated after it is first declared.\n")),(0,o.mdx)("p",{parentName:"li"},"An easy fix for the first two errors is to use a new variable rather than re-annotating the old variable so it can hold a new type. For the third error, ",(0,o.mdx)("inlineCode",{parentName:"p"},"z")," should have been annotated at first declaration.")),(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("p",{parentName:"li"},"Trying to annotate non-self attributes, i.e annotating the attributes of a different class than the one whose scope you are in:"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'class Foo:\n    attribute: int = 1\n\nclass Bar:\n    def __init__(self) -> None:\n        Foo.attribute: str = "hello"\n\ndef some_method() -> None:\n    Foo.attribute: int = 5\n')),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nIllegal annotation target [35]: Target `sandbox.Foo.attribute` cannot be annotated.\nIllegal annotation target [35]: Target `sandbox.Foo.attribute` cannot be annotated.\n")),(0,o.mdx)("p",{parentName:"li"},"This is not allowed as Pyre needs to be able to statically determine the type of globally accessible values, including class attributes. Even if Pyre followed control flow across functions to determine class attribute annotations, such re-annotations imply very dynamic behavior that makes the code difficult to work with."),(0,o.mdx)("p",{parentName:"li"},"The fix for this situation, similar to the case above, is to annotate the class attribute at its definition in the class that owns it and remove any annotations elsewhere. If this attribute is from a third party library, then you can add a ",(0,o.mdx)("a",{parentName:"p",href:"/docs/errors#third-party-libraries"},"stub")," for the class and annotate the attribute there."))),(0,o.mdx)("h3",{id:"39-invalid-inheritance"},"39: Invalid Inheritance"),(0,o.mdx)("p",null,"When defining a new class, Pyre will error if the base class given is not a valid parent class. This may be caused by various conditions:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("p",{parentName:"li"},"The parent class is marked as final which means it explicitly is annotated as not supporting child classes."),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@final\nclass Base:\n    ...\n\nclass Derived(Base): # Invalid inheritance error\n    ...\n")),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre"},"$ pyre\nInvalid inheritance [39]: Cannot inherit from final class `Base`.\n"))),(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("p",{parentName:"li"},"The expression given in the base class field is not a class at all."),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'MY_GLOBAL: str = "string"\n\nclass Foo(MY_GLOBAL): # Invalid inheritance error\n    ...\n')),(0,o.mdx)("p",{parentName:"li"},"Pyre does not support dynamic expressions as base classes, even if they may evaluate to a valid class at runtime. This is because the type checker relies on building up a valid class hierarchy before it can resolve types in the Python it is analyzing. On the other hand, type aliases are equivalent to types and are acceptable as base classes."))),(0,o.mdx)("ol",{start:3},(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("p",{parentName:"li"},"You are defining a typed dictionary that does not inherit from another typed dictionary."),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import TypedDict\n\nclass NonTypedDict:\n    ...\n\nclass Movie(TypedDict):\n    name: str\n    year: int\n\nclass BookBasedMovie(Movie): # No error\n    based_on: str\n\nclass BookBasedMovie(NonTypedDict): # Invalid inheritance error\n    based_on: str\n")),(0,o.mdx)("p",{parentName:"li"},"If inheriting from another typed dictionary, fields need to have a consistent type between child and parent, in order for subclassing to be sound. Similarly, a required field in the child must also be required for the parent."))),(0,o.mdx)("h3",{id:"40-invalid-override"},"40: Invalid Override"),(0,o.mdx)("p",null,"Pyre will error when methods in a child class override those in a parent class inconsistently.\nStatic methods cannot be overwritten by non-static methods, and final methods cannot be overwritten."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n    @staticmethod\n    def foo() -> int:\n        pass\n\nclass B(A):\n    @classmethod # Non-static method `B.foo` cannot override a static method defined in `A`.\n    def foo(cls) -> int:\n        pass\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import final\n\nclass Foo:\n    @final\n    def bar(self) -> None:\n        pass\n\nclass Bar(Foo):\n    def bar(self) -> None: # Invalid override, because Foo.bar is final\n        pass\n")),(0,o.mdx)("h3",{id:"41-invalid-assignment"},"41: Invalid Assignment"),(0,o.mdx)("p",null,"Pyre will error on assignments to final attributes, read-only properties, and class variables from a class instance. For example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Final, Optional\n\nclass Foo:\n  field: Final[Optional[int]] = 1\n\n  def foo() -> None:\n    self.field = 2 # Invalid assignment\n\nclass Bar:\n    _x = 1\n    @property\n    def x(self) -> int:\n        return self._x\n\ndef bar(b: Bar) -> None:\n    b.x = 1 # Invalid assignment\n")),(0,o.mdx)("p",null,"To fix this error, change the definition of this attribute to something that is mutable, if it is not intended to be read-only."),(0,o.mdx)("h3",{id:"42-missing-overload-implementation"},"42: Missing Overload Implementation"),(0,o.mdx)("p",null,"Pyre will throw this error if a source module specifies one or more overloads via ",(0,o.mdx)("a",{parentName:"p",href:"https://fburl.com/d7b8cd2h"},(0,o.mdx)("inlineCode",{parentName:"a"},"typing.overload"))," but fails to provide an implementation, for example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import overload\n\n@overload\ndef f(x: int) -> float:\n    ...\n\n@overload\ndef f(x: str) -> str:\n    ...\n")),(0,o.mdx)("p",null,"Missing implementations are allowed in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pyi")," stub files."),(0,o.mdx)("p",null,"To fix it, provide exactly one implementation (a function of the same name without the ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.overload")," decorator). For example above we could implement ",(0,o.mdx)("inlineCode",{parentName:"p"},"f")," as follows:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import overload, Union\n\n@overload\ndef f(x: int) -> float:\n    ...\n\n@overload\ndef f(x: str) -> str:\n    ...\n\n@overload\ndef f(x: str) -> str:\n    ...\n\ndef f(x: Union[int, str]) -> Union[float, str]:\n    if isinstance(x, int):\n        return float(x)\n    else:\n        return x\n")),(0,o.mdx)("h3",{id:"43-incompatible-overload-implementation"},"43: Incompatible Overload Implementation"),(0,o.mdx)("p",null,"Pyre will error if you define one or more overloads using ",(0,o.mdx)("a",{parentName:"p",href:"https://fburl.com/d7b8cd2h"},(0,o.mdx)("inlineCode",{parentName:"a"},"typing.overload")),", and your concrete implementation has an incompatible type signature."),(0,o.mdx)("p",null,"For example, this code will produce an incompatible overload implementation error"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# pyre-strict\n\nfrom typing import overload, Union\n\n@overload\ndef f(x: int) -> float:\n    ...\n\n@overload\ndef f(x: float) -> int:\n    ...\n\n@overload\ndef f(x: str) -> str:\n    ...\n\ndef f(x: Union[int, float, str]) -> Union[int, str]:\n    if isinstance(x, float):\n        return int(x)\n    elif isinstance(x, int):\n        return float(x)\n    else:\n        return x\n")),(0,o.mdx)("p",null,"The problem here is that the return type ",(0,o.mdx)("inlineCode",{parentName:"p"},"Union[int, str]")," is too narrow to\npermit ",(0,o.mdx)("inlineCode",{parentName:"p"},"f")," to return ",(0,o.mdx)("inlineCode",{parentName:"p"},"float")," when called on an ",(0,o.mdx)("inlineCode",{parentName:"p"},"int")," argument."),(0,o.mdx)("p",null,"You can fix this by either removing incorrect overload delcarations or making\nsure all parameters and return type annotations on the concrete\nimplementation are general enough to be consistent with the overloads:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def f(x: Union[int, float, str]) -> Union[int, float, str]:\n    <same implementation>\n")),(0,o.mdx)("h3",{id:"45-invalid-class-instantiation"},"45: Invalid Class Instantiation"),(0,o.mdx)("p",null,"In typed Python, some classes that represent abstract interfaces may not be directly instantiated. Pyre considers a class ",(0,o.mdx)("inlineCode",{parentName:"p"},"C")," abstract, and will error on invalid instantiation if you try to construct an instance directly in either of the following cases:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"C")," contains one or more abstract methods that are left not overridden. Abstract methods are defined as methods that are decorated with ",(0,o.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/library/abc.html#abc.abstractmethod"},(0,o.mdx)("inlineCode",{parentName:"a"},"@abc.abstractmethod")),"."),(0,o.mdx)("p",{parentName:"li"},"For example, here ",(0,o.mdx)("inlineCode",{parentName:"p"},"Derived0")," is abstract because it does not override ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar"),", but ",(0,o.mdx)("inlineCode",{parentName:"p"},"Derived1")," may be instantiated:"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'import abc\nfrom typing import Protocol\n\nclass Base(abc.ABC):\n    @abc.abstractmethod\n    def foo(self) -> None:\n        raise NotImplementedError\n    @abc.abstractmethod\n    def bar(self) -> str:\n        raise NotImplementedError\n\nclass Derived0(Base):\n    def foo(self) -> None:\n        print(self.bar())\n\nclass Derived1(Derived0):\n    def bar(self) -> str:\n        return "bar"\n\ndef test0() -> None:\n    base = Base()  # Error! Class `Base` contains 2 abstract methods and therefore cannot be instantiated.\n    derived0 = Derived0()  # Error! Class `Derived0` contains 1 abstract method `bar` and therefore cannot be instantiated.\n    derived1 = Derived1()  # OK\n'))),(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"C")," directly inherits from ",(0,o.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/library/typing.html#typing.Protocol"},(0,o.mdx)("inlineCode",{parentName:"a"},"typing.Protocol")),"."),(0,o.mdx)("p",{parentName:"li"},"For example, here ",(0,o.mdx)("inlineCode",{parentName:"p"},"MyProtocol")," is abstract because it inherits directly from ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.Protocol"),", but ",(0,o.mdx)("inlineCode",{parentName:"p"},"MyClass")," (which implements the protocol interface) may be instantiated:"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class MyProtocol(Protocol):\n    def baz(self, x: int) -> int:\n        ...\n\nclass MyClass:\n    def baz(self, x: int) -> int:\n        return x\n\ndef test1() -> None:\n    object0 = MyProtocol()  # Error! Class `MyProtocol` cannot be instantiated.\n    object1 = MyClass()  # OK\n")))),(0,o.mdx)("h3",{id:"46-invalid-type-variance"},"46: Invalid Type Variance"),(0,o.mdx)("p",null,"In brief, read-only data types can be covariant, write-only data types can be contravariant, and data types that support both reads and writes must be invariant.\nIf a data type implements any functions accepting parameters of that type, we cannot guarantee that writes are not happening. If a data type implements any functions returning values of that type, we cannot guarantee that reads are not happening.\nFor example (note: int is a subclass of float in the type system and in these examples):\nWrites taking covariants:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypeVar, Generic\n\n_T_co = TypeVar("_T_co", covariant=True)\n\nclass MyList(Generic[_T_co]):\n    def write(self, element: _T_co) -> None:\n        ... # adds element to list\n\ndef takes_float_list(float_list: MyList[float]) -> None:\n    float_list.write(1.0)\n\nint_list: MyList[int] = ...\ntakes_float_list(int_list)  # this call is OK because MyList is covariant: MyList[int] < MyList[float]\n# int_list contains floats\n')),(0,o.mdx)("p",null,"Reads returning contravariants:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypeVar, Generic\n\n_T_cont = TypeVar("_T_cont", contravariant=True)\n\nclass MyList(Generic[_T_cont]):\n    def read(self) -> _T_cont:\n        ... # returns first element from list\n\ndef takes_int_list(int_list: MyList[int]) -> int:\n    return int_list.read()\n\nfloat_list: MyList[float] = ...\ntakes_int_list(float_list)  # this call is OK because MyList is contravariant: MyList[float] < MyList[int]\n# problem with return above is clear\n')),(0,o.mdx)("h3",{id:"47-invalid-method-signature"},"47: Invalid Method Signature"),(0,o.mdx)("p",null,"Pyre will error if a non-static method fails to specify an expected implicit parameter like ",(0,o.mdx)("inlineCode",{parentName:"p"},"self")," for an instance method or ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls")," for a class method, as this argument is always implicitly passed in a call and will cause a runtime crash if not specified. Additionally, Pyre will warn if this parameter is specified but typed as something incompatible with the type of the parent class."),(0,o.mdx)("p",null,"Often times, the method may not need a ",(0,o.mdx)("inlineCode",{parentName:"p"},"self")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls")," and should be decorated with ",(0,o.mdx)("inlineCode",{parentName:"p"},"@staticmethod")," to resolve this error. For example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Foo:\n    def foo() -> None: ...  # type error\n\nclass Foo:\n    @staticmethod\n    def foo() -> None: ... # no type error\n\nclass Foo:\n    def foo(self) -> None: ... # no type error\n")),(0,o.mdx)("p",null,"Only type variables with compatible bounds can be used to annotate the ",(0,o.mdx)("inlineCode",{parentName:"p"},"self")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"cls")," parameter. For example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypeVar\n\nP = TypeVar("T", bound="Parent")\nA = TypeVar("S", bound="ChildA")\nB = TypeVar("S", bound="ChildB")\n\nclass Parent: ...\n\nclass ChildA(Parent):\n    @classmethod\n    def foo(cls: Type[A]) -> A: ...  # no type error\n\nclass ChildB(Parent):\n    def foo(self: A) -> A: ...  # type error\n    def bar(self: B) -> B: ...  # no type error\n    def baz(self: P) -> P: ...  # no type error\n')),(0,o.mdx)("h3",{id:"48-invalid-exception"},"48: Invalid Exception"),(0,o.mdx)("p",null,"In python, you can only raise objects that derive from ",(0,o.mdx)("inlineCode",{parentName:"p"},"BaseException")," (it's more common to subtype ",(0,o.mdx)("inlineCode",{parentName:"p"},"Exception")," or one of the standard library-defined errors like ",(0,o.mdx)("inlineCode",{parentName:"p"},"ValueError"),"). Attempting to raise another object such as a bare string will result in a ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeError"),". As a result, pyre will flag code like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def f(x: int) -> None:\n    if x > 1:\n        raise "x is too big"\n')),(0,o.mdx)("p",null,"To fix this, wrap the information you are trying to raise (usually an error message) in some exception type, for example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def f(x: int) -> None:\n    if x > 1:\n        raise ValueError("x is too big")\n')),(0,o.mdx)("h3",{id:"49-unsafe-cast"},"49: Unsafe Cast"),(0,o.mdx)("p",null,'To allow "safe" casts that preserve type soundness, you can use ',(0,o.mdx)("inlineCode",{parentName:"p"},"pyre_extensions.safe_cast"),". This will verify that the type you are casting to is broader than the type of the expression. In cases where this is not the case, pyre will produce an Unsafe Cast error. For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from pyre_extensions import safe_cast\n\ndef foo(x: int) -> str:\n    y = safe_cast(str, x) # Unsafe cast error\n    z = safe_cast(Union[int, str], x) # No error\n    return z # Invalid return type error\n")),(0,o.mdx)("p",null,"Some context on this: ",(0,o.mdx)("inlineCode",{parentName:"p"},"pyre_extensions.safe_cast")," is a type-safe alternative to ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.cast"),". The ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.cast")," function forces type checkers to accept a type for an expression that otherwise would not be valid, which is sometimes useful but also can hide clear type errors, for example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import cast\n\ndef foo(x: int) -> str:\n    y = cast(str, x)\n    return y # No type error, even though this is unsound.\n")),(0,o.mdx)("h3",{id:"51-unused-local-mode"},"51: Unused Local Mode"),(0,o.mdx)("p",null,"This error will be thrown if you specify more than one local mode, by having multiple line comments of the form ",(0,o.mdx)("inlineCode",{parentName:"p"},"# pyre-strict")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"# pyre-unsafe")," in the header. Pyre will ask you to remove all but one local mode declaration if you have more than one because the mode needs to be unambiguous."),(0,o.mdx)("p",null,"Context: Pyre  supports two modes of type checking, ",(0,o.mdx)("a",{parentName:"p",href:"/docs/types-in-python#gradual-typing"},"unsafe")," and ",(0,o.mdx)("a",{parentName:"p",href:"/docs/types-in-python#strict-mode"},"strict"),"."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"By default, every file runs in unsafe mode, but you can change this default to strict in your ",(0,o.mdx)("a",{parentName:"li",href:"/docs/configuration#configuration-files"},"configuration file"),"."),(0,o.mdx)("li",{parentName:"ul"},"In addition, you can set the type checking mode of a module to differ from the default for the project by adding a comment in the form ",(0,o.mdx)("inlineCode",{parentName:"li"},"# pyre-strict")," or ",(0,o.mdx)("inlineCode",{parentName:"li"},"# pyre-unsafe")," comment on its own line to the file header.")),(0,o.mdx)("h3",{id:"52-private-protocol-property"},"52: Private Protocol Property"),(0,o.mdx)("p",null,"Python ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0544/"},"Protocols"),' provide a way to statically check "duck typing", what many languages would refer to as ',(0,o.mdx)("inlineCode",{parentName:"p"},"interfaces"),"."),(0,o.mdx)("p",null,"Because protocols specify only an interface, they should not include ",(0,o.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/tutorial/classes.html#private-variables"},"private fields and methods"),", which cannot not be accessed outside of the class where they are defined (including in subclasses). Pyre will complain about the following:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Protocol\n\nclass Duck(Protocol):\n\n    def __quack(self) -> str:\n        ...\n\nclass SomeDuck:\n\n    def __quack(self) -> str:\n        return "quack"\n')),(0,o.mdx)("p",null,"To signal a non-public part of an interface, use a protected field or method (single leading underscore), which is accessible by classes implementing the interface:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Protocol\n\nclass Duck(Protocol):\n\n    def _quack(self) -> str:\n        ...\n\nclass SomeDuck:\n\n    def _quack(self) -> str:\n        return "quack"\n')),(0,o.mdx)("h3",{id:"53-missing-annotation-for-captured-variables"},"53: Missing Annotation For Captured Variables"),(0,o.mdx)("p",null,"Pyre makes no attempt at trying to infer the types across function boundaries. The statement holds for nested functions as well.\nFrom a nested function's perspective, a variable defined in an nesting function behaves similarly to a global variable. As with global variables, an explicit annotation is required if strict mode is turned on:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def outer_function0() -> int:\n    x = foo()\n    def inner_function() -> int:\n        return x  # Due to the lack of explicit annotation, Pyre will treat this variable as having type `Any`.\n    return inner_function()\n\ndef outer_function1() -> int:\n    x: int = foo()\n    def inner_function() -> int:\n        return x  # This is ok: the type of `x` is known to be `int`.\n    return inner_function()\n\ndef outer_function2() -> int:\n    x = foo()\n    def inner_function(x: int) -> int:\n        return x  # This is also ok: even though the outer `x` is not annotated, the `x` parameter of the inner function is.\n    return inner_function(x)\n")),(0,o.mdx)("h3",{id:"54-invalid-typeddict-operation"},"54: Invalid TypedDict Operation"),(0,o.mdx)("p",null,"In accordance with ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0589/"},"PEP 598"),", code that tries to assign a value of the wrong type to a field of a ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypedDict")," will not typecheck:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypedDict\n\nclass MyDict(TypedDict):\n    value: str\n\nd: MyDict = {"value": "hello"}\nd["value"] = 5  # Invalid TypedDict operation\n')),(0,o.mdx)("p",null,"To fix this you may need to change your field type to a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Union"),", if variable types are actually needed for a field."),(0,o.mdx)("h3",{id:"55-typeddict-initialization-error"},"55: TypedDict Initialization Error"),(0,o.mdx)("p",null,"Pyre will warn you when initializing a TypedDict with:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Missing required fields"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypedDict\n\nclass Movie(TypedDict):\n    name: str\n    year: int\n\nmovie: Movie = {"name": "The Matrix"}\n\n$ pyre\nTypedDict initialization error [55]: Missing required field `year` for TypedDict `Movie`.\n'))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Incorrect field type"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'movie: Movie = {"name": "The Matrix", "year": "1999"}\n\n$ pyre\nTypedDict initialization error [55]: Expected type `int` for `Movie` field `year` but got `str`.\n'))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Undefined fields"),(0,o.mdx)("pre",{parentName:"li"},(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'movie: Movie = {"name": "The Matrix", "year": 1999, "extra_field": "hello"}\n\n$ pyre\nTypedDict initialization error [55]: TypedDict `Movie` has no field `extra_field`.\n')))),(0,o.mdx)("h3",{id:"56-invalid-decoration"},"56: Invalid Decoration"),(0,o.mdx)("p",null,"This error code is a catch-all for a variety of problems that can arise in the course of resolving the type of a decorated function.\nIn all of these cases, these decoration failures will lead to the function being registered with type ",(0,o.mdx)("inlineCode",{parentName:"p"},"Any")," to avoid any spurious downstream errors."),(0,o.mdx)("h4",{id:"pyre-was-not-able-to-infer-the-type-of-the-decorator-"},'"Pyre was not able to infer the type of the decorator ..."'),(0,o.mdx)("p",null,"This should only happen when the decorator access itself is invalid, e.g. when you use a decorator which isn't declared in the stubs for a third-party library."),(0,o.mdx)("h4",{id:"pyre-was-not-able-to-infer-the-type-of-argument-"},'"Pyre was not able to infer the type of argument ..."'),(0,o.mdx)("p",null,'When using the "decorator factory" pattern, we need to resolve the type of both the decorator factory itself as well as the arguments passed to the decorator factory.\nThis is because the types of these arguments can alter the behavior of the returned decorator via overloads or type variables.\nHowever, this resolution has to happen early in the environment-building pipeline, when we don\'t yet have all of the context we need in order to resolve the types of arbitrary expressions.\nWe support resolving literals and simple globals as arguments, but using anything else will result in this error.'),(0,o.mdx)("p",null,"To work around this, you can statically type your arguments to the decorator factory as separate globals, which can be validated later in the type-checking pipeline."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypeVar\n\nT = TypeVar("T")\n\ndef decorator_factory(x: T) -> Callable[[Callable[[int], str]], Callable[[str], T]]:\n    ...\n\n# pyre-fixme[56]: Pyre was not able to infer the type of argument\n#  `complex_expression()` to decorator factory `decorator_factory`.\n@decorator_factory(complex_expression())\ndef foo(x: int) -> str:\n    ...\n\nargument: float = complex_expression()\n\n@decorator_factory(argument) # Accepted!  bar resolves to Callable[[str], float]\ndef bar(x: int) -> str:\n    ...\n')),(0,o.mdx)("h4",{id:"decorator-factory-x-could-not-be-called"},'"Decorator factory ',"`","X","`",' could not be called"'),(0,o.mdx)("p",null,"This corresponds to when the decorator factory access resolves to a type that is not callable (i.e. has no ",(0,o.mdx)("inlineCode",{parentName:"p"},"__call__")," method)."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"not_a_factory: int = 5\n\n# pyre-fixme[56]: Decorator factory `not_a_factory` could not be called, because its\n# type `int` is not callable\n@not_a_factory(1)\ndef bar() -> None:\n    pass\n")),(0,o.mdx)("h4",{id:"decorator-x-could-not-be-called"},'"Decorator ',"`","X","`",' could not be called"'),(0,o.mdx)("p",null,"Similarly, these errors correspond to when the entire decorator expression (potentially including arguments to a decorator factory), resolves to a non-callable type."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo() -> int:\n    return 42\n\n# pyre-fixme[56]: Decorator `foo()` could not be called, because its\n# type `int` is not callable\n@foo()\ndef bar() -> None:\n    pass\n")),(0,o.mdx)("h4",{id:"while-applying-decorator-factory-"},'"While applying decorator factory ..."'),(0,o.mdx)("p",null,"These errors are emitted from attempting to pass the resolved factory arguments to the factory, as with any other function call."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Callable\n\ndef factory(x: str) -> Callable[[object], object]:\n    ...\n\n# pyre-fixme[56]: While applying decorator factory `factory`:\n# Expected `str` for 1st param but got `int`.\n@factory(1)\ndef foo() -> None:\n    pass\n")),(0,o.mdx)("h4",{id:"while-applying-decorator-"},'"While applying decorator ..."'),(0,o.mdx)("p",null,"Correspondingly, these errors are emitted from trying to pass the decorated function as an argument to the resolved decorator type."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Callable\n\ndef decorator(f: Callable[[int], str]) -> int:\n    ...\n\n# pyre-fixme[56]: While applying decorator `decorator`:\n# Expected `Callable[[int], str]` for 1st param but got `Callable[[str], int]`.\n@decorator\ndef foo(x: str) -> int:\n    return 5\n")),(0,o.mdx)("h3",{id:"57-incompatible-async-generator-return-type"},"57: Incompatible Async Generator Return Type"),(0,o.mdx)("p",null,"An async generator function is an ",(0,o.mdx)("inlineCode",{parentName:"p"},"async")," function that contains at least one ",(0,o.mdx)("inlineCode",{parentName:"p"},"yield")," statement. The Python runtime ensures that all async generator would return an async generator object. Therefore, the return type of async generator functions should always be ",(0,o.mdx)("inlineCode",{parentName:"p"},"typing.AsyncGenerator")," or one of its supertypes."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import AsyncGenerator\n\nasync def f() -> int:  # Error\n    yield 0\n\nasync def g() -> AsyncGenerator[int, None]:  # OK\n    if False:\n        yield 1\n")),(0,o.mdx)("h3",{id:"58-unsupported-operand"},"58: Unsupported Operand"),(0,o.mdx)("p",null,"Pyre will warn if an infix operator is not supported for the right or left operands provided."),(0,o.mdx)("p",null,"In Python, an infix operator is converted to a method call on either of the operands - for example, ",(0,o.mdx)("inlineCode",{parentName:"p"},"a < b")," is equivalent to ",(0,o.mdx)("inlineCode",{parentName:"p"},"a.__lt__(b)"),". Therefore, this type error can also be considered sugar for an error that method ",(0,o.mdx)("inlineCode",{parentName:"p"},"a.__lt__")," does not accept the type of ",(0,o.mdx)("inlineCode",{parentName:"p"},"b")," as an argument."),(0,o.mdx)("p",null,"For example,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import Optional\n\ndef foo(x: Optional[int]) -> bool:\n    return x < 0  # type error: Optional[int] is not a supported operand\n\ndef bar(x: Optional[int]) -> bool:\n    if x:\n        return x < 0  # no type error\n    return False\n")),(0,o.mdx)("h3",{id:"59-duplicate-type-variables"},"59: Duplicate Type Variables"),(0,o.mdx)("p",null,"This occurs when the same type variable is provided more than once to a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Generic")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"Protocol"),". A type variable needs to be bound to a single value. Thus, if one wants two independent type variables with perhaps the same bounds or same properties, they have to be different variables."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import TypeVar, Generic\n\nT0 = TypeVar("T0")\nT1 = TypeVar("T1")\nT2 = TypeVar("T2")\n\nclass A(Generic[T0, T1, T0]):  # Error\n    pass\n\nclass B(Generic[T0, T1, T2]):  # OK\n    pass\n')),(0,o.mdx)("h3",{id:"60-unable-to-concatenate-tuple"},"60: Unable to Concatenate Tuple"),(0,o.mdx)("h4",{id:"expected-to-unpack-an-iterable-"},'"Expected to unpack an iterable ..."'),(0,o.mdx)("p",null,"This can occur if during concatenation of a tuple one tries to unpack a non-iterable since non-iterables can't be unpacked. Either try to unpack an iterable, or concatenate without unpacking."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(x: int, not_iterable: int, iterable: list[int]) -> None:\n    y = (x, *not_iterable)  # Error\n    z = (x, not_iterable) # OK\n    w = (x, *iterable)  # OK\n")),(0,o.mdx)("h4",{id:"concatenation-not-yet-supported-for-multiple-variadic-tuples-"},'"Concatenation not yet supported for multiple variadic tuples ..."'),(0,o.mdx)("p",null,"This can occur if during concatenation one tries to use multiple variadic tuples. This is due the limitations of the current type system and there is no workaround currently. One may use ",(0,o.mdx)("inlineCode",{parentName:"p"},"# pyre-ignore[60]")," to suppress."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Tuple\nfrom pyre_extensions import TypeVarTuple\n\nTs = TypeVarTuple("Ts")\n\ndef foo(xs: Tuple[*Ts]) -> None:\n    y = (*xs, *xs)  # Error\n')),(0,o.mdx)("h3",{id:"61-uninitialized-local"},"61: Uninitialized Local"),(0,o.mdx)("p",null,"This indicates that there are code paths along which a local variable may not be initialized. Below are some common code patterns that may cause this error:"),(0,o.mdx)("h4",{id:"not-initialized-in-all-branches-of-condition"},"Not initialized in all branches of condition"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def f(x: int) -> None:\n    z = None\n    if x > 5:\n        y = 2\n        z = 2\n    print(y)  # Error\n    print(z)  # OK\n")),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"y")," is not defined when the ",(0,o.mdx)("inlineCode",{parentName:"p"},"if")," condition is not met. For instance, ",(0,o.mdx)("inlineCode",{parentName:"p"},"f(4)")," will result in a runtime error. Possible ways to address this:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"initialize ",(0,o.mdx)("inlineCode",{parentName:"li"},"y")," to a default value, outside the conditional or in the ",(0,o.mdx)("inlineCode",{parentName:"li"},"else")," branch"),(0,o.mdx)("li",{parentName:"ul"},"refactor so that initialization and access are in the same conditional")),(0,o.mdx)("p",null,"Pyre static analysis does not reason about runtime values or potential side effects of interleaving calls, so for instance, in the example below we cannot guarantee that the two if statements will always be consistent and, hence, throw the same error:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def f(x: int) -> None:\n    if x > 5:\n        y = 2\n    # ...some operations...\n    if x > 5:\n        print(y)    # Error\n")),(0,o.mdx)("h4",{id:"initialized-only-inside-a-for-loop"},"Initialized only inside a ",(0,o.mdx)("inlineCode",{parentName:"h4"},"for")," loop"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def f(xs: List[int]) -> None\n    for x in xs:\n        y = "yes"\n    print("Last element is: ", x)  # Error\n    print("Did we enter the loop?", y)  # Error\n')),(0,o.mdx)("p",null,"Here, if one calls ",(0,o.mdx)("inlineCode",{parentName:"p"},"f([])"),", it will result in errors."),(0,o.mdx)("p",null,"One way to remediate is to initialize outside the loop. For instance,"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def f(xs: List[int]) -> None:\n    x = None\n    y = "no"\n    for x in xs:\n        y = "yes"\n    print("Last element is: ", x)  # OK\n    print("Did we enter the loop?", y)  # OK\n')),(0,o.mdx)("h4",{id:"initialized-in-try-block"},"Initialized in ",(0,o.mdx)("inlineCode",{parentName:"h4"},"try")," block"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def f(divisor: int) -> None:\n    answer_good = None\n    try:\n        answer_bad = 5 / divisor\n        answer_good = 5 / divisor\n        answer_also_good = 5 / divisor\n        print(f"5 divided by {divisor} is {answer_also_good}")   # OK\n    except ZeroDivisionError:\n        pass\n    print(f"5 divided by {divisor} is {answer_bad}")  # Error\n    print(f"5 divided by {divisor} is {answer_good}")  # OK\n')),(0,o.mdx)("p",null,"Here, ",(0,o.mdx)("inlineCode",{parentName:"p"},"f(0)")," leads to an error on access of ",(0,o.mdx)("inlineCode",{parentName:"p"},"answer_bad"),". Suggested approaches to address this:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Initialize any variables needed after the ",(0,o.mdx)("inlineCode",{parentName:"li"},"try")," block to a default value before entering the ",(0,o.mdx)("inlineCode",{parentName:"li"},"try")," block."),(0,o.mdx)("li",{parentName:"ul"},"Keep the access to variables initialized inside the ",(0,o.mdx)("inlineCode",{parentName:"li"},"try")," block within the ",(0,o.mdx)("inlineCode",{parentName:"li"},"try")," block."),(0,o.mdx)("li",{parentName:"ul"},"Consider if pulling the initialization as-is before the ",(0,o.mdx)("inlineCode",{parentName:"li"},"try")," block is possible. It is generally considered a good practice to minimize the code inside a try block, and keep it to exception throwing code. This also helps with Pyre, as it does not reason about which operations might throw exceptions.")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def bad(divisor: int) -> Optional[int]:\n    try:\n        dividend = 5\n        return dividend // divisor\n    except ZeroDivisionError:\n        print(f"Cannot divide {dividend} by 0")  # Error (according to Pyre)\n\ndef good(divisor: int) -> Optional[int]:\n    dividend = 5\n    try:\n        return dividend // divisor\n    except ZeroDivisionError:\n        print(f"Cannot divide {dividend} by 0")  # OK\n')),(0,o.mdx)("h3",{id:"62-non-literal-string"},"62: Non-literal string"),(0,o.mdx)("p",null,"Pyre will error if you passs in a non-literal string into a function call that expects a LiteralString."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def query_user(conn: Connection, user_id: str) -> User:\n    query = f"SELECT * FROM data WHERE user_id = {user_id}"\n    conn.execute(query)  # Error: Expected LiteralString, got str.\n    ...\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def query_user(conn: Connection, user_id: str) -> User:\n    query = "SELECT * FROM data WHERE user_id = ?"\n    conn.execute(query, (user_id,))  # OK.\n\n')),(0,o.mdx)("p",null,'LiteralStrings are created either from an explicit string literal like "foo" or from combining multiple string literals or LiteralStrings. This is a security focused typing feature for safely calling  powerful APIs. See ',(0,o.mdx)("a",{parentName:"p",href:"https://peps.python.org/pep-0675/#appendix-b-limitations"},"PEP 675")," for more details."),(0,o.mdx)("h3",{id:"63-suppression-comment-without-error-code"},"63: Suppression Comment Without Error Code"),(0,o.mdx)("p",null,"When running Pyre in strict mode, suppression comments like ",(0,o.mdx)("inlineCode",{parentName:"p"},"pyre-ignore")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"pyre-fixme")," need to be associated with a specific error code or set of error codes."),(0,o.mdx)("p",null,"OK:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo() -> int:\n    # pyre-ignore[7]\n    return ""\n')),(0,o.mdx)("p",null,"Not OK:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo() -> int:\n    # pyre-ignore\n    return ""\n')),(0,o.mdx)("p",null,"For more details on how to write suppression comments, refer to the section on ",(0,o.mdx)("a",{parentName:"p",href:"https://www.internalfb.com/intern/staticdocs/pyre/docs/errors/#suppressing-individual-errors"},"Suppression")," later in this doc."),(0,o.mdx)("h3",{id:"64-inconsistent-method-resolution-order"},"64: Inconsistent Method Resolution Order"),(0,o.mdx)("p",null,"Python supports multiple inheritance via multiple base classes. In order to decide the order that methods from base classes are overridden, there needs to be a consistent order among the base classes of a particular class. When this order cannot be created, for example because there is a cycle, then Pyre raises this error."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A(B):  # Error\n    pass\n\nclass B(A):  # Error\n    pass\n")),(0,o.mdx)("p",null,"For more details and examples for Python's Method Resolution Order (MRO), please refer to ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/download/releases/2.3/mro/"},"the official guide"),"."),(0,o.mdx)("h3",{id:"65-duplicate-parameter"},"65: Duplicate Parameter"),(0,o.mdx)("p",null,"Functions may not have multiple named parameters that share the same name."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def add(a: int, a: int) -> None:  # Error\n    pass\n")),(0,o.mdx)("h3",{id:"66-invalid-exception-handler"},"66: Invalid Exception Handler"),(0,o.mdx)("p",null,"Exception types listed in an ",(0,o.mdx)("inlineCode",{parentName:"p"},"except")," clause must extend ",(0,o.mdx)("inlineCode",{parentName:"p"},"BaseException"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"try:\n    pass\nexcept (int, bool):  # Error\n    pass\n")),(0,o.mdx)("h3",{id:"67-invalid-exception-group-handler"},"67: Invalid Exception Group Handler"),(0,o.mdx)("p",null,"Exception types listed in an ",(0,o.mdx)("inlineCode",{parentName:"p"},"except*")," clause (Python 3.12 exception group handler) must extend ",(0,o.mdx)("inlineCode",{parentName:"p"},"BaseException")," and may not extend ",(0,o.mdx)("inlineCode",{parentName:"p"},"BaseExceptionGroup"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"try:\n    pass\nexcept* ExceptionGroup as e:  # Error\n    pass\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"try:\n    pass\nexcept* int as e:  # Error\n    pass\n")),(0,o.mdx)("h3",{id:"68-invalid-type-guard"},"68: Invalid Type Guard"),(0,o.mdx)("p",null,"User defined type-guards are functions that return ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeIs[X]")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeGuard[X]"),"; at runtime these return a ",(0,o.mdx)("inlineCode",{parentName:"p"},"bool"),", but the static type indicates to the type checker that they narrow the type of the first positional argument, for example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import TypeIs, reveal_type\n\ndef is_int_or_str(val: object) -> TypeIs[int | str]: ...\n\ndef f(x: object):\n    if is_int_or_str(x):\n        reveal_type(x)  # int | str\n")),(0,o.mdx)("p",null,"The difference between ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeGuard")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeIs")," is that ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeGuard")," only narrows in the positive case and is covariant in its type parameter, whereas ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeIs")," also narrows in the negative case and is invariant in its type parameter; for example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# (extending the previous example)\n\ndef is_int_or_str_typeguard(val: object) -> TypeGuard[int | str]: ...\n\ndef g(x: int | str | bytes):\n    if is_int_or_str(x):\n        reveal_type(x)  # int | str\n    else:\n        reveal_type(x)  # bytes\n\n    if is_int_or_str_typeguard(x):\n        reveal_type(x)  # int | str\n    else:\n        reveal_type(x)  # int | str | bytes (no narrowing here)\n")),(0,o.mdx)("p",null,"It is a type error if such a type guard function does not accept at least one positional argument; the type guard cannot actually be invoked correctly in this case. For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import TypeIs, TypeGuard\n\n# Error: the argument is keyword-only, this is not a valid type guard.\ndef bad_type_guard(/, val: objec) -> TypeGuard[float]: ...\n\nclass CustomTypeGuard:\n    # Error: this is a non-static method and `self` is bound, so it does not\n    #  accept a positional argument.\n    def guard(self) -> TypeIs[str]: ...\n")),(0,o.mdx)("p",null,"In addition, for ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeIs")," it is an error if the narrowed type (the type inside the ",(0,o.mdx)("inlineCode",{parentName:"p"},"TypeIs"),") is not assignable to the type of the first positional parameter."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"from typing import TypeIs\n\n# Error: `int` is not a subtype of `str`\ndef inconsistent_type_is(x: str) -> TypeIs[int]: ...\n")),(0,o.mdx)("p",null,"You can read more about type guards and narrowing in the specification: ",(0,o.mdx)("a",{parentName:"p",href:"https://typing.readthedocs.io/en/latest/spec/narrowing.html"},"https://typing.readthedocs.io/en/latest/spec/narrowing.html"),"."),(0,o.mdx)("h3",{id:"69-invalid-positional-only-parameter"},"69: Invalid Positional-Only Parameter"),(0,o.mdx)("p",null,"Python has positional-only parameters which may not be passed by name. Positional-only parameters cannot appear after parameters that may be passed by name."),(0,o.mdx)("p",null,"Typically, all the parameters that proceed ",(0,o.mdx)("inlineCode",{parentName:"p"},"/")," in the parameter list are considered positional-only, but in functions without this syntax we treat parameters that are prefixed but not suffixed with ",(0,o.mdx)("inlineCode",{parentName:"p"},"__")," as positional-only for backwards-compatibility purposes. Refer to ",(0,o.mdx)("a",{parentName:"p",href:"https://typing.readthedocs.io/en/latest/spec/historical.html#positional-only-parameters"},"https://typing.readthedocs.io/en/latest/spec/historical.html#positional-only-parameters")," for more details."),(0,o.mdx)("p",null,"In the following example, ",(0,o.mdx)("inlineCode",{parentName:"p"},"__y")," is a positional-only that follows the regular parameter ",(0,o.mdx)("inlineCode",{parentName:"p"},"x"),", which is an error."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(x: int, __y: int) -> None:  # Error\n    pass\n")),(0,o.mdx)("h3",{id:"70-assert-type"},"70: Assert Type"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"assert_type")," is a static assertion that has no effect at runtime. Pyre will emit an error if the inferred type for the first argument does not match the type provided as the second argument."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x: int = 1\nassert_type(x, str) # Error\n")),(0,o.mdx)("h3",{id:"71-typed-dictionary-isinstance"},"71: Typed Dictionary Isinstance"),(0,o.mdx)("p",null,"Typed dictionaries are structurally typed. This means that it is invalid to use ",(0,o.mdx)("inlineCode",{parentName:"p"},"isinstance")," to check whether something is an instance of a typed dictionary."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class Coord(TypedDict):\n    x: int\n    y: int\n\nisinstance({}, Coord) # Error\n")),(0,o.mdx)("h3",{id:"72-tuple-delete"},"72: Tuple Delete"),(0,o.mdx)("p",null,"Tuples are immutable, so deleting elements is not allowed."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x = (1, 2, 3)\ndel x[0] # Error\n")),(0,o.mdx)("h3",{id:"73-tuple-out-of-bounds"},"73: Tuple Out of Bounds"),(0,o.mdx)("p",null,"When a tuple with a concrete/known length is indexed with a literal, Pyre will emit an error if the index is out of bounds."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x = (1, 2, 3)\ny: int = ...\nx[0] # OK\nx[-1] # OK\nx[5] # Error\nx[y] # OK\n")),(0,o.mdx)("h3",{id:"74-named-tuple-default-fields"},"74: Named Tuple Default Fields"),(0,o.mdx)("p",null,"Since named tuple constructors are generated based on the order fields are declared in, fields without defaults may not follow fields with defaults in a named tuple declaration."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# This is OK\nclass MyTuple(NamedTuple):\n    x: int\n    y: int = 1\n\n# This is not allowed\nclass MyTuple2(NamedTuple):\n    x: int = 1\n    y: int\n")),(0,o.mdx)("h2",{id:"suppression"},"Suppression"),(0,o.mdx)("p",null,"It is not always possible to address all errors immediately \u2013 some code is too dynamic and should be refactored, other times it's ",(0,o.mdx)("em",{parentName:"p"},"just not the right time")," to deal with a type error. We do encourage people to keep their type check results clean at all times and provide mechanisms to suppress errors that cannot be immediately fixed."),(0,o.mdx)("h3",{id:"suppressing-individual-errors"},"Suppressing Individual Errors"),(0,o.mdx)("p",null,"Pyre supports error suppression of individual errors with comments that can be placed on the line of the error or on the line preceding the error."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"# pyre-fixme")," indicates there is an issue in the code that will be revisited later."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"# pyre-ignore")," indicates there's an issue with the type checker or the code is too dynamic and we have decided to not fix this. If this is a Pyre bug, make sure you ",(0,o.mdx)("a",{parentName:"li",href:"https://github.com/facebook/pyre/issues"},"open an issue")," on our tracker.")),(0,o.mdx)("p",null,"Both comment styles allow you to suppress individual error codes as well as adding additional context."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo() -> int:\n    # pyre-fixme[7]: only suppresses return mismatches\n    return ""\n')),(0,o.mdx)("p",null,"Pyre also supports ",(0,o.mdx)("inlineCode",{parentName:"p"},"# type: ignore")," comments for backwards-compatibility with ",(0,o.mdx)("em",{parentName:"p"},"MyPy"),"."),(0,o.mdx)("h3",{id:"suppressing-errors-within-format-strings"},"Suppressing Errors within Format Strings"),(0,o.mdx)("p",null,"If you want to suppress an error within an f-string, you can add a fixme comment on the line before the string. This will suppress all errors within the f-string matching that fixme:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def print_profile(name: str, age: Optional[int]) -> None:\n    # pyre-fixme[58]: `-` is not supported for operand types `Optional[int]` and `int`.\n    s = f"""\n    Your personal details!!\n\n    Name: {name}\n    Age: {age - 3}\n    """\n    print(s)\n')),(0,o.mdx)("h3",{id:"suppressing-all-errors"},"Suppressing All Errors"),(0,o.mdx)("p",null,"You can use the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/types-in-python#upgrade"},"Pyre upgrade tool")," to add inline error suppressions for all errors in your project."),(0,o.mdx)("h3",{id:"suppressing-errors-across-files"},"Suppressing Errors Across Files"),(0,o.mdx)("p",null,"You can suppress all errors in entire sections of your code by adding the path to the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/configuration#the-global-configuration"},(0,o.mdx)("inlineCode",{parentName:"a"},"ignore_all_errors")," section of your configuration"),"."),(0,o.mdx)("p",null,"Furthermore Pyre supports suppressing all errors in an individual file if you add a ",(0,o.mdx)("inlineCode",{parentName:"p"},"# pyre-ignore-all-errors")," to your file. Like the other suppression comments, you can use square brackets to chose to only ignore one or more particular error types. For example, you can suppress all incompatible return type errors by adding:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# pyre-ignore-all-errors[7]\n\ndef foo(x: int) -> str:\n    return x  # pyre will not error here\n")),(0,o.mdx)("h2",{id:"debugging"},"Debugging"))}h.isMDXComponent=!0}}]);