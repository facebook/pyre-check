"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8840],{15680:(e,a,n)=>{n.r(a),n.d(a,{MDXContext:()=>s,MDXProvider:()=>u,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>m});var t=n(96540);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(){return r=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},r.apply(this,arguments)}function o(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function d(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?o(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,t,i=function(e,a){if(null==e)return{};var n,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=t.createContext({}),m=function(e){return function(a){var n=p(a.components);return t.createElement(e,r({},a,{components:n}))}},p=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):d(d({},a),e)),n},u=function(e){var a=p(e.components);return t.createElement(s.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},h=t.forwardRef((function(e,a){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,h=m["".concat(o,".").concat(u)]||m[u]||c[u]||r;return n?t.createElement(h,d(d({ref:a},s),{},{components:n})):t.createElement(h,d({ref:a},s))}));function f(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var d={};for(var l in a)hasOwnProperty.call(a,l)&&(d[l]=a[l]);d.originalType=e,d.mdxType="string"==typeof e?e:i,o[1]=d;for(var s=2;s<r;s++)o[s]=n[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}h.displayName="MDXCreateElement"},73373:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>m,contentTitle:()=>l,default:()=>c,frontMatter:()=>d,metadata:()=>s,toc:()=>p});var t=n(9668),i=n(21367),r=(n(96540),n(15680)),o=["components"],d={id:"pysa-features",title:"Feature Annotations",sidebar_label:"Feature Annotations"},l=void 0,s={unversionedId:"pysa-features",id:"pysa-features",title:"Feature Annotations",description:"Features (sometimes called breadcrumbs) are additional metadata that are",source:"@site/docs/pysa_features.md",sourceDirName:".",slug:"/pysa-features",permalink:"/docs/pysa-features",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/pysa_features.md",tags:[],version:"current",frontMatter:{id:"pysa-features",title:"Feature Annotations",sidebar_label:"Feature Annotations"},sidebar:"pysa",previous:{title:"Overview",permalink:"/docs/pysa-basics"},next:{title:"Advanced Topics",permalink:"/docs/pysa-advanced"}},m={},p=[{value:"Manually Added Features",id:"manually-added-features",level:2},{value:"<code>via</code> Feature Using <code>Via[]</code>",id:"via-feature-using-via",level:3},{value:"<code>via-value</code> Feature Using <code>ViaValueOf[]</code>",id:"via-value-feature-using-viavalueof",level:3},{value:"<code>via-type</code> Feature Using <code>ViaTypeOf[]</code>",id:"via-type-feature-using-viatypeof",level:3},{value:"<code>via-attribute</code> Feature Using <code>ViaAttributeName[]</code>",id:"via-attribute-feature-using-viaattributename",level:3},{value:"Supporting Features Dynamically Using <code>ViaDynamicFeature[]</code>",id:"supporting-features-dynamically-using-viadynamicfeature",level:3},{value:"Automatic Features",id:"automatic-features",level:2},{value:"<code>via</code> Feature",id:"via-feature",level:3},{value:"<code>type</code> Feature",id:"type-feature",level:3},{value:"<code>first-field</code> Feature",id:"first-field-feature",level:3},{value:"<code>first-index</code> Feature",id:"first-index-feature",level:3},{value:"<code>has</code> Feature",id:"has-feature",level:3},{value:"<code>always-</code> Modifier on Features",id:"always--modifier-on-features",level:3},{value:"<code>broadening</code> Features",id:"broadening-features",level:3}],u={toc:p};function c(e){var a=e.components,n=(0,i.A)(e,o);return(0,r.mdx)("wrapper",(0,t.A)({},u,n,{components:a,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Features (sometimes called breadcrumbs) are additional metadata that are\nassociated with taint flows. They can be useful for helping to filter out false\npositives, or for zeroing in on high-signal subsets of a rule. Some are\nautomatically added during the analysis process, and there is a rich system for\nmanually specifying additional features."),(0,r.mdx)("h2",{id:"manually-added-features"},"Manually Added Features"),(0,r.mdx)("h3",{id:"via-feature-using-via"},(0,r.mdx)("inlineCode",{parentName:"h3"},"via")," Feature Using ",(0,r.mdx)("inlineCode",{parentName:"h3"},"Via[]")),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via")," feature indicates that a flow passed through a point in the code, such\nas a function parameter, that was annotated with the specified feature name. For\nexample, ",(0,r.mdx)("inlineCode",{parentName:"p"},"via:getattr")," might indicate that the flow passed through a call to\n",(0,r.mdx)("inlineCode",{parentName:"p"},"getattr")),(0,r.mdx)("p",null,"Feature names are declared in your ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config")," file (the same file as\nsources/sinks/rules) like this:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'features: [\n    {\n        name: "getattr",\n        comment: "via getattr first parameter"\n    },\n    {\n        name: "request_files",\n        comment: "via django request.FILES"\n    }\n]\n')),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via")," feature can be appended to ",(0,r.mdx)("inlineCode",{parentName:"p"},"TaintSource")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"TaintSink")," annotations\nto add extra metadata to the specified source and sink flows. It can also be\nappended to ",(0,r.mdx)("inlineCode",{parentName:"p"},"TaintInTaintOut")," annotations, to add extra metadata to any flow\nthat goes through that annotated function/parameter/attribute."),(0,r.mdx)("p",null,"This is done by adding ",(0,r.mdx)("inlineCode",{parentName:"p"},"Via[FEATURE_NAME]")," within square brackets after the\n",(0,r.mdx)("inlineCode",{parentName:"p"},"TaintXXXX")," annotation in a model file:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# Augmenting TaintSource\ndjango.http.request.HttpRequest.FILES: TaintSource[UserControlled, Via[request_files]] = ...\n\n# Augmenting TaintInTaintOut\ndef getattr(\n    o: TaintInTaintOut[Via[getattr]],\n    name: TaintSink[GetAttr],\n    default: TaintInTaintOut[LocalReturn],\n): ...\n")),(0,r.mdx)("p",null,"Pysa also supports attaching features to inferred flows, which allows you to\nfilter flows passing through a function without having to annotate the taint\nyourself explicitly, and having the feature attached to all taint flowing\nthrough the function. This is done by adding the ",(0,r.mdx)("inlineCode",{parentName:"p"},"AttachToSource"),",\n",(0,r.mdx)("inlineCode",{parentName:"p"},"AttachToSink"),", and ",(0,r.mdx)("inlineCode",{parentName:"p"},"AttachToTito")," annotations in a model file:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# Attaching taint to sources.\ndef get_signed_cookie() -> AttachToSource[Via[signed]]: ...\n\n# Attaching taint to sinks.\ndef HttpResponseRedirect.__init__(self, redirect_to: AttachToSink[Via[redirect]], *args, **kwargs): ...\n\n# Attaching taint to taint-in-taint-out models.\ndef attach_features.tito_and_sink(arg: AttachToTito[Via[some_feature_name]]): ...\n")),(0,r.mdx)("p",null,"Pysa additionally supports attaching features to flows irrespective of sources,\nsinks, and TITO, using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"AddFeatureToArgument")," annotation:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def add_feature_to_argument.add_feature_to_first(\n  first: AddFeatureToArgument[Via[string_concat_lhs]],\n  second\n): ...\n")),(0,r.mdx)("p",null,"Note that ",(0,r.mdx)("strong",{parentName:"p"},"Pysa automatically adds some ",(0,r.mdx)("inlineCode",{parentName:"strong"},"via")," features with special meaning"),".\nSee the Automatic Features section for details."),(0,r.mdx)("h3",{id:"via-value-feature-using-viavalueof"},(0,r.mdx)("inlineCode",{parentName:"h3"},"via-value")," Feature Using ",(0,r.mdx)("inlineCode",{parentName:"h3"},"ViaValueOf[]")),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value")," feature is similar to the ",(0,r.mdx)("inlineCode",{parentName:"p"},"via")," feature, however, it captures\n",(0,r.mdx)("em",{parentName:"p"},"the value of the specified argument, rather than a feature name"),". Note that\nthis only works for string literals, boolean literals, numeric literals, and enums.\nFor example, ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value:Access-Control-Allow-Origin")," might indicate that the string\nliteral ",(0,r.mdx)("inlineCode",{parentName:"p"},"Access-Control-Allow-Origin")," was used to set a header in a Django response."),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value")," feature can be added anywhere that the ",(0,r.mdx)("inlineCode",{parentName:"p"},"via")," feature can be\nadded. It is added by specifying ",(0,r.mdx)("inlineCode",{parentName:"p"},"ViaValueOf[PARAMETER_NAME]"),", where\n",(0,r.mdx)("inlineCode",{parentName:"p"},"PARAMETER_NAME")," is the name of the function parameter for which you would like\nto capture the argument value. To continue the above example, this is how you\nwould capture the name of a header being set on a Django ",(0,r.mdx)("inlineCode",{parentName:"p"},"HttpResponse"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def django.http.response.HttpResponse.__setitem__(\n    self,\n    header: TaintSink[ResponseHeaderName],\n    value: TaintSink[ResponseHeaderValue, ViaValueOf[header]]\n): ...\n")),(0,r.mdx)("p",null,"In cases where the argument is not a constant, the feature will appear as\n",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value:<unknown:ARGUMENT_TYPE>"),", where ",(0,r.mdx)("inlineCode",{parentName:"p"},"ARGUMENT_TYPE")," indicates how the\nargument value is provided at the callsite. For a model such as this:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def f (first, second, third) -> TaintSource[Test, ViaValueOf[second]]:...\n")),(0,r.mdx)("p",null,"The following function invocations will produce the features shown\nin the comments:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"f(*args)            # Generates via-value:<unknown:args>\nf(**kwargs)         # Generates via-value:<unknown:kwargs>\nf(second=foo)       # Generates via-value:<unknown:named>\nf(foo, bar)         # Generates via-value:<unknown:positional>\nf(*args, **kwargs)  # Generates via-value:<unknown:args_or_kwargs>\n")),(0,r.mdx)("p",null,"If the argument is not provided at the call site (e.g,\nusing the default value), the feature will appear as ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value:<missing>"),"."),(0,r.mdx)("p",null,"You can also associate a tag with a ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value")," feature to ensure that different\n",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value")," annotations don't interfere with each other. Here's how you can retain\nthe information that the name of the header was being set:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def django.http.response.HttpResponse.__setitem__(\n    self,\n    header: TaintSink[ResponseHeaderName],\n    value: TaintSink[ResponseHeaderValue, ViaValueOf[header, WithTag["set-header"]]\n): ...\n')),(0,r.mdx)("p",null,"The feature would now appear as ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-set-header-value:Access-Control-Allow-Origin"),"."),(0,r.mdx)("h3",{id:"via-type-feature-using-viatypeof"},(0,r.mdx)("inlineCode",{parentName:"h3"},"via-type")," Feature Using ",(0,r.mdx)("inlineCode",{parentName:"h3"},"ViaTypeOf[]")),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-type")," feature is nearly identical to the ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value")," feature, however,\nit captures ",(0,r.mdx)("em",{parentName:"p"},"the type of the specified argument, rather than it's value"),". Pysa\nwill retrieve the type information for the argument from Pyre, and add a feature\nsuch as ",(0,r.mdx)("inlineCode",{parentName:"p"},'"via-type": "str"'),", ",(0,r.mdx)("inlineCode",{parentName:"p"},'"via-type": "typing.List[str]"'),", or ",(0,r.mdx)("inlineCode",{parentName:"p"},'"via-type":\n"typing.Any"')," (in the case Pyre doesn't have type information)."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," is useful for sinks such as ",(0,r.mdx)("inlineCode",{parentName:"p"},"subprocess.run"),", which accepts\n",(0,r.mdx)("inlineCode",{parentName:"p"},"Union[bytes, str, Sequence]")," for it's ",(0,r.mdx)("inlineCode",{parentName:"p"},"arg")," parameter. The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-type")," feature\ncan help identify which type the argument to ",(0,r.mdx)("inlineCode",{parentName:"p"},"arg")," actually had. Knowing the\ntype of the argument can help assess the severity of a given issue (user\ncontrolled input in a ",(0,r.mdx)("inlineCode",{parentName:"p"},"str")," passed to ",(0,r.mdx)("inlineCode",{parentName:"p"},"arg")," is much easier to exploit for RCE\nthan user controlled input in one element of a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Sequence")," passed to ",(0,r.mdx)("inlineCode",{parentName:"p"},"arg"),")."),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value")," feature can be added anywhere that the ",(0,r.mdx)("inlineCode",{parentName:"p"},"via")," feature can be\nadded. It is added by specifying ",(0,r.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf[PARAMETER_NAME]"),", where\n",(0,r.mdx)("inlineCode",{parentName:"p"},"PARAMETER_NAME")," is the name of the function parameter for which you would like\nto capture the argument value:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def subprocess.run(\n    args: TaintSink[RemoteCodeExecution, ViaTypeOf[args]],\n): ...\n")),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-type")," feature can also be used on attribute or global models. For example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"my_module.MyClass.source: TaintSource[Test, ViaTypeOf] = ...\nmy_module.MyClass.sink: TaintSource[Test, ViaTypeOf] = ...\n")),(0,r.mdx)("p",null,"A standalone ",(0,r.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," is also supported in this case, and is shorthand for ",(0,r.mdx)("inlineCode",{parentName:"p"},"TaintInTaintOut[ViaTypeOf]"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"my_module.MyClass.my_attribute: ViaTypeOf = ...\n")),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-type")," feature also supports adding tags, using the same syntax as the ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value"),"\nfeature:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def subprocess.run(\n    args: TaintSink[RemoteCodeExecution, ViaTypeOf[args, WithTag["my_tag"]]]\n): ...\nmy_module.MyClass.sink: TaintSource[Test, ViaTypeOf[WithTag["my_tag"]]] = ...\nmy_module.MyClass.other_attribute: ViaTypeOf[WithTag["my_tag"]] = ...\n')),(0,r.mdx)("p",null,"Note that ",(0,r.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," on ",(0,r.mdx)("inlineCode",{parentName:"p"},"Annotated")," types will not include the annotations after the first type specified.\nThis is because Pyre does not store annotations as part of the type information. Consider the following code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'from typing import Annotated\n\nclass Foo:\n  x: Annotated[int, "foo"]\n')),(0,r.mdx)("p",null,"If there is a ",(0,r.mdx)("inlineCode",{parentName:"p"},"ViaTypeOf")," on ",(0,r.mdx)("inlineCode",{parentName:"p"},"Foo.x")," here, the feature shown on traces will be ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-type-of:typing.Annotated[int]"),",\n",(0,r.mdx)("strong",{parentName:"p"},"not")," ",(0,r.mdx)("inlineCode",{parentName:"p"},'via-type-of:typing.Annotated[int, "foo"]'),"."),(0,r.mdx)("h3",{id:"via-attribute-feature-using-viaattributename"},(0,r.mdx)("inlineCode",{parentName:"h3"},"via-attribute")," Feature Using ",(0,r.mdx)("inlineCode",{parentName:"h3"},"ViaAttributeName[]")),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-attribute")," feature is similar to the ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value")," feature, however,\nit can only be used to model attributes, and captures ",(0,r.mdx)("em",{parentName:"p"},"the name of the attribute\nbeing accessed"),"."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"my_module.MyClass.my_attribute: ViaAttributeName = ...\n")),(0,r.mdx)("p",null,"Pysa will add the feature ",(0,r.mdx)("inlineCode",{parentName:"p"},'"via-attribute:my_attribute')," when taint flows through\nthe attribute."),(0,r.mdx)("p",null,"This also supports tags, using the same syntax as ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'my_module.MyClass.my_attribute: ViaAttributeName[WithTag["example"]] = ...\n')),(0,r.mdx)("p",null,"Note that ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-attribute")," is most useful in\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-model-dsl#using-viaattributename-with-the-attributemodel-clause"},"model queries"),",\nwhen the attribute name is not known in advance."),(0,r.mdx)("h3",{id:"supporting-features-dynamically-using-viadynamicfeature"},"Supporting Features Dynamically Using ",(0,r.mdx)("inlineCode",{parentName:"h3"},"ViaDynamicFeature[]")),(0,r.mdx)("p",null,"In general, Pysa requires you to specify the list of features that are allowed. This encourages features\nto be documented, and help avoid typos when writing features so that the features propagating in the analysis are\nconsistent with filters you might have on issues."),(0,r.mdx)("p",null,"However, there might be very specific cases where you want to dynamically generate features, depending on artifacts\nof the code. Most cases here can be handled by ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-type")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"via-value")," features, however, you might be dealing with\ndynamic code or metadata that the system can't detect. In these cases, Pysa allows skipping validation on features\nby the use of ",(0,r.mdx)("inlineCode",{parentName:"p"},"ViaDynamicFeature"),". This syntax has identical behavior to ",(0,r.mdx)("inlineCode",{parentName:"p"},"Via[]")," except the lack of validation. Here's an example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def subprocess.run(\n  args: TaintSink[RemoteCodeExecution, ViaDynamicFeature[subprocess_run_execution]]\n): ...\n")),(0,r.mdx)("h2",{id:"automatic-features"},"Automatic Features"),(0,r.mdx)("h3",{id:"via-feature"},(0,r.mdx)("inlineCode",{parentName:"h3"},"via")," Feature"),(0,r.mdx)("p",null,"In addition to the manually specified ",(0,r.mdx)("inlineCode",{parentName:"p"},"via")," features, Pysa automatically adds\nsome ",(0,r.mdx)("inlineCode",{parentName:"p"},"via")," features with special meaning such as ",(0,r.mdx)("inlineCode",{parentName:"p"},"via:obscure:model"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"via:obscure:unknown-callee"),",\n",(0,r.mdx)("inlineCode",{parentName:"p"},"via:format-string"),", and ",(0,r.mdx)("inlineCode",{parentName:"p"},"via:tito"),". ",(0,r.mdx)("inlineCode",{parentName:"p"},"via:obscure:model")," means that the flow passed\nthrough code that Pysa does not have access to analyze, and thus some taint flow\nassumptions were made. This can be a useful feature to filter out flows that may be more\nnoisy. ",(0,r.mdx)("inlineCode",{parentName:"p"},"via:obscure:unknown-callee")," means that a call cannot be resolved as the callee is\nunknown (most likely because of missing type information). ",(0,r.mdx)("inlineCode",{parentName:"p"},"via:format-string")," means that\na flow passed through a ",(0,r.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0498/"},"python f-string")," (",(0,r.mdx)("inlineCode",{parentName:"p"},'f"Variable:\n{variable_name}"'),") or a ",(0,r.mdx)("inlineCode",{parentName:"p"},"str.format"),". Tito stands for taint-in-taint-out which refers to taint\nflows that enter a function via a parameter and then exit it in some form via\nthe return value. The ",(0,r.mdx)("inlineCode",{parentName:"p"},"via:tito")," feature is attached automatically to all such\nflows."),(0,r.mdx)("h3",{id:"type-feature"},(0,r.mdx)("inlineCode",{parentName:"h3"},"type")," Feature"),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"type")," feature is an automatically added feature which indicates that the\nflow passes through a conversion to the specified type. This feature currently\nonly tracks conversion to numeric values (ie. ",(0,r.mdx)("inlineCode",{parentName:"p"},"type:scalar"),"). This can be useful\nfor filtering out flows when numeric values are highly unlikely to result in an\nexploitable flow, such as SQL injection or RCE."),(0,r.mdx)("h3",{id:"first-field-feature"},(0,r.mdx)("inlineCode",{parentName:"h3"},"first-field")," Feature"),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"first-field")," feature is automatically added to flows for the first field\naccess on the flow. E.g., if ",(0,r.mdx)("inlineCode",{parentName:"p"},"request")," is a source, and the flow starts with\n",(0,r.mdx)("inlineCode",{parentName:"p"},"request.f"),", then ",(0,r.mdx)("inlineCode",{parentName:"p"},"first-field:f")," should be attached to the flow."),(0,r.mdx)("h3",{id:"first-index-feature"},(0,r.mdx)("inlineCode",{parentName:"h3"},"first-index")," Feature"),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"first-index")," feature is an automatically added feature which indicates that\na flow starts with a dictionary access using the specified constant as the key.\nThis is useful in cases such as Django's ",(0,r.mdx)("inlineCode",{parentName:"p"},"GET"),"/",(0,r.mdx)("inlineCode",{parentName:"p"},"POST"),"/",(0,r.mdx)("inlineCode",{parentName:"p"},"META")," dictionaries on the\n",(0,r.mdx)("inlineCode",{parentName:"p"},"HttpRequest")," object. A flow that started with as access of the ",(0,r.mdx)("inlineCode",{parentName:"p"},"HTTP_REFERER"),"\nheader from the ",(0,r.mdx)("inlineCode",{parentName:"p"},"META")," object would result in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"first-index:HTTP_REFERER"),"\nfeature being added."),(0,r.mdx)("h3",{id:"has-feature"},(0,r.mdx)("inlineCode",{parentName:"h3"},"has")," Feature"),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"has")," features is a summary feature for ",(0,r.mdx)("inlineCode",{parentName:"p"},"first-field")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"first-index"),".\nThus, ",(0,r.mdx)("inlineCode",{parentName:"p"},"has:first-index")," simply indicates that there is at least one\n",(0,r.mdx)("inlineCode",{parentName:"p"},"first-index:<name>")," feature present, and similarly for ",(0,r.mdx)("inlineCode",{parentName:"p"},"has:first-field"),"."),(0,r.mdx)("h3",{id:"always--modifier-on-features"},(0,r.mdx)("inlineCode",{parentName:"h3"},"always-")," Modifier on Features"),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"always-")," modifier will automatically be added to any of the above features,\nwhen every single flow within an issue has the feature. For example, if an issue\ncaptures flows from three different sources of user input into a SQL sink, the\n",(0,r.mdx)("inlineCode",{parentName:"p"},"always-type:scalar")," modifier would be added if all three of those flows pass\nthrough a conversion to ",(0,r.mdx)("inlineCode",{parentName:"p"},"int")," before reaching the sink. Note that ",(0,r.mdx)("strong",{parentName:"p"},"the\n",(0,r.mdx)("inlineCode",{parentName:"strong"},"always-")," version of a feature is ",(0,r.mdx)("em",{parentName:"strong"},"exclusive")," with the non-",(0,r.mdx)("inlineCode",{parentName:"strong"},"always-")," version"),";\nif ",(0,r.mdx)("inlineCode",{parentName:"p"},"always-type:scalar")," is present, ",(0,r.mdx)("inlineCode",{parentName:"p"},"type:scalar")," will not be present."),(0,r.mdx)("h3",{id:"broadening-features"},(0,r.mdx)("inlineCode",{parentName:"h3"},"broadening")," Features"),(0,r.mdx)("p",null,"Pysa automatically adds broadening features when\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-advanced#taint-broadening"},"taint broadening")," is applied during the\nanalysis."),(0,r.mdx)("p",null,"Broadening features are:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"tito-broadening")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"model-broadening")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"model-source-broadening")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"model-sink-broadening")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"model-tito-broadening")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"model-shaping")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"model-source-shaping")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"model-sink-shaping")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"model-tito-shaping")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"widen-broadening")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"issue-broadening"))),(0,r.mdx)("p",null,"See ",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-advanced#taint-broadening"},"taint broadening")," for more infomation."))}c.isMDXComponent=!0}}]);