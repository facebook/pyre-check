"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9281],{15680:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>s,MDXProvider:()=>u,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>m});var t=a(96540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},o.apply(this,arguments)}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function d(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),m=function(e){return function(n){var a=p(n.components);return t.createElement(e,o({},n,{components:a}))}},p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),m=p(a),u=i,h=m["".concat(r,".").concat(u)]||m[u]||c[u]||o;return a?t.createElement(h,l(l({ref:n},s),{},{components:a})):t.createElement(h,l({ref:n},s))}));function f(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=h;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=a[s];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},29512:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>m,contentTitle:()=>d,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var t=a(9668),i=a(21367),o=(a(96540),a(15680)),r=["components"],l={id:"pysa-advanced",title:"Advanced Topics",sidebar_label:"Advanced Topics"},d=void 0,s={unversionedId:"pysa-advanced",id:"pysa-advanced",title:"Advanced Topics",description:"This page documents more advanced bits of Pysa.",source:"@site/docs/pysa_advanced.md",sourceDirName:".",slug:"/pysa-advanced",permalink:"/docs/pysa-advanced",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/pysa_advanced.md",tags:[],version:"current",frontMatter:{id:"pysa-advanced",title:"Advanced Topics",sidebar_label:"Advanced Topics"},sidebar:"pysa",previous:{title:"Feature Annotations",permalink:"/docs/pysa-features"},next:{title:"Implementation Details",permalink:"/docs/pysa-implementation-details"}},m={},p=[{value:"Conditional models based on Python version",id:"conditional-models-based-on-python-version",level:2},{value:"Obscure models",id:"obscure-models",level:2},{value:"Parameter and return path",id:"parameter-and-return-path",level:2},{value:"Access path definition",id:"access-path-definition",level:3},{value:"all()",id:"all",level:4},{value:"keys()",id:"keys",level:4},{value:"all_static_fields()",id:"all_static_fields",level:4},{value:"parameter_name()",id:"parameter_name",level:4},{value:"Taint In Taint Out",id:"taint-in-taint-out",level:3},{value:"Taint propagation from arguments to self",id:"taint-propagation-from-arguments-to-self",level:2},{value:"Taint propagation between arguments",id:"taint-propagation-between-arguments",level:2},{value:"Taint broadening",id:"taint-broadening",level:2},{value:"Broadening on obscure models",id:"broadening-on-obscure-models",level:3},{value:"Broadening on taint-in-taint-out (TITO)",id:"broadening-on-taint-in-taint-out-tito",level:3},{value:"Model broadening",id:"model-broadening",level:3},{value:"Model shaping",id:"model-shaping",level:3},{value:"Widen broadening",id:"widen-broadening",level:3},{value:"Issue broadening",id:"issue-broadening",level:3},{value:"Tainting Specific <code>kwargs</code>",id:"tainting-specific-kwargs",level:2},{value:"Instance attributes versus class attributes",id:"instance-attributes-versus-class-attributes",level:2},{value:"Literal String Sources And Sinks",id:"literal-string-sources-and-sinks",level:2},{value:"Combined Source Rules",id:"combined-source-rules",level:2},{value:"String Combine Rules",id:"string-combine-rules",level:2},{value:"Prevent Inferring Models with <code>SkipAnalysis</code>",id:"prevent-inferring-models-with-skipanalysis",level:2},{value:"Ignoring overrides",id:"ignoring-overrides",level:2},{value:"Force to analyze all overrides",id:"force-to-analyze-all-overrides",level:2},{value:"Force to treat a callable as being called when passed as parameters",id:"force-to-treat-a-callable-as-being-called-when-passed-as-parameters",level:2},{value:"Limit the trace length for better signal and performance",id:"limit-the-trace-length-for-better-signal-and-performance",level:2},{value:"Limit the trace length for a given rule",id:"limit-the-trace-length-for-a-given-rule",level:2},{value:"Limit the tito depth for better signal and performance",id:"limit-the-tito-depth-for-better-signal-and-performance",level:2},{value:"Decorators",id:"decorators",level:2},{value:"Ignoring decorators",id:"ignoring-decorators",level:2},{value:"Inlining decorators",id:"inlining-decorators",level:2},{value:"Prevent Inlining Decorators with <code>SkipDecoratorWhenInlining</code>",id:"prevent-inlining-decorators-with-skipdecoratorwheninlining",level:3},{value:"Single trace sanitizers with <code>@SanitizeSingleTrace</code>",id:"single-trace-sanitizers-with-sanitizesingletrace",level:2},{value:"Filtering the call graph with <code>@Entrypoint</code>",id:"filtering-the-call-graph-with-entrypoint",level:2},{value:"Taint In Taint Out Transforms",id:"taint-in-taint-out-transforms",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Semantics",id:"semantics",level:3},{value:"Analysis thresholds",id:"analysis-thresholds",level:2},{value:"Maximum model source tree width",id:"maximum-model-source-tree-width",level:3},{value:"Maximum model sink tree width",id:"maximum-model-sink-tree-width",level:3},{value:"Maximum model tito tree width",id:"maximum-model-tito-tree-width",level:3},{value:"Maximum tree depth after widening",id:"maximum-tree-depth-after-widening",level:3},{value:"Maximum return access path width",id:"maximum-return-access-path-width",level:3},{value:"Maximum return access path depth after widening",id:"maximum-return-access-path-depth-after-widening",level:3},{value:"Maximum tito collapse depth",id:"maximum-tito-collapse-depth",level:3},{value:"Maximum tito positions",id:"maximum-tito-positions",level:3}],u={toc:p};function c(e){var n=e.components,a=(0,i.A)(e,r);return(0,o.mdx)("wrapper",(0,t.A)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"This page documents more advanced bits of Pysa."),(0,o.mdx)("h2",{id:"conditional-models-based-on-python-version"},"Conditional models based on Python version"),(0,o.mdx)("p",null,"Pysa models support if conditions but only for version comparisons for the python\nversion used to run pysa. This allows for conditional parsing of models and allows\ndifferent models to be used for different versions of python."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"if sys.version == (3,9,0):\n    def module.foo(): ...\nelse:\n    def module.bar(): ...\n")),(0,o.mdx)("p",null,"In this example, the first model will only be parsed and honored if the python\nversion in the system or virtual environment from which Pysa is run is equal\nto ",(0,o.mdx)("inlineCode",{parentName:"p"},"3.9.0"),". In all other conditions, the second model will be parsed and honored."),(0,o.mdx)("p",null,"sys.version is the only allowed left hand expression and the right hand expression\nhas to be a tuple of integers of the form (major, minor, micro). Only the major\nversion number is required and the other two are optional."),(0,o.mdx)("p",null,"The comparison operators supported include ",(0,o.mdx)("inlineCode",{parentName:"p"},"==")," (equal to), ",(0,o.mdx)("inlineCode",{parentName:"p"},"!=")," (not equal to),\n",(0,o.mdx)("inlineCode",{parentName:"p"},"<")," (less than), ",(0,o.mdx)("inlineCode",{parentName:"p"},">")," greater than, ",(0,o.mdx)("inlineCode",{parentName:"p"},"<=")," (less than or equal to), and\n",(0,o.mdx)("inlineCode",{parentName:"p"},">=")," (greater than or equal to)."),(0,o.mdx)("p",null,"If conditions can also be nested inside one another and follow the same behavior\nas python if conditions."),(0,o.mdx)("h2",{id:"obscure-models"},"Obscure models"),(0,o.mdx)("p",null,"When Pysa does not have enough information about a function or method, it will\nmake basic assumptions about its behavior. This is referred to as an ",(0,o.mdx)("strong",{parentName:"p"},"obscure\nmodel"),". Most notably, it assumes that the function or method propagates the\ntaint from its arguments to its return value."),(0,o.mdx)("p",null,"This usually happens when Pysa doesn't know about the callee of a function call:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(f: Any):\n    x = input()\n    y = f(x) # no information about `f`, y will be considered tainted.\n    eval(y)\n")),(0,o.mdx)("p",null,"Functions and methods defined in type stubs or in a different language (for\ninstance, in C or C++ bindings) will also be treated as obscure models."),(0,o.mdx)("p",null,"To prevent a function or method from being marked as obscure, one can use the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"@SkipObscure")," taint annotation in a ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipObscure\ndef module.foo(): ...\n")),(0,o.mdx)("h2",{id:"parameter-and-return-path"},"Parameter and return path"),(0,o.mdx)("p",null,"When writing a model for a source, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"ReturnPath")," annotation allows to specify\nwhich index or attribute of the returned value is tainted. For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def only_attribute_foo_tainted() -> TaintSource[Test, ReturnPath[_.foo]]: ...\n")),(0,o.mdx)("p",null,"Similarly, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"ParameterPath")," annotation allows to specify which index or attribute\nof an argument leads to a sink. For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def only_arg_dot_bar_is_sink(arg: TaintSink[Test, ParameterPath[_.bar]]): ...\n")),(0,o.mdx)("h3",{id:"access-path-definition"},"Access path definition"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"ParameterPath")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"ReturnPath")," annotation takes an ",(0,o.mdx)("strong",{parentName:"p"},"access path")," as an argument.\nAn access path starts with an underscore ",(0,o.mdx)("inlineCode",{parentName:"p"},"_")," which represents the whole argument or\nreturn value (depending on the context). The underscore can be followed by attribute\naccesses (e.g, ",(0,o.mdx)("inlineCode",{parentName:"p"},"_.foo.bar"),") and index accesses (e.g, ",(0,o.mdx)("inlineCode",{parentName:"p"},'_["foo"][0]["bar"]'),"), or a\ncombination of both (e.g, ",(0,o.mdx)("inlineCode",{parentName:"p"},"_.foo[0]"),")."),(0,o.mdx)("p",null,"In addition to these, four special calls can be used: ",(0,o.mdx)("inlineCode",{parentName:"p"},".all()"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},".keys()"),",\n",(0,o.mdx)("inlineCode",{parentName:"p"},".parameter_name()")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},".all_static_fields()"),"."),(0,o.mdx)("h4",{id:"all"},"all()"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},".all()")," is used to represent that any index might be tainted. This is usually when\nthe index cannot be known statically. For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(i: int):\n  i = random.randint(0, 100)\n  return {i: source()}\n")),(0,o.mdx)("p",null,"This can be represented by the model:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(): TaintSource[Test, ReturnPath[_.all()]]: ...\n")),(0,o.mdx)("h4",{id:"keys"},"keys()"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},".keys()")," is used to represent that any key of the dictionary might be tainted.\nFor instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo():\n  return {source(): 0}\n")),(0,o.mdx)("p",null,"This can be represented by the model:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(): TaintSource[Test, ReturnPath[_.keys()]]: ...\n")),(0,o.mdx)("h4",{id:"all_static_fields"},"all_static_fields()"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},".all_static_fields()")," is used to mark all statically-known attributes of the\ngiven parameter or return value as a source or sink. The set of attributes is\ndetermined using the type annotation of the parameter or return value. If it is\nnot annotated or that we could not find any attributes, the whole parameter or\nreturn value will be marked as a source or sink instead."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class A:\n  x: str\n  y: str\n\ndef foo(a: A) -> B: ...\n")),(0,o.mdx)("p",null,"Using the following model:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(a: TaintSink[Test, ParameterPath[_.all_static_fields()]]): ...\n")),(0,o.mdx)("p",null,"This will add a sink on ",(0,o.mdx)("inlineCode",{parentName:"p"},"a.x")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"a.y"),"."),(0,o.mdx)("p",null,"This can also be used on the return value:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo() -> TaintSource[Test, ReturnPath[_.all_static_fields()]]: ...\n")),(0,o.mdx)("p",null,"In general, we recommend to ",(0,o.mdx)("strong",{parentName:"p"},"mark the whole parameter or return value")," as a\nsource or sink. This feature is ",(0,o.mdx)("strong",{parentName:"p"},"only useful")," for power users that post\nprocess the result of the analysis and extract leaf ports. It is also very\n",(0,o.mdx)("strong",{parentName:"p"},"computationally expensive"),"."),(0,o.mdx)("h4",{id:"parameter_name"},"parameter_name()"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},".parameter_name()")," will be replaced by the name of the parameter that is being\nmodelled. This can only be used for ",(0,o.mdx)("inlineCode",{parentName:"p"},"TaintInTaintOut")," on parameters of functions\nor methods. This is usually useful to model constructors of dataclass-like\nclasses."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"class A:\n  def __init__(self, x, y, z):\n    # method too complicated\n    pass\n")),(0,o.mdx)("p",null,"Using the following ",(0,o.mdx)("a",{parentName:"p",href:"/docs/pysa-model-dsl"},"model query"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'ModelQuery(\n  name="constructors",\n  find="method",\n  where=[fully_qualified_name.equals("A.__init__")],\n  model=[\n    Parameters(TaintInTaintOut[LocalReturn, NoCollapse, ReturnPath[_.parameter_name()]]),\n    Modes([SkipAnalysis])\n  ]\n)\n')),(0,o.mdx)("p",null,"This will automatically propagate taint from parameters ",(0,o.mdx)("inlineCode",{parentName:"p"},"x"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"y"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"z")," to\n",(0,o.mdx)("inlineCode",{parentName:"p"},"self.x"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"self.y")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"self.z"),". Note that if the code is available and the\nconstructor is not too complex, Pysa will do that automatically without the need\nfor a model."),(0,o.mdx)("h3",{id:"taint-in-taint-out"},"Taint In Taint Out"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"ParameterPath")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"ReturnPath")," can also be used to give more information about\na propagation. For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo(arg):\n  return {"a": arg["b"][42]}\n')),(0,o.mdx)("p",null,"This can be represented by the model:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo(arg: TaintInTaintOut[ParameterPath[_["b"][42]], ReturnPath[_["a"]]]): ...\n')),(0,o.mdx)("p",null,"Note that Pysa will automatically infer propagations if it has access to the body\nof the function. Writing taint-in-taint-out models should rarely be required."),(0,o.mdx)("p",null,"When using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"Updates")," annotation, the annotation ",(0,o.mdx)("inlineCode",{parentName:"p"},"UpdatePath")," is used instead\nof ",(0,o.mdx)("inlineCode",{parentName:"p"},"ReturnPath"),". For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def MyClass.updates_foo(self, x: TaintInTaintOut[Updates[self], UpdatePath[_.foo]]): ...\n")),(0,o.mdx)("h2",{id:"taint-propagation-from-arguments-to-self"},"Taint propagation from arguments to self"),(0,o.mdx)("p",null,"By default, Pysa only infers taint propagation from arguments to self for\nconstructors, property setters and the special ",(0,o.mdx)("inlineCode",{parentName:"p"},"__setitem__")," method."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'class Foo:\n  def __init__(self, x):\n    self.x = x\n\n  def set_x(self, x):\n    self.x = x\n\ndef issue():\n  foo = Foo(source())\n  sink(foo)  # Issue found.\n\n  foo = Foo("")\n  foo.set_x(source())\n  sink(foo)  # Issue NOT found.\n')),(0,o.mdx)("p",null,"To enable the inference of propagations from arguments to self for all methods,\none can provide the command line argument ",(0,o.mdx)("inlineCode",{parentName:"p"},"--infer-self-tito")," or use the taint\nannotation ",(0,o.mdx)("inlineCode",{parentName:"p"},"@InferSelfTito")," in a ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@InferSelfTito\ndef my_module.Foo.set_x(): ...\n")),(0,o.mdx)("p",null,"Pysa would now find the second issue properly. Note that ",(0,o.mdx)("inlineCode",{parentName:"p"},"--infer-self-tito")," can\nsignificantly increase the analysis time as well as the amount of false positives."),(0,o.mdx)("h2",{id:"taint-propagation-between-arguments"},"Taint propagation between arguments"),(0,o.mdx)("p",null,"By default, Pysa does NOT infer taint propagation between arguments. For short,\nit assumes that functions do not mutate their arguments."),(0,o.mdx)("p",null,"For instance, this flow will NOT be found:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def append_wrapper(l: List[str], v: str) -> None:\n  l.append(v)\n\ndef issue():\n  l = []\n  append_wrapper(l, source())\n  sink(l[0])  # Issue NOT found.\n")),(0,o.mdx)("p",null,"To enable the inference of propagations between arguments for all functions and\nmethods, one can provide the command line argument ",(0,o.mdx)("inlineCode",{parentName:"p"},"--infer-argument-tito")," or\nuse the taint annotation ",(0,o.mdx)("inlineCode",{parentName:"p"},"@InferArgumentTito")," in a ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@InferSelfTito\ndef my_module.append_wrapper(): ...\n")),(0,o.mdx)("p",null,"Pysa would now find the issue properly. Note that ",(0,o.mdx)("inlineCode",{parentName:"p"},"--infer-argument-tito")," can\nsignificantly increase the analysis time as well as the amount of false positives."),(0,o.mdx)("h2",{id:"taint-broadening"},"Taint broadening"),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Taint broadening")," is an over-approximation performed by the taint analysis\nfor correctness or performance reasons. After applying broadening, Pysa\nconsiders that a whole object or variable is tainted when only some attributes\nor keys were initially tainted."),(0,o.mdx)("p",null,"This is also called ",(0,o.mdx)("strong",{parentName:"p"},"taint collapsing")," or ",(0,o.mdx)("strong",{parentName:"p"},"tree collapsing")," because the taint\nis internally represented as a tree structure where edges are attributes or keys.\nCollapsing means merging the taint on all children into the root of the tree."),(0,o.mdx)("p",null,"For instance, this happens when Pysa does not have access to the body of a\nfunction:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def obscure_function(arg): ...\n\n\ndef foo():\n  # Only `x['a']` is tainted.\n  x = {\"a\": source()}\n\n  # Taint broadening happens, `y` and all its attributes are considered tainted.\n  y = obscure_function(x)\n\n  # This is considered an issue, even if only `x['a']` was initially tainted.\n  sink(y['b'])\n\n  # Also an issue, `y` is entirely tainted.\n  sink(y)\n")),(0,o.mdx)("p",null,"Note that whenever broadening happens, Pysa will automatically add a broadening\n",(0,o.mdx)("a",{parentName:"p",href:"/docs/pysa-features"},"feature")," on the taint flow, which can help discard false\npositives in post processing. Fine grained features are used for each different\nscenario leading to broadening."),(0,o.mdx)("p",null,"The most common causes for taint broadening are the following:"),(0,o.mdx)("h3",{id:"broadening-on-obscure-models"},"Broadening on obscure models"),(0,o.mdx)("p",null,"Taint that flows through an ",(0,o.mdx)("a",{parentName:"p",href:"#obscure-models"},"obscure model")," - for instance,\nwhen Pysa does not have access to the body of the callee - is collapsed, since\nwe must assume anything could get tainted, for correctness."),(0,o.mdx)("p",null,"In this scenario, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"tito-broadening")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"via:obscure:model")," features are\nadded to the flow."),(0,o.mdx)("h3",{id:"broadening-on-taint-in-taint-out-tito"},"Broadening on taint-in-taint-out (TITO)"),(0,o.mdx)("p",null,"When specifying a ",(0,o.mdx)("a",{parentName:"p",href:"/docs/pysa-basics#taint-propagation"},"taint propagation")," (also\ncalled ",(0,o.mdx)("strong",{parentName:"p"},"Taint In Taint Out")," or ",(0,o.mdx)("strong",{parentName:"p"},"TITO"),") in a ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file, the propagation\nwill collapse the taint by default."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# models.pysa\ndef tito(arg: TaintInTaintOut): ...\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo():\n  x = {\"a\": source()}\n  y = tito(x)\n  sink(y['b']) # Considered an issue because of taint broadening.\n")),(0,o.mdx)("p",null,"In this scenario, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"tito-broadening")," feature is added to the flow."),(0,o.mdx)("p",null,"If the function is known to preserve the structure of the argument, the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"NoCollapse")," annotation can be used to disable collapsing. For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def tito(arg: TaintInTaintOut[NoCollapse]): ...\n")),(0,o.mdx)("p",null,"This would remove the issue from the previous example."),(0,o.mdx)("p",null,"Note that this can be used in combination with\n",(0,o.mdx)("a",{parentName:"p",href:"#parameter-and-return-path"},(0,o.mdx)("inlineCode",{parentName:"a"},"ParameterPath")," and ",(0,o.mdx)("inlineCode",{parentName:"a"},"ReturnPath")),"."),(0,o.mdx)("h3",{id:"model-broadening"},"Model broadening"),(0,o.mdx)("p",null,"When the number of tainted attributes or keys hits a certain threshold, taint\nbroadening is applied to prevent the analysis from blowing up by tracking too\nmany values."),(0,o.mdx)("p",null,"This is referred as ",(0,o.mdx)("strong",{parentName:"p"},"Model broadening")," since this happens when the model (or\nsummary) of a function is computed."),(0,o.mdx)("p",null,"For instance, this can happen when the number of tainted key-value pairs of a\ndictionary hit a certain threshold. For scalability reasons, Pysa cannot track\nan infinite amount of indices, and thus makes the approximation that the whole\nobject is tainted."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo(condition):\n    d = {}\n    if condition:\n        d["a"] = source()\n        d["b"] = source()\n        # c, d, e, etc.\n    else:\n        d["1"] = source()\n        d["2"] = source()\n        # etc.\n    return d # too many indexes, the whole return value is considered tainted.\n')),(0,o.mdx)("p",null,"In this scenario, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-broadening")," feature is added to the flow."),(0,o.mdx)("p",null,"See ",(0,o.mdx)("a",{parentName:"p",href:"#analysis-thresholds"},"analysis thresholds")," for documentation about the\ndifferent scenarios of model broadening."),(0,o.mdx)("p",null,"Note that model broadening can be disabled for a given function or method using\nthe ",(0,o.mdx)("inlineCode",{parentName:"p"},"@SkipModelBroadening")," annotation in a ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipModelBroadening\ndef foo(): ...\n")),(0,o.mdx)("p",null,"This can also be used in a ",(0,o.mdx)("inlineCode",{parentName:"p"},"ModelQuery")," using the\n",(0,o.mdx)("a",{parentName:"p",href:"/docs/pysa-model-dsl##models-for-setting-modes"},(0,o.mdx)("inlineCode",{parentName:"a"},"Modes"))," clause."),(0,o.mdx)("p",null,"Note that this should be used sparingly since this can potentially lead to an\nincrease in analysis time."),(0,o.mdx)("h3",{id:"model-shaping"},"Model shaping"),(0,o.mdx)("p",null,"When a specific attribute or key is tainted when the whole object is tainted\nwith the same taint kind (e.g, ",(0,o.mdx)("inlineCode",{parentName:"p"},"UserControlled"),"), taint collapsing is applied\nas an optimization to save analysis time. This is called ",(0,o.mdx)("strong",{parentName:"p"},"model shaping")," and\nis applied right before ",(0,o.mdx)("strong",{parentName:"p"},"model broadening"),"."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def my_sink(x):\n  sink(x)\n  sink(x.foo)\n")),(0,o.mdx)("p",null,"The sink on ",(0,o.mdx)("inlineCode",{parentName:"p"},"x.foo")," (represented as ",(0,o.mdx)("inlineCode",{parentName:"p"},"formal(x)[foo]"),") is merged into the sink\non ",(0,o.mdx)("inlineCode",{parentName:"p"},"x"),"."),(0,o.mdx)("p",null,"Note that this is sound since attributes of a tainted object are also considered\ntainted. Thus if ",(0,o.mdx)("inlineCode",{parentName:"p"},"my_sink")," is actually called with ",(0,o.mdx)("inlineCode",{parentName:"p"},"x.foo")," tainted, the flow\nwill be found as expected."),(0,o.mdx)("p",null,"The downside is that this can lead to false positives in cases where ",(0,o.mdx)("inlineCode",{parentName:"p"},"my_sink"),"\nis called with another attribute (say ",(0,o.mdx)("inlineCode",{parentName:"p"},"x.bar"),") tainted. We would find a flow\nfrom ",(0,o.mdx)("inlineCode",{parentName:"p"},"x.bar")," to ",(0,o.mdx)("inlineCode",{parentName:"p"},"x.foo")," in ",(0,o.mdx)("inlineCode",{parentName:"p"},"my_sink"),"."),(0,o.mdx)("p",null,"In this scenario, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-shaping")," feature is added to the flow. The features\n",(0,o.mdx)("inlineCode",{parentName:"p"},"model-source-shaping"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-sink-shaping")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-tito-shaping")," are also\nadded to differentiate whether the shaping was on sources, sinks or tito."),(0,o.mdx)("h3",{id:"widen-broadening"},"Widen broadening"),(0,o.mdx)("p",null,"When the number of tainted attributes or keys is potentially infinite because of\na loop or recursion, taint broadening is applied to allow the termination of the\nanalysis."),(0,o.mdx)("p",null,'The term "widen" or "widening" refers to an operator that is applied to ensure\nconvergence. It commonly happens within loops.'),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo(n):\n  d = {}\n  for _ in range(n):\n    d = {\n      "a": source(),\n      "b": d,\n    }\n  return d\n')),(0,o.mdx)("p",null,"Technically, ",(0,o.mdx)("inlineCode",{parentName:"p"},"d['b']...['b']['a']")," (with an infinite number of access to ",(0,o.mdx)("inlineCode",{parentName:"p"},"b"),")\ncould be tainted. To allow the analysis to terminate, Pysa stops at a certain\ndepth. See ",(0,o.mdx)("a",{parentName:"p",href:"#analysis-thresholds"},"analysis thresholds")," for documentation about\nthe different scenarios of widen broadening."),(0,o.mdx)("p",null,"Another example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(person):\n    while person.parent is not None:\n        person = person.parent\n        # Infer sinks on person.name, person.parent.name, person.parent.parent.name, etc.\n        sink(person.name)\n")),(0,o.mdx)("p",null,"In these scenarios, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"widen-broadening")," feature is added to the flow."),(0,o.mdx)("h3",{id:"issue-broadening"},"Issue broadening"),(0,o.mdx)("p",null,"When an object with a tainted attribute or key reaches a sink, Pysa considers\nthe flow as valid even if the whole object is not tainted."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'d = {"a": source(), "b": "foo"}\nsink(d) # `d` itself is not tainted, but `d["a"]` is, thus we emit an issue.\n')),(0,o.mdx)("p",null,"In this scenario, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"issue-broadening")," feature is added to the issue."),(0,o.mdx)("h2",{id:"tainting-specific-kwargs"},"Tainting Specific ",(0,o.mdx)("inlineCode",{parentName:"h2"},"kwargs")),(0,o.mdx)("p",null,"Sometimes, a function can have potential sinks mixed together with benign\nparameters in the keyword arguments (",(0,o.mdx)("inlineCode",{parentName:"p"},"kwargs"),") that it accepts. In these cases,\ntainting the whole ",(0,o.mdx)("inlineCode",{parentName:"p"},"kwargs")," variable will result in false positives when tainted\ndata flows into a benign ",(0,o.mdx)("inlineCode",{parentName:"p"},"kwarg"),". Instead, for a function like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def eval_and_log(**kwargs):\n    eval(kwargs["eval"])\n    logging.debug(kwargs["log"])\n')),(0,o.mdx)("p",null,"We can lie a bit in our ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file, and break out the dangerous argument for\ntainting:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def eval_and_log(*, eval: TaintSink[RemoteCodeExecution], **kwargs): ...\n")),(0,o.mdx)("p",null,"This allows us to catch flows only into the ",(0,o.mdx)("inlineCode",{parentName:"p"},"eval")," keyword argument."),(0,o.mdx)("h2",{id:"instance-attributes-versus-class-attributes"},"Instance attributes versus class attributes"),(0,o.mdx)("p",null,"Models can specify sources and sinks on attributes, following the type annotation\nsyntax:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"django.http.request.HttpRequest.GET: TaintSource[UserControlled]\n")),(0,o.mdx)("p",null,"Any access to ",(0,o.mdx)("inlineCode",{parentName:"p"},"request.GET")," will be tainted when ",(0,o.mdx)("inlineCode",{parentName:"p"},"request")," is an instance of\n",(0,o.mdx)("inlineCode",{parentName:"p"},"HttpRequest")," or any of its children. However, note that the access to the class\nattribute (i.e, ",(0,o.mdx)("inlineCode",{parentName:"p"},"HttpRequest.GET"),") won't be considered tainted."),(0,o.mdx)("p",null,"To specify sources and sinks on class attributes, use the ",(0,o.mdx)("inlineCode",{parentName:"p"},"__class__")," prefix:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"django.http.request.HttpRequest.__class__.GET: TaintSource[UserControlled]\n")),(0,o.mdx)("p",null,"To specify a source on both the class attribute and instance attribute, simply\nuse both lines."),(0,o.mdx)("h2",{id:"literal-string-sources-and-sinks"},"Literal String Sources And Sinks"),(0,o.mdx)("p",null,"Some security vulnerabilities are best captured by modeling strings of a given\nform flowing to dangerous functions, or format strings that match a pattern getting\ntainted data passed in."),(0,o.mdx)("p",null,"To mark all literal strings matching a pattern as sources, you first need to add a\nregular expression corresponding to the pattern to your ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "name": "IPAddress"\n    }\n  ],\n  "implicit_sources": {\n     "literal_strings": [\n       {\n         "regexp": "\\\\d{1,3}(\\\\.\\\\d{1,3})+",\n         "kind": "IPAddress",\n         "description": "String that looks like an IP address."\n       }\n     ]\n  }\n}\n')),(0,o.mdx)("p",null,"With this regex in place, whenever Pysa sees a string such as ",(0,o.mdx)("inlineCode",{parentName:"p"},"123.456.789.123"),", it will flag it\nas a taint source with the kind ",(0,o.mdx)("inlineCode",{parentName:"p"},"IPAddress"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def test() -> None:\n    ip_address = "123.456.789.123"\n    dont_pass_an_ip_address(ip_address) # Pysa will now flag this.\n')),(0,o.mdx)("p",null,"The converse of supporting literal strings as sinks is also supported, for data flowing into a tainted string. The\nsyntax allows you to model data being used to format strings, like f-strings, manual string formatting, the string ",(0,o.mdx)("inlineCode",{parentName:"p"},"format()")," method, and printf-style string formatting with ",(0,o.mdx)("inlineCode",{parentName:"p"},"%"),"."),(0,o.mdx)("p",null,"Template strings and manual string formatting with more than two subexpressions are not yet supported."),(0,o.mdx)("p",null,"To add a literal sink, first add the literal_sink to your configuration"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sinks": [\n    { "name": "MayBeRendered" },\n    { "name": "MayBeSQL" }\n  ],\n  "implicit_sinks": {\n     "literal_strings": [\n       {\n         "regexp": "^<.*>$",\n         "kind": "MayBeRendered",\n         "description": "Indicates a string whose contents may be rendered."\n       },\n       {\n         "regexp": "^SELECT *.",\n         "kind": "MayBeSQL",\n         "description": "Indicates a string whose contents may be a SQL query."\n       }\n\n     ]\n  }\n')),(0,o.mdx)("p",null,"Now, Pysa will treat any values flowing into a each of the following as a regular sink:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def may_render(parameter: str) -> None:\n    result = f"<content={parameter}>"\n    result = "<content={}>".format(parameter)\n    result = "<content%s>" % (parameter,)\n')),(0,o.mdx)("p",null,"As well as values flowing into each of these as a regular sink:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def build_sql_query(columns: str) -> None:\n    result = f"SELECT {columns} FROM users;"\n    result = "SELECT {} FROM users;".format(columns)\n    result = "SELECT %s FROM users" % (columns,)\n    result = "SELECT " + columns + " FROM users;"\n')),(0,o.mdx)("p",null,"Note that string literal sinks have some limitations. For instance, they cannot catch issues if the string literal is stored in a temporary variable (e.g., ",(0,o.mdx)("inlineCode",{parentName:"p"},'x = "SELECT {}"; x.format(input)'),"). We recommend using string combine rules instead (see below)."),(0,o.mdx)("h2",{id:"combined-source-rules"},"Combined Source Rules"),(0,o.mdx)("p",null,"Some security vulnerabilities are better modeled as ",(0,o.mdx)("em",{parentName:"p"},"two")," sources reaching\nsinks at the same call site. For example, leaking credentials via ",(0,o.mdx)("inlineCode",{parentName:"p"},"requests.get")," could be modeled as\nuser controlled data flowing into the ",(0,o.mdx)("inlineCode",{parentName:"p"},"url")," parameter and credentials flowing\ninto the ",(0,o.mdx)("inlineCode",{parentName:"p"},"params")," parameter. These flows can be modeled by ",(0,o.mdx)("em",{parentName:"p"},"combined source\nrules"),"."),(0,o.mdx)("p",null,"Sources for combined source rules are declared as normal in ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config"),".\nSinks, however, are declared inside the rule definition, and are referred to as ",(0,o.mdx)("em",{parentName:"p"},"partial sinks"),".\nThe rule itself is declared in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"combined_source_rules")," top level entry.\nThe actual flows are defined under section ",(0,o.mdx)("inlineCode",{parentName:"p"},"rule"),", which must contain two flows, one for each source. Each flow specifies a pair of (potentially multiple) sources and a single partial sink:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    { "name": "UserControlled" },\n    { "name": "Credentials" }\n  ],\n  "combined_source_rules": [\n    {\n       "name": "Credentials leaked through requests",\n       "rule": [\n        {\n           "sources": [ "UserControlled" ],\n           "partial_sink": "UserControlledRequestSink"\n         },\n         {\n           "sources": [ "Credentials" ],\n           "partial_sink": "CredentialsSink"\n         }\n       ],\n       "code": 1,\n       "message_format": "Credentials leaked through requests",\n       "main_trace_source": "url",\n    }\n  ]\n}\n')),(0,o.mdx)("p",null,"Sources are declared as normal in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files. Instead of specifying sinks\nwith a ",(0,o.mdx)("inlineCode",{parentName:"p"},"TaintSink")," annotation, however, ",(0,o.mdx)("inlineCode",{parentName:"p"},"PartialSink")," annotations are used to\nspecify where each source needs to flow for the combined source rule. These\n",(0,o.mdx)("inlineCode",{parentName:"p"},"PartialSink")," must reference the ones that were declared by\nthe rule above:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def requests.api.get(\n  url: PartialSink[UserControlledRequestSink],\n  params: PartialSink[CredentialsSink],\n  **kwargs\n): ...\n")),(0,o.mdx)("p",null,"With the above configuration, Pysa can detect cases where ",(0,o.mdx)("inlineCode",{parentName:"p"},"UserControlled")," flows\ninto ",(0,o.mdx)("inlineCode",{parentName:"p"},"url")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"Credentials")," flow into ",(0,o.mdx)("inlineCode",{parentName:"p"},"params")," ",(0,o.mdx)("em",{parentName:"p"},"at the same time")," (or at the same call site)."),(0,o.mdx)("p",null,"Note that the same partial sink can be used in different rules, which avoids duplicating a given model for each rule (in some cases)."),(0,o.mdx)("h2",{id:"string-combine-rules"},"String Combine Rules"),(0,o.mdx)("p",null,"It is sometimes useful to detect data tainted with a source (e.g., ",(0,o.mdx)("inlineCode",{parentName:"p"},"UserControlled")," data) that is incorporated into a suspicious looking string (e.g., a string that looks like a SQL query). Detecting such a pattern is useful, because it allows Pysa to detect dynamic creation of SQL queries which could lead to SQL injection, even if the code under analysis is using a SQL framework that Pysa does not have models for."),(0,o.mdx)("p",null,"To detect such flows, one can specify a variant of ",(0,o.mdx)("a",{parentName:"p",href:"#combined-source-rules"},"combined source rules"),", called string combine rules, to detect when the suspicious string (identified via regex match) and the other configured source both flow into string formatting call sites (such as calling ",(0,o.mdx)("inlineCode",{parentName:"p"},"str.__add__"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"str.__mod__"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"str.format")," or constructing f-strings)."),(0,o.mdx)("p",null,"For example, to detect flows from source ",(0,o.mdx)("inlineCode",{parentName:"p"},"UserControlled")," to sink ",(0,o.mdx)("inlineCode",{parentName:"p"},"StringMayBeSQL"),", one should specify the following contents in the taint configuration file, where ",(0,o.mdx)("inlineCode",{parentName:"p"},"UserControlled")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"StringMayBeSQL")," are both declared as sources:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    { "name": "UserControlled" },\n    { "name": "StringMayBeSQL" }\n  ],\n  "implicit_sources": {\n    "literal_strings": [\n      {\n        "regexp": "SELECT.*",\n        "kind": "StringMayBeSQL",\n        "comment": "matches a SQL statement"\n      }\n    ]\n  },\n  "string_combine_rules": [\n    {\n       "name": "User controlled data flows into potential SQL strings",\n       "rule": [\n        {\n           "sources": [ "UserControlled" ],\n           "partial_sink": "UserControlledDataSink"\n         },\n         {\n           "sources": [ "StringMayBeSQL" ],\n           "partial_sink": "StringMayBeSQLSink"\n         }\n       ],\n       "code": 4324,\n       "message_format": "User controlled data flows into potential SQL strings"\n    }\n  ]\n}\n')),(0,o.mdx)("p",null,"As shown above, the syntax is similar to that of ",(0,o.mdx)("a",{parentName:"p",href:"#combined-source-rules"},"combined source rules"),", especially for section ",(0,o.mdx)("inlineCode",{parentName:"p"},"rule"),"."),(0,o.mdx)("p",null,"The above rule enables catching the following flows:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def issue():\n  uc = user_controlled()\n  f"SELECT {uc} FROM async_query"\n  "SELECT " + uc + " FROM async_query"\n  "SELECT %s FROM async_query" % uc\n  "SELECT {} FROM async_query".format(uc)\n')),(0,o.mdx)("p",null,"Note that the string combine rules are strictly more powerful than the feature of implicit literal string sinks.\nThat is, any flow that can be detected via implicit literal string sinks can also be detected via string combine rules, but not vice versa.\nHence, we recommend using the string combine rules."),(0,o.mdx)("h2",{id:"prevent-inferring-models-with-skipanalysis"},"Prevent Inferring Models with ",(0,o.mdx)("inlineCode",{parentName:"h2"},"SkipAnalysis")),(0,o.mdx)("p",null,"In addition to the models defined in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files, Pysa will infer models for\nfunctions based what sources, sinks, etc. they call in their body. The\n",(0,o.mdx)("inlineCode",{parentName:"p"},"SkipAnalysis")," annotation can be used to prevent Pysa from inferring models, and\ninstead force it to use only the user defined models for determining taint flow:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipAnalysis\ndef qualifier.dont_generate_models(argument): ...\n")),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"SkipAnalysis")," can be applied at the class level as a shorthand to prevent pysa\nfrom infering models for all functions in a class:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class skip_analysis.SkipMe(SkipAnalysis): ...\n")),(0,o.mdx)("h2",{id:"ignoring-overrides"},"Ignoring overrides"),(0,o.mdx)("p",null,"When a method is called on a base class, Pysa has to assume that that call could\nactually invoke any subclass methods that override the base class's method. For\nheavily overriden methods, this can lead to both performance impacts and false\npositives. When running Pysa, you may see messages such as this in the output:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"2020-09-02 09:25:50,677 WARNING `object.__init__` has 106 overrides, this might slow down the analysis considerably.\n")),(0,o.mdx)("p",null,"The above message indicates that 106 subclasses of ",(0,o.mdx)("inlineCode",{parentName:"p"},"object")," have overridden\n",(0,o.mdx)("inlineCode",{parentName:"p"},"__init__"),". If Pysa sees taint flowing into ",(0,o.mdx)("inlineCode",{parentName:"p"},"object.__init__"),", then it will\ntreat all 106 overrides of ",(0,o.mdx)("inlineCode",{parentName:"p"},"object.__init__")," as also receiving that taint."),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"@SkipOverrides")," decorator can be applied to deal with false positives or\nperformance issues from having too many overrides on a given function:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipOverrides\ndef object.__init__(self): ...\n")),(0,o.mdx)("p",null,"This annotation will cause Pysa not to propagate taint into to and from\noverridden methods on subclasses, when analyzing functions that call the\noverriden method on the base class."),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"maximum_overrides_to_analyze")," can be added the the ",(0,o.mdx)("inlineCode",{parentName:"p"},"options")," block of\n",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," to limit the number of overrides that Pysa will analyze:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_overrides_to_analyze": 60\n  }\n}\n')),(0,o.mdx)("p",null,"This option can also be provided in the command line, using\n",(0,o.mdx)("inlineCode",{parentName:"p"},"--maximum-overrides-to-analyze"),"."),(0,o.mdx)("p",null,"This can speed up the analysis, but it will lead to false negatives, because\nPysa will only propagate taint to or from 60 (in the case of the above example)\noverriden methods on subclasses. The remaining overriding methods will be\nignored and treated as if they weren't actually overriding the base class\nmethod."),(0,o.mdx)("p",null,"By default, Pysa skips overrides on some functions that are typically\nproblematic. You can find the full list of default-skipped functions in\n",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/pyre-check/blob/main/stubs/taint/common/skipped_overrides.pysa"},(0,o.mdx)("inlineCode",{parentName:"a"},"stubs/taint/common/skipped_overrides.pysa"))),(0,o.mdx)("h2",{id:"force-to-analyze-all-overrides"},"Force to analyze all overrides"),(0,o.mdx)("p",null,"We also allow the use of decorator ",(0,o.mdx)("inlineCode",{parentName:"p"},"@AnalyzeAllOverrides")," to force analyzing all overriding methods of a given method, regardless of the configured maximum number of overrides to analyze (e.g., via command line option ",(0,o.mdx)("inlineCode",{parentName:"p"},"--maximum-overrides-to-analyze"),"), or if there simultaneously exists an ",(0,o.mdx)("inlineCode",{parentName:"p"},"@SkipOverrides")," on the given method. An example is:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@AnalyzeAllOverrides\ndef BaseClass.method(self): ...\n")),(0,o.mdx)("p",null,"Decorator ",(0,o.mdx)("inlineCode",{parentName:"p"},"@AnalyzeAllOverrides")," is often used to reduce false negatives, by analyzing all overrides of some selected methods. This offers a more fine-grained option than tweaking ",(0,o.mdx)("inlineCode",{parentName:"p"},"--maximum-overrides-to-analyze")," for all methods. Adding decorator ",(0,o.mdx)("inlineCode",{parentName:"p"},"@AnalyzeAllOverrides")," to some selected methods is faster than using a large threshold of maximum overrides for all methods, but achieves better precision than using a small threshold."),(0,o.mdx)("h2",{id:"force-to-treat-a-callable-as-being-called-when-passed-as-parameters"},"Force to treat a callable as being called when passed as parameters"),(0,o.mdx)("p",null,"We allow the usage of decorator ",(0,o.mdx)("inlineCode",{parentName:"p"},"@CalledWhenParameter")," to force treating the callable as being called, when the callable is passed as a parameter. An example is:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@CalledWhenParameter\ndef foo(): ...\ndef bar(f):\n  f()\ndef main():\n  bar(foo) # We would treat `foo` as being called here.\n")),(0,o.mdx)("p",null,"This is useful for reducing false negatives. By default, the higher order call graph building would always create a parameterized callable ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar[f=foo]")," (i.e., a version of ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar")," where ",(0,o.mdx)("inlineCode",{parentName:"p"},"f")," is instantiated as ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo"),") at the call site in ",(0,o.mdx)("inlineCode",{parentName:"p"},"main"),". Hence, ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo")," would no longer get called if the higher order call graph building is limited in knowing that ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo")," is eventually called in ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar"),". This may lead to false negatives."),(0,o.mdx)("h2",{id:"limit-the-trace-length-for-better-signal-and-performance"},"Limit the trace length for better signal and performance"),(0,o.mdx)("p",null,"By default, Pysa will find all flows from sources to sinks matching a rule.\nThis can lead to very long traces which are hard to understand and tend to be\nfalse positives. This also brings down the performance a lot."),(0,o.mdx)("p",null,"Pysa provides a ",(0,o.mdx)("inlineCode",{parentName:"p"},"--maximum-trace-length <integer>")," command line argument which\nlimits the length of traces that it finds. In general, this will also make Pysa\nfaster."),(0,o.mdx)("p",null,"This option can also be added in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," as follows:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_trace_length": 20\n  }\n}\n')),(0,o.mdx)("p",null,"Note that this is not a silver bullet and that this might hide security\nvulnerabilities. Use it with caution."),(0,o.mdx)("h2",{id:"limit-the-trace-length-for-a-given-rule"},"Limit the trace length for a given rule"),(0,o.mdx)("p",null,"Similarly to the option described above, one can limit the trace length\nfor a given rule, using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"filters")," option:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},'"rules": [\n  {\n    "name": "SQL injection.",\n    "code": 1,\n    "sources": [ "UserControlled" ],\n    "sinks": [ "SQL" ],\n    "message_format": "Data from [{$sources}] source(s) may reach [{$sinks}] sink(s)",\n    "filters": {\n      "maximum_source_distance": 10,\n      "maximum_sink_distance": 5\n    }\n  }\n]\n')),(0,o.mdx)("p",null,"This will limit the trace length from the root to the source by 10, and the\ntrace length from the root to the sink by 5, only for that specific rule."),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Note"),": This is meant to be used to limit the number of issues written to the\ndatabase. Prefer using ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/sapp#readme"},"SAPP")," to\nfilter out false positives."),(0,o.mdx)("h2",{id:"limit-the-tito-depth-for-better-signal-and-performance"},"Limit the tito depth for better signal and performance"),(0,o.mdx)("p",null,'Pysa automatically infers when a function propagate the taint from one argument\nto its return value. This is called tito, for "Taint In Taint Out". In practice,\ninfering it can be very expensive since the taint can go through an arbitrary\nnumber of hops (i.e, depth).'),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(x):\n  return x\ndef bar(x):\n  return foo(x)\ndef baz(x):\n  return bar(x)\n")),(0,o.mdx)("p",null,"In this example, ",(0,o.mdx)("inlineCode",{parentName:"p"},"baz")," propagates the taint on its argument to the return value\nusing 3 hops."),(0,o.mdx)("p",null,"Pysa provides a ",(0,o.mdx)("inlineCode",{parentName:"p"},"--maximum-tito-depth <integer>")," command line argument which\nlimints the depth of inferred propagations. In combination with the trace length\nlimit, this usually makes Pysa faster."),(0,o.mdx)("p",null,"This option can also be added in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," as follows:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_tito_depth": 20\n  }\n}\n')),(0,o.mdx)("h2",{id:"decorators"},"Decorators"),(0,o.mdx)("p",null,"By default, Pysa does not generally understand decorators, and will treat a call to a decorated function as an obscure call."),(0,o.mdx)("p",null,"This will usually lead to false negatives if the decorated functions has sources or sinks. For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def identity(f: Callable[[str], None]) -> Callable[[str], None]:\n  return f\n\n@identity\ndef decorated_sink(x: str) -> None:\n  sink(x)\n\ndecorated_sink(source()) # False negative, issue will NOT be found!\n")),(0,o.mdx)("p",null,"This also leads to false negatives if the decorator adds a flow to a sink. For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def with_sink(f: Callable[[str], None]) -> Callable[[str], None]:\n  def inner(x: str) -> None:\n    sink(x)\n    f(x)\n\n  return inner\n\n@with_sink\ndef foo(x: str) -> None:\n  print(x)\n\nfoo(source()) # False negative, issue will NOT be found!\n")),(0,o.mdx)("p",null,"Since the call to a decorated function is treated as an obscure call, it will conservatively propagate taint through decorated function:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def identity(f: Callable[[str], str]) -> Callable[[str], str]:\n  return f\n\n@identity\ndef decorated(x: str) -> str:\n  # Whatever happens here will not be considered at the call site.\n  return 'hello %s' % x\n\nsink(decorated(source())) # Issue is properly found.\n")),(0,o.mdx)("p",null,"Pysa provides a few ways to deal with these limitations."),(0,o.mdx)("h2",{id:"ignoring-decorators"},"Ignoring decorators"),(0,o.mdx)("p",null,"Pysa can entirely ignore a decorator, as if it was not present in the source code. This can be done safely when the decorator does not change the signature of the decorated function (i.e, it does not add or remove parameters)."),(0,o.mdx)("p",null,"To ignore a decorator, use the ",(0,o.mdx)("inlineCode",{parentName:"p"},"@IgnoreDecorator")," annotation in a ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@IgnoreDecorator\ndef module.decorator(): ...\n")),(0,o.mdx)("h2",{id:"inlining-decorators"},"Inlining decorators"),(0,o.mdx)("p",null,"Pysa can try to inline decorators into decorated functions before analyzing them. This can be enabled with the ",(0,o.mdx)("inlineCode",{parentName:"p"},"--inline-decorators")," flag."),(0,o.mdx)("p",null,"Inlining will take the code of the decorator and copy it within the decorated function. For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def my_decorator(f: Callable[[int], int]) -> Callable[[int], int]:\n  def inner(x: int) -> int:\n    before(x)\n    result = f(x)\n    after(x)\n    return result\n\n  return inner\n\n@my_decorator\ndef decorated(x: int) -> int:\n  return x + 1\n")),(0,o.mdx)("p",null,"Will be inlined as:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"def decorated(x: int) -> int:\n  before(x)\n  result = x + 1\n  after(x)\n  return result\n")),(0,o.mdx)("h3",{id:"prevent-inlining-decorators-with-skipdecoratorwheninlining"},"Prevent Inlining Decorators with ",(0,o.mdx)("inlineCode",{parentName:"h3"},"SkipDecoratorWhenInlining")),(0,o.mdx)("p",null,"Decorator inlining comes at the cost of increasing the analysis time and also increasing the lengths of traces. If you would like to prevent certain decorators from being inlined, you can mark them in your ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file using ",(0,o.mdx)("inlineCode",{parentName:"p"},"@SkipDecoratorWhenInlining"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# foo.pysa\n@SkipDecoratorWhenInlining\ndef foo.decorator_to_be_skipped(f): ...\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# foo.py\n@decorator_to_be_skipped\ndef bar(x: int) -> None:\n  pass\n")),(0,o.mdx)("p",null,"This will prevent the decorator from being inlined when analyzing ",(0,o.mdx)("inlineCode",{parentName:"p"},"bar"),". Note that we use ",(0,o.mdx)("inlineCode",{parentName:"p"},"@SkipDecoratorWhenInlining")," on the decorator that is to be skipped, not the function on which the decorator is applied."),(0,o.mdx)("p",null,"Unfortunately, this will lead back to false negatives as described earlier."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@decorator_to_be_skipped\ndef bar(x: int) -> None:\n  sink(x)\n\nbar(source()) # False negative, issue will NOT be found!\n")),(0,o.mdx)("h2",{id:"single-trace-sanitizers-with-sanitizesingletrace"},"Single trace sanitizers with ",(0,o.mdx)("inlineCode",{parentName:"h2"},"@SanitizeSingleTrace")),(0,o.mdx)("p",null,"Sanitizers, as described in the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/pysa-basics"},"Overview"),", are applied in both\nthe forward (i.e source) trace and backward (i.e sink) trace."),(0,o.mdx)("p",null,"For instance, with the given ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@Sanitize(TaintInTaintOut[TaintSink[RemoteCodeExecution]])\ndef shlex.quote(x): ...\n")),(0,o.mdx)("p",null,"And the following Python code:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"import subprocess\nfrom shlex import quote\n\ndef quoted_input():\n  x = input() # source 'UserControlled'\n  y = quote(x)\n  return y\n\ndef echo(argument):\n  subprocess.run(f'/bin/echo {argument}', shell=True) # sink 'RemoteCodeExecution'\n\ndef issue():\n  x = quoted_input() # source trace: input -> quoted_input -> issue\n  echo(x) # sink trace: issue -> echo -> subprocess.run\n")),(0,o.mdx)("p",null,"Pysa will NOT find an issue here, as expected.\nThis is because during the propagation of the 'UserControlled' source in the\nforward trace, pysa remembers that it was sanitized for the sink 'RemoteCodeExecution'."),(0,o.mdx)("p",null,"However, Pysa provides a simpler version of sanitizers, which only sanitizes in the\nforward trace or the backward trace:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@SanitizeSingleTrace(TaintSource)\ndef f(): ...\n\n@SanitizeSingleTrace(TaintSource[UserControlled])\ndef g(): ...\n\n@SanitizeSingleTrace(TaintSink)\ndef h(): ...\n\n@SanitizeSingleTrace(TaintSink[RemoteCodeExecution])\ndef i(): ...\n")),(0,o.mdx)("p",null,"These sanitizers are a lot cheaper and could save analysis time. However, these\nmight introduce false positives, so we recommend to use the default sanitizers."),(0,o.mdx)("h2",{id:"filtering-the-call-graph-with-entrypoint"},"Filtering the call graph with ",(0,o.mdx)("inlineCode",{parentName:"h2"},"@Entrypoint")),(0,o.mdx)("p",null,"By default, Pysa will analyze the entire call graph of your program. This can lead to longer analysis times for larger programs, especially when you'd only like to perform analysis on specific parts of the program. This decorator will mark a specified function and the functions it calls as the only functions to be analyzed."),(0,o.mdx)("p",null,"Note: the flag ",(0,o.mdx)("inlineCode",{parentName:"p"},"--limit-entrypoints")," must be passed to ",(0,o.mdx)("inlineCode",{parentName:"p"},"pyre analyze")," for call graph filtering to occur, even if the ",(0,o.mdx)("inlineCode",{parentName:"p"},"@Entrypoint")," decorator is present. This allows for call graph filtering to be easily enabled or disabled without editing your ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files."),(0,o.mdx)("p",null,"If you have the following Python file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"class MyClass:\n  def class_entrypoint():\n    taint_sink(taint_source())\n\ndef my_bad_func_1():\n  taint_sink(taint_source())\n\ndef my_bad_func_2():\n  taint_sink(taint_source())\n\ndef func_entrypoint():\n  my_bad_func_1()\n\ndef main():\n  func_entrypoint()\n  my_bad_func_2()\n  MyClass().class_entrypoint()\n\nmain()\n")),(0,o.mdx)("p",null,"And the following ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@Entrypoint\ndef my_file.MyClass.class_entrypoint(): ...\n\n@Entrypoint\ndef func_entrypoint(): ...\n")),(0,o.mdx)("p",null,"Then issues will be found for taint in calls to ",(0,o.mdx)("inlineCode",{parentName:"p"},"class_entrypoint")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"my_bad_func_1"),", but not ",(0,o.mdx)("inlineCode",{parentName:"p"},"my_bad_func_2"),", since it isn't called by a function marked by an ",(0,o.mdx)("inlineCode",{parentName:"p"},"@Entrypoint"),"."),(0,o.mdx)("h2",{id:"taint-in-taint-out-transforms"},"Taint In Taint Out Transforms"),(0,o.mdx)("p",null,"Taint in taint out transforms can be used to capture more precise flows."),(0,o.mdx)("p",null,"As an example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def read_file(path):\n  with open(path, "r") as f:\n    content = f.read()\n  return content\n')),(0,o.mdx)("p",null,"Without taint in taint transforms we can write a rule that captures a ",(0,o.mdx)("inlineCode",{parentName:"p"},"UserControlled")," path is ",(0,o.mdx)("inlineCode",{parentName:"p"},"read"),". Such a rule can be made much higher signal if we can detect that ",(0,o.mdx)("inlineCode",{parentName:"p"},"content")," is also ",(0,o.mdx)("inlineCode",{parentName:"p"},"ReturnedToUser"),". We can use taint in taint out transforms to stitch the two flows together. We mark ",(0,o.mdx)("inlineCode",{parentName:"p"},"read")," with a taint in taint out transform ",(0,o.mdx)("inlineCode",{parentName:"p"},"FileRead"),", and the rule becomes ",(0,o.mdx)("inlineCode",{parentName:"p"},"UserControlled -> FileRead -> ReturnedToUser"),"."),(0,o.mdx)("p",null,"To contrast with feature annotations, there are two differences:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The filtering is done during analysis itself, and limits the issues generated (as opposed to a post-processing step by the user)"),(0,o.mdx)("li",{parentName:"ul"},"Taint in taint out transforms can be used to reason about the order of events")),(0,o.mdx)("h3",{id:"syntax"},"Syntax"),(0,o.mdx)("p",null,"In ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config"),", one can specify ",(0,o.mdx)("inlineCode",{parentName:"p"},"transforms")," to define new transforms. Each transform is defined by following fields:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"name"),": name of the transform, this is used when defining rules, as well as writing models"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"comment"),": description of the transform")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},'{\n  ...\n  "transforms": [\n    {\n      "name": "MyTransform",\n      "comment": "This is my transform"\n    },\n    ...\n  ],\n  ...\n}\n')),(0,o.mdx)("p",null,"Then, one may use these transforms in ",(0,o.mdx)("inlineCode",{parentName:"p"},"rules")," as follows:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},' {\n  ...\n  "rules": [\n    {\n      "name": ...,\n      "code": ...,\n      "sources": ["SourceA"],\n      "transforms": ["MyTransform1", "MyTransform2"],\n      "sinks": ["SinkB"],\n      "message_format": "[{$sources}] transformed by [${transforms}] may reach [${sinks}]"\n    },\n    ...\n  ],\n  ...\n}\n')),(0,o.mdx)("p",null,"Intuitively, one can think of the rule above as ",(0,o.mdx)("inlineCode",{parentName:"p"},"SourceA -> MyTransform1 -> MyTransform2 -> SinkB"),". The order is important."),(0,o.mdx)("p",null,"Finally, in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," model files a taint transform can be specified using a ",(0,o.mdx)("inlineCode",{parentName:"p"},"TaintInTaintOut[Transform[...]]")," annotation, where the parameter is the name of the transform."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"def my_function(arg: TaintInTaintOut[Transform[MyTransform]]): ...\n")),(0,o.mdx)("h3",{id:"semantics"},"Semantics"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"  y = my_function(x)\n")),(0,o.mdx)("p",null,"If ",(0,o.mdx)("inlineCode",{parentName:"p"},"x")," has source taint ",(0,o.mdx)("inlineCode",{parentName:"p"},"SourceA"),", the taint of ",(0,o.mdx)("inlineCode",{parentName:"p"},"y")," is ",(0,o.mdx)("inlineCode",{parentName:"p"},"MyTransform:SourceA"),". This will correspond to matching ",(0,o.mdx)("inlineCode",{parentName:"p"},"SourceA -> MyTransform")," in a rule. Likewise, if ",(0,o.mdx)("inlineCode",{parentName:"p"},"y")," has sink taint ",(0,o.mdx)("inlineCode",{parentName:"p"},"SinkB"),", then the taint of ",(0,o.mdx)("inlineCode",{parentName:"p"},"x")," is ",(0,o.mdx)("inlineCode",{parentName:"p"},"MyTransorm:SinkB"),". This will correspond to matching ",(0,o.mdx)("inlineCode",{parentName:"p"},"MyTransform -> SinkB")," in a rule."),(0,o.mdx)("p",null,"Note that a transform modifies the taint itself. Hence, if a flow passes through a transform, it will no longer match rules which do not contain the transform."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"RuleX: SourceA -> SinkB\nRuleY: SourceA -> MyTransform -> SinkB\nFlow1: SourceA -> SinkB\nFlow2: SourceA -> MyTransform -> SinkB\n")),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"Flow1")," matches ",(0,o.mdx)("inlineCode",{parentName:"p"},"RuleX")," but not ",(0,o.mdx)("inlineCode",{parentName:"p"},"RuleY"),". ",(0,o.mdx)("inlineCode",{parentName:"p"},"Flow2")," matches ",(0,o.mdx)("inlineCode",{parentName:"p"},"RuleY")," but not ",(0,o.mdx)("inlineCode",{parentName:"p"},"RuleX"),"."),(0,o.mdx)("p",null,"Consider the scenario where we have an additional rule:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"RuleZ: SourceC -> SinkD\n")),(0,o.mdx)("p",null,"If transform ",(0,o.mdx)("inlineCode",{parentName:"p"},"MyTransform")," is applied to taint ",(0,o.mdx)("inlineCode",{parentName:"p"},"SourceC"),", there is no possible rule it can possibly match. As an optimization, we check for this continuously in our analysis and filter out eagerly."),(0,o.mdx)("p",null,"Also note that the existing TaintInTaintOut annotation semantics of TITO being assumed (instead of inferred) on the argument are unchanged."),(0,o.mdx)("h2",{id:"analysis-thresholds"},"Analysis thresholds"),(0,o.mdx)("p",null,"Pysa provides many options to fine tune the taint analysis. The following\noptions can be provided either via the command line or in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," file,\nunder the ",(0,o.mdx)("inlineCode",{parentName:"p"},"options")," section."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_model_source_tree_width": 10,\n    "maximum_model_sink_tree_width": 10,\n    "maximum_model_tito_tree_width": 10\n  }\n}\n')),(0,o.mdx)("p",null,"When not provided, these are set to the following defaults:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ocaml",metastring:"file=source/interprocedural_analyses/taint/taintConfiguration.ml start=DOCUMENTATION_CONFIGURATION_START end=DOCUMENTATION_CONFIGURATION_END",file:"source/interprocedural_analyses/taint/taintConfiguration.ml",start:"DOCUMENTATION_CONFIGURATION_START",end:"DOCUMENTATION_CONFIGURATION_END"},"maximum_model_source_tree_width = 25;\nmaximum_model_sink_tree_width = 25;\nmaximum_model_tito_tree_width = 5;\nmaximum_tree_depth_after_widening = 4;\nmaximum_return_access_path_width = 10;\nmaximum_return_access_path_depth_after_widening = 4;\nmaximum_tito_collapse_depth = 4;\nmaximum_tito_positions = 50;\n")),(0,o.mdx)("h3",{id:"maximum-model-source-tree-width"},"Maximum model source tree width"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Command line option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"--maximum-model-source-tree-width")),(0,o.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"maximum_model_source_tree_width"))),(0,o.mdx)("p",null,"See ",(0,o.mdx)("a",{parentName:"p",href:"#taint-broadening"},"taint broadening")," and ",(0,o.mdx)("a",{parentName:"p",href:"#model-broadening"},"model broadening"),"."),(0,o.mdx)("p",null,"This limits the width of the source tree in the model for a callable, i.e\nthe number of output paths in the return value."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo():\n  return {"a": source(), "b": source(), "c": source()}\n')),(0,o.mdx)("p",null,"The source tree for ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo")," has a width of 3. Above the provided threshold, pysa\nwill collapse the taint and consider the whole dictionary tainted. When that\nhappens, the breadcrumbs ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-broadening")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-source-broadening")," will\nbe added to the flow."),(0,o.mdx)("h3",{id:"maximum-model-sink-tree-width"},"Maximum model sink tree width"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Command line option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"--maximum-model-sink-tree-width")),(0,o.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"maximum_model_sink_tree_width"))),(0,o.mdx)("p",null,"See ",(0,o.mdx)("a",{parentName:"p",href:"#taint-broadening"},"taint broadening")," and ",(0,o.mdx)("a",{parentName:"p",href:"#model-broadening"},"model broadening"),"."),(0,o.mdx)("p",null,"This limits the width of the sink tree in the model for a callable, i.e\nthe number of input paths leading to a sink for a given parameter."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  sink(arg[1])\n  sink(arg[2])\n  sink(arg[3])\n")),(0,o.mdx)("p",null,"The sink tree for ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo")," and parameter ",(0,o.mdx)("inlineCode",{parentName:"p"},"arg")," has a width of 3.\nAbove the provided threshold, pysa will collapse the taint and consider that the\nwhole argument leads to a sink. When that happens, the breadcrumbs\n",(0,o.mdx)("inlineCode",{parentName:"p"},"model-broadening")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-sink-broadening")," will be added to the flow."),(0,o.mdx)("h3",{id:"maximum-model-tito-tree-width"},"Maximum model tito tree width"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Command line option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"--maximum-model-tito-tree-width")),(0,o.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"maximum_model_tito_tree_width"))),(0,o.mdx)("p",null,"See ",(0,o.mdx)("a",{parentName:"p",href:"#taint-broadening"},"taint broadening")," and ",(0,o.mdx)("a",{parentName:"p",href:"#model-broadening"},"model broadening"),"."),(0,o.mdx)("p",null,"This limits the width of the taint-in-taint-out tree in the model for a callable,\ni.e the number of input paths propagated to the return value, for a given parameter."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  return '%s:%s:%s' % (arg.a, arg.b, arg.c)\n")),(0,o.mdx)("p",null,"The taint-in-taint-out tree for ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo")," and parameter ",(0,o.mdx)("inlineCode",{parentName:"p"},"arg")," has a width of 3.\nAbove the provided threshold, pysa will collapse the taint and consider that the\ntaint on the whole argument is propagated to the return value. When that happens,\nthe breadcrumbs ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-broadening")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-tito-broadening")," will be added to\nthe flow."),(0,o.mdx)("h3",{id:"maximum-tree-depth-after-widening"},"Maximum tree depth after widening"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Command line option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"--maximum-tree-depth-after-widening")),(0,o.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"maximum_tree_depth_after_widening"))),(0,o.mdx)("p",null,"See ",(0,o.mdx)("a",{parentName:"p",href:"#taint-broadening"},"taint broadening")," and ",(0,o.mdx)("a",{parentName:"p",href:"#widen-broadening"},"widen broadening"),"."),(0,o.mdx)("p",null,"This limits the depth of the source, sink and tito trees within loops, i.e the\nlength of source, sink and tito paths for each variables."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo():\n  variable = MyClass()\n  for x in generate():\n    variable.a.b.c = source()\n  return result\n")),(0,o.mdx)("p",null,"The source tree for ",(0,o.mdx)("inlineCode",{parentName:"p"},"variable")," has a depth of 3 (i.e, ",(0,o.mdx)("inlineCode",{parentName:"p"},"a")," -> ",(0,o.mdx)("inlineCode",{parentName:"p"},"b")," -> ",(0,o.mdx)("inlineCode",{parentName:"p"},"c"),").\nWithin a loop, pysa limits the depth to the provided threshold. For instance,\nif that threshold is 1, we would consider that ",(0,o.mdx)("inlineCode",{parentName:"p"},"variable.a")," is entirely tainted.\nWhen that happens, the breadcrumb ",(0,o.mdx)("inlineCode",{parentName:"p"},"widen-broadening")," will be added to the flow."),(0,o.mdx)("h3",{id:"maximum-return-access-path-width"},"Maximum return access path width"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Command line option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"--maximum-return-access-path-width")),(0,o.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"maximum_return_access_path_width"))),(0,o.mdx)("p",null,"See ",(0,o.mdx)("a",{parentName:"p",href:"#taint-broadening"},"taint broadening")," and ",(0,o.mdx)("a",{parentName:"p",href:"#model-broadening"},"model broadening"),"."),(0,o.mdx)("p",null,"This limits the width of the return access path tree in the model for a callable,\ni.e the number of output paths propagated to the return value, for a given parameter."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  return {'a': arg, 'b': arg, 'c': arg}\n")),(0,o.mdx)("p",null,"The return access path tree for ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo")," and parameter ",(0,o.mdx)("inlineCode",{parentName:"p"},"arg")," has a width of 3.\nAbove the provided threshold, pysa will collapse the taint and consider that the\nwhole return value is tainted whenever ",(0,o.mdx)("inlineCode",{parentName:"p"},"arg")," is tainted. When that happens,\nthe breadcrumbs ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-broadening")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-tito-broadering")," will be added to\nthe flow."),(0,o.mdx)("h3",{id:"maximum-return-access-path-depth-after-widening"},"Maximum return access path depth after widening"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Command line option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"--maximum-return-access-path-depth-after-widening")),(0,o.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"maximum_return_access_path_depth_after_widening"))),(0,o.mdx)("p",null,"See ",(0,o.mdx)("a",{parentName:"p",href:"#taint-broadening"},"taint broadening")," and ",(0,o.mdx)("a",{parentName:"p",href:"#widen-broadening"},"widen broadening"),"."),(0,o.mdx)("p",null,"This limits the depth of the return access path tree within loops, i.e the\nlength of output paths propagated to the return value, for a given parameter."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  result = MyClass()\n  for x in generate():\n    result.a.b.c = arg\n  return result\n")),(0,o.mdx)("p",null,"The return access path tree for ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo")," and parameter ",(0,o.mdx)("inlineCode",{parentName:"p"},"arg")," has a depth  of 3\n(i.e, ",(0,o.mdx)("inlineCode",{parentName:"p"},"a")," -> ",(0,o.mdx)("inlineCode",{parentName:"p"},"b")," -> ",(0,o.mdx)("inlineCode",{parentName:"p"},"c"),"). Within a loop, pysa limits the depth to the provided\nthreshold. For instance, if that threshold is 2, we would cut the output path\nto just ",(0,o.mdx)("inlineCode",{parentName:"p"},"a.b"),". When that happens, the breadcrumb ",(0,o.mdx)("inlineCode",{parentName:"p"},"model-broadening")," and\n",(0,o.mdx)("inlineCode",{parentName:"p"},"model-tito-broadening")," will be added to the flow."),(0,o.mdx)("h3",{id:"maximum-tito-collapse-depth"},"Maximum tito collapse depth"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Command line option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"--maximum-tito-collapse-depth")),(0,o.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"maximum_tito_collapse_depth"))),(0,o.mdx)("p",null,"This limits the depth of the taint tree after applying taint-in-taint-out,\ni.e the length of paths for taint propagated from a parameter to the return\nvalue."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def identity(arg): return arg\n\ndef foo():\n  input = {'a': {'b': {'c': source()}}}\n  output = identity(input)\n")),(0,o.mdx)("p",null,"The taint tree for ",(0,o.mdx)("inlineCode",{parentName:"p"},"input")," has a depth of 3 (i.e, ",(0,o.mdx)("inlineCode",{parentName:"p"},"a")," -> ",(0,o.mdx)("inlineCode",{parentName:"p"},"b")," -> ",(0,o.mdx)("inlineCode",{parentName:"p"},"c"),").\nWhen the taint is propagated to the return value of ",(0,o.mdx)("inlineCode",{parentName:"p"},"identity"),", we limit\nthe resulting taint tree to the given depth. For instance, if that threshold\nis 1, we would consider that ",(0,o.mdx)("inlineCode",{parentName:"p"},"output['a']")," is tainted."),(0,o.mdx)("p",null,"This is also applied for sinks in the backward analysis:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  output = identity(arg)\n  sink(output['a']['b']['c'])\n")),(0,o.mdx)("p",null,"With a threshold of 1, we would consider that ",(0,o.mdx)("inlineCode",{parentName:"p"},"output['a']")," leads to a sink."),(0,o.mdx)("h3",{id:"maximum-tito-positions"},"Maximum tito positions"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Command line option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"--maximum-tito-positions")),(0,o.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,o.mdx)("inlineCode",{parentName:"li"},"maximum_tito_positions"))),(0,o.mdx)("p",null,"This limits the number of positions to keep track of when propagating taint."),(0,o.mdx)("p",null,"When taint is propagated through a function and returned (i.e, taint-in-taint-out),\npysa will keep track of the position of the argument, and display it in the trace."),(0,o.mdx)("p",null,"For instance:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def foo():\n  x = source()\n  y = tito(x)\n           ^\n  z = {"a": y}\n            ^\n  sink(z)\n')),(0,o.mdx)("p",null,"In this example, we have 2 tito positions. Above the provided threshold,\npysa simply discards all positions. Note that the taint is still propagated."))}c.isMDXComponent=!0}}]);