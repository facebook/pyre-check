"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[415],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>d,MDXProvider:()=>u,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>m});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},r.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=a.createContext({}),m=function(e){return function(n){var t=p(n.components);return a.createElement(e,r({},n,{components:t}))}},p=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(d.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(t),u=i,h=m["".concat(o,".").concat(u)]||m[u]||c[u]||r;return t?a.createElement(h,l(l({ref:n},d),{},{components:t})):a.createElement(h,l({ref:n},d))}));function f(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},72560:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>d,toc:()=>p});var a=t(83117),i=t(80102),r=(t(67294),t(3905)),o=["components"],l={id:"pysa-advanced",title:"Advanced Topics",sidebar_label:"Advanced Topics"},s=void 0,d={unversionedId:"pysa-advanced",id:"pysa-advanced",title:"Advanced Topics",description:"This page documents less straightforward bits of Pysa.",source:"@site/docs/pysa_advanced.md",sourceDirName:".",slug:"/pysa-advanced",permalink:"/docs/pysa-advanced",draft:!1,editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/pysa_advanced.md",tags:[],version:"current",frontMatter:{id:"pysa-advanced",title:"Advanced Topics",sidebar_label:"Advanced Topics"},sidebar:"pysa",previous:{title:"Feature Annotations",permalink:"/docs/pysa-features"},next:{title:"Implementation Details",permalink:"/docs/pysa-implementation-details"}},m={},p=[{value:"Conditional models based on Python version",id:"conditional-models-based-on-python-version",level:2},{value:"Obscure models",id:"obscure-models",level:2},{value:"Parameter and return path",id:"parameter-and-return-path",level:2},{value:"Access path definition",id:"access-path-definition",level:3},{value:"Taint In Taint Out",id:"taint-in-taint-out",level:3},{value:"Collapsing on taint-in-taint-out",id:"collapsing-on-taint-in-taint-out",level:2},{value:"Tainting Specific <code>kwargs</code>",id:"tainting-specific-kwargs",level:2},{value:"Instance attributes versus class attributes",id:"instance-attributes-versus-class-attributes",level:2},{value:"Literal String Sources And Sinks",id:"literal-string-sources-and-sinks",level:2},{value:"Combined Source Rules",id:"combined-source-rules",level:2},{value:"String Combine Rules",id:"string-combine-rules",level:2},{value:"Prevent Inferring Models with <code>SkipAnalysis</code>",id:"prevent-inferring-models-with-skipanalysis",level:2},{value:"Ignoring overrides",id:"ignoring-overrides",level:2},{value:"Limit the trace length for better signal and performance",id:"limit-the-trace-length-for-better-signal-and-performance",level:2},{value:"Limit the tito depth for better signal and performance",id:"limit-the-tito-depth-for-better-signal-and-performance",level:2},{value:"Decorators",id:"decorators",level:2},{value:"Ignoring decorators",id:"ignoring-decorators",level:2},{value:"Inlining decorators",id:"inlining-decorators",level:2},{value:"Prevent Inlining Decorators with <code>SkipDecoratorWhenInlining</code>",id:"prevent-inlining-decorators-with-skipdecoratorwheninlining",level:3},{value:"Single trace sanitizers with <code>@SanitizeSingleTrace</code>",id:"single-trace-sanitizers-with-sanitizesingletrace",level:2},{value:"Filtering the call graph with <code>@Entrypoint</code>",id:"filtering-the-call-graph-with-entrypoint",level:2},{value:"Taint In Taint Out Transforms",id:"taint-in-taint-out-transforms",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Semantics",id:"semantics",level:3},{value:"Tune the taint tree width and depth",id:"tune-the-taint-tree-width-and-depth",level:2},{value:"Maximum model source tree width",id:"maximum-model-source-tree-width",level:3},{value:"Maximum model sink tree width",id:"maximum-model-sink-tree-width",level:3},{value:"Maximum model tito tree width",id:"maximum-model-tito-tree-width",level:3},{value:"Maximum tree depth after widening",id:"maximum-tree-depth-after-widening",level:3},{value:"Maximum return access path width",id:"maximum-return-access-path-width",level:3},{value:"Maximum return access path depth after widening",id:"maximum-return-access-path-depth-after-widening",level:3},{value:"Maximum tito collapse depth",id:"maximum-tito-collapse-depth",level:3},{value:"Maximum tito positions",id:"maximum-tito-positions",level:3}],u={toc:p};function c(e){var n=e.components,t=(0,i.Z)(e,o);return(0,r.mdx)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"This page documents less straightforward bits of Pysa."),(0,r.mdx)("h2",{id:"conditional-models-based-on-python-version"},"Conditional models based on Python version"),(0,r.mdx)("p",null,"Pysa models support if conditions but only for version comparisons for the python\nversion used to run pysa. This allows for conditional parsing of models and allows\ndifferent models to be used for different versions of python."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"if sys.version == (3,9,0):\n    def module.foo(): ...\nelse:\n    def module.bar(): ...\n")),(0,r.mdx)("p",null,'In this example, the first model will only be parsed and honoured if the python\nversion in the system or virtual environment from which Pysa is run is equal\nto "3.9.0". In all other conditions, the second model will be parsed and honoured.'),(0,r.mdx)("p",null,"sys.version is the only allowed left hand expression and the right hand expression\nhas to be a tuple of integers of the form (major, minor, micro). Only the major\nversion number is required and the other two are optional."),(0,r.mdx)("p",null,"The comparison operators supported include '==' (equal to), '!=' (not equal to),\n'","<","' (less than), '",">","' greater than, '","<","=' (less than or equal to), and\n'",">","=' (greater than or equal to)."),(0,r.mdx)("p",null,"If conditions can also be nested inside one another and follow the same behavior\nas python if conditions."),(0,r.mdx)("h2",{id:"obscure-models"},"Obscure models"),(0,r.mdx)("p",null,"When Pysa does not have enough information about a function or method, it will\nmake basic assumptions about its behavior. This is referred to as an ",(0,r.mdx)("strong",{parentName:"p"},"obscure\nmodel"),". Most notably, it assumes that the function or method propagates the\ntaint from its arguments to its return value."),(0,r.mdx)("p",null,"This usually happens when Pysa doesn't know about the callee of a function call:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(f: Any):\n    x = input()\n    y = f(x) # no information about `f`, y will be considered tainted.\n    eval(y)\n")),(0,r.mdx)("p",null,"Functions and methods defined in type stubs or in a different language (for\ninstance, in C or C++ binding) will also be treated as obscure models."),(0,r.mdx)("p",null,"To prevent a function or method to be marked as obscure, one can use the\n",(0,r.mdx)("inlineCode",{parentName:"p"},"@SkipObscure")," taint annotation in a ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipObscure\ndef module.foo(): ...\n")),(0,r.mdx)("h2",{id:"parameter-and-return-path"},"Parameter and return path"),(0,r.mdx)("p",null,"When writing a model for a source, the ",(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnPath")," annotation allows to specify\nwhich index or attribute of the returned value is tainted. For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def only_attribute_foo_tainted() -> TaintSource[Test, ReturnPath[_.foo]]: ...\n")),(0,r.mdx)("p",null,"Similarly, the ",(0,r.mdx)("inlineCode",{parentName:"p"},"ParameterPath")," annotation allows to specify which index or attribute\nof an argument leads to a sink. For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def only_arg_dot_bar_is_sink(arg: TaintSink[Test, ParameterPath[_.bar]]): ...\n")),(0,r.mdx)("h3",{id:"access-path-definition"},"Access path definition"),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"ParameterPath")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnPath")," annotation takes an ",(0,r.mdx)("strong",{parentName:"p"},"access path")," as an argument.\nAn access path starts with an underscore ",(0,r.mdx)("inlineCode",{parentName:"p"},"_")," which represents the whole argument or\nreturn value (depending on the context). The underscore can be followed by attribute\naccesses (e.g, ",(0,r.mdx)("inlineCode",{parentName:"p"},"_.foo.bar"),") and index accesses (e.g, ",(0,r.mdx)("inlineCode",{parentName:"p"},'_["foo"][0]["bar"]'),"), or a\ncombination of both (e.g, ",(0,r.mdx)("inlineCode",{parentName:"p"},"_.foo[0]"),")."),(0,r.mdx)("p",null,"In addition to these, two special calls can be used: ",(0,r.mdx)("inlineCode",{parentName:"p"},".all()")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},".keys()"),"."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},".all()")," is used to represent that any index might be tainted. This is usually when\nthe index cannot be known statically. For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(i: int):\n  i = random.randint(0, 100)\n  return {i: source()}\n")),(0,r.mdx)("p",null,"This can be represented by the model:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(): TaintSource[Test, ReturnPath[_.all()]]: ...\n")),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},".keys()")," is used to represent that any key of the dictionary might be tainted.\nFor instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo():\n  return {source(): 0}\n")),(0,r.mdx)("p",null,"This can be represented by the model:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(): TaintSource[Test, ReturnPath[_.keys()]]: ...\n")),(0,r.mdx)("h3",{id:"taint-in-taint-out"},"Taint In Taint Out"),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"ParameterPath")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnPath")," can also be used to give more information about\na propagation. For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def foo(arg):\n  return {"a": arg["b"][42]}\n')),(0,r.mdx)("p",null,"This can be represented by the model:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def foo(arg: TaintInTaintOut[ParameterPath[_["b"][42]], ReturnPath[_["a"]]]): ...\n')),(0,r.mdx)("p",null,"Note that Pysa will automatically infer propagations if it has access to the body\nof the function. Writing taint-in-taint-out models should rarely be required."),(0,r.mdx)("p",null,"When using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"Updates")," annotation, the annotation ",(0,r.mdx)("inlineCode",{parentName:"p"},"UpdatePath")," is used instead\nof ",(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnPath"),". For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def MyClass.updates_foo(self, x: TaintInTaintOut[Updates[self], UpdatePath[_.foo]]): ...\n")),(0,r.mdx)("h2",{id:"collapsing-on-taint-in-taint-out"},"Collapsing on taint-in-taint-out"),(0,r.mdx)("p",null,"Collapsing (also called taint broadening) is an over-approximation performed by\nthe taint analysis for correctness or performance reasons. After applying collapsing,\nPysa considers that a whole object or variable is tainted when only some attributes\nor keys were initially tainted."),(0,r.mdx)("p",null,"The most common causes for taint collapsing are:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Taint goes through an ",(0,r.mdx)("a",{parentName:"li",href:"#obscure-models"},"obscure model"),", when it does not have\nthe body of the callee; Pysa must assume anything could get tainted, for correctness."),(0,r.mdx)("li",{parentName:"ul"},"The number of tainted attributes or keys hits a ",(0,r.mdx)("a",{parentName:"li",href:"#tune-the-taint-tree-width-and-depth"},"threshold"),".\nTo prevent the analysis from blowing up by tracking too many values, Pysa assumes the whole object is tainted.")),(0,r.mdx)("p",null,"Whenever collapsing happens, Pysa will add the ",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-features#broadening-feature"},"broadening feature")," on\nthe taint flow, which can help discard false positives in post processing."),(0,r.mdx)("p",null,"When specifying a ",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-basics#taint-propagation"},"taint propagation")," in a ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file,\nthe propagation will collapse the taint by default. For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def tito(arg: TaintInTaintOut): ...\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo():\n  x = {\"a\": source()}\n  y = tito(x) # Only `x['a']` is tainted, but `y` gets tainted.\n  sink(y) # Issue since `y` is tainted\n  sink(y['b']) # Also an issue, because taint is propagated from `y` to `y['b']`.\n")),(0,r.mdx)("p",null,"If the function is known to preserve the structure of the argument, the ",(0,r.mdx)("inlineCode",{parentName:"p"},"NoCollapse"),"\nannotation can be used to disable collapsing. For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def tito(arg: TaintInTaintOut[NoCollapse]): ...\n")),(0,r.mdx)("p",null,"This would remove both issues from the previous example."),(0,r.mdx)("p",null,"Note that this can be used in combination with ",(0,r.mdx)("a",{parentName:"p",href:"#parameter-and-return-path"},(0,r.mdx)("inlineCode",{parentName:"a"},"ParameterPath")," and ",(0,r.mdx)("inlineCode",{parentName:"a"},"ReturnPath")),"."),(0,r.mdx)("h2",{id:"tainting-specific-kwargs"},"Tainting Specific ",(0,r.mdx)("inlineCode",{parentName:"h2"},"kwargs")),(0,r.mdx)("p",null,"Sometimes, a function can have potential sinks mixed together with benign\nparameters in the keyword arguments (",(0,r.mdx)("inlineCode",{parentName:"p"},"kwargs"),") that it accepts. In these cases,\ntainting the whole ",(0,r.mdx)("inlineCode",{parentName:"p"},"kwargs")," variable will result in false positives when tainted\ndata flows into a benign ",(0,r.mdx)("inlineCode",{parentName:"p"},"kwarg"),". Instead, for a function like this:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def eval_and_log(**kwargs):\n    eval(kwargs["eval"])\n    logging.debug(kwargs["log"])\n')),(0,r.mdx)("p",null,"We can lie a bit in our ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file, and break out the dangerous argument for\ntainting:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def eval_and_log(*, eval: TaintSink[RemoteCodeExecution], **kwargs): ...\n")),(0,r.mdx)("p",null,"This allows us to catch flows only into the ",(0,r.mdx)("inlineCode",{parentName:"p"},"eval")," keyword argument."),(0,r.mdx)("h2",{id:"instance-attributes-versus-class-attributes"},"Instance attributes versus class attributes"),(0,r.mdx)("p",null,"Models can specify sources and sinks on attributes, following the type annotation\nsyntax:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"django.http.request.HttpRequest.GET: TaintSource[UserControlled]\n")),(0,r.mdx)("p",null,"Any access to ",(0,r.mdx)("inlineCode",{parentName:"p"},"request.GET")," will be tainted when ",(0,r.mdx)("inlineCode",{parentName:"p"},"request")," is an instance of\n",(0,r.mdx)("inlineCode",{parentName:"p"},"HttpRequest")," or any of its children. However, note that the access to the class\nattribute (i.e, ",(0,r.mdx)("inlineCode",{parentName:"p"},"HttpRequest.GET"),") won't be considered tainted."),(0,r.mdx)("p",null,"To specify sources and sinks on class attributes, use the ",(0,r.mdx)("inlineCode",{parentName:"p"},"__class__")," prefix:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"django.http.request.HttpRequest.__class__.GET: TaintSource[UserControlled]\n")),(0,r.mdx)("p",null,"To specify a source on both the class attribute and instance attribute, simply\nuse both lines."),(0,r.mdx)("h2",{id:"literal-string-sources-and-sinks"},"Literal String Sources And Sinks"),(0,r.mdx)("p",null,"Some security vulnerabilities are best captured by modeling strings of a given\nform flowing to dangerous functions, or format strings that match a pattern getting\ntainted data passed in."),(0,r.mdx)("p",null,"To mark all literal strings matching a pattern as sources, you first need to add a\nregular expression corresponding to the pattern to your ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "name": "IPAddress"\n    }\n  ],\n  "implicit_sources": {\n     "literal_strings": [\n       {\n         "regexp": "\\\\d{1,3}(\\\\.\\\\d{1,3})+",\n         "kind": "IPAddress",\n         "description": "String that looks like an IP address."\n       }\n     ]\n  }\n}\n')),(0,r.mdx)("p",null,"With this regex in place, whenever Pysa sees a string such as ",(0,r.mdx)("inlineCode",{parentName:"p"},"123.456.789.123"),", it will flag it\nas a taint source with the kind ",(0,r.mdx)("inlineCode",{parentName:"p"},"IPAddress"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def test() -> None:\n    ip_address = "123.456.789.123"\n    dont_pass_an_ip_address(ip_address) # Pysa will now flag this.\n')),(0,r.mdx)("p",null,"The converse of supporting literal strings as sinks is also supported, for data flowing into a tainted string. The\nsyntax allows you to model data being used to format strings, like f-strings, manual string formatting, the string ",(0,r.mdx)("inlineCode",{parentName:"p"},"format()")," method, and printf-style string formatting with ",(0,r.mdx)("inlineCode",{parentName:"p"},"%"),"."),(0,r.mdx)("p",null,"Template strings and manual string formatting with more than two subexpressions are not yet supported."),(0,r.mdx)("p",null,"To add a literal sink, first add the literal_sink to your configuration"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sinks": [\n    { "name": "MayBeRendered" },\n    { "name": "MayBeSQL" }\n  ],\n  "implicit_sinks": {\n     "literal_strings": [\n       {\n         "regexp": "^<.*>$",\n         "kind": "MayBeRendered",\n         "description": "Indicates a string whose contents may be rendered."\n       },\n       {\n         "regexp": "^SELECT *.",\n         "kind": "MayBeSQL",\n         "description": "Indicates a string whose contents may be a SQL query."\n       }\n\n     ]\n  }\n')),(0,r.mdx)("p",null,"Now, Pysa will treat any values flowing into a each of the following as a regular sink:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def may_render(parameter: str) -> None:\n    result = f"<content={parameter}>"\n    result = "<content={}>".format(parameter)\n    result = "<content%s>" % (parameter,)\n')),(0,r.mdx)("p",null,"As well as values flowing into each of these as a regular sink:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def build_sql_query(columns: str) -> None:\n    result = f"SELECT {columns} FROM users;"\n    result = "SELECT {} FROM users;".format(columns)\n    result = "SELECT %s FROM users" % (columns,)\n    result = "SELECT " + columns + " FROM users;"\n')),(0,r.mdx)("p",null,"Note that string literal sinks have some limitations. For instance, they cannot catch issues if the string literal is stored in a temporary variable (e.g., ",(0,r.mdx)("inlineCode",{parentName:"p"},'x = "SELECT {}"; x.format(input)'),"). We recommend using string combine rules instead (see below)."),(0,r.mdx)("h2",{id:"combined-source-rules"},"Combined Source Rules"),(0,r.mdx)("p",null,"Some security vulnerabilities are better modeled as ",(0,r.mdx)("em",{parentName:"p"},"multiple")," sources reaching\na sink. For example, leaking credentials via ",(0,r.mdx)("inlineCode",{parentName:"p"},"requests.get")," could be modeled as\nuser controlled data flowing into the ",(0,r.mdx)("inlineCode",{parentName:"p"},"url")," parameter and credentials flowing\ninto the ",(0,r.mdx)("inlineCode",{parentName:"p"},"params")," parameter. These flows can be modeled by ",(0,r.mdx)("em",{parentName:"p"},"combined source\nrules"),"."),(0,r.mdx)("p",null,"Sources for combined source rules are declared as normal in ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config"),".\nSinks, however, need to be unique to the combined source rule and are declared inside\nthe rule definition. The rule itself is declared in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"combined_source_rules"),"\ntop level entry. The rule lists all the same things as a regular rule, but also ties\nlabels to its sources:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    { "name": "UserControlled" },\n    { "name": "Credentials" }\n  ],\n  "combined_source_rules": [\n    {\n       "name": "Credentials leaked through requests",\n       "sources": { "url": "UserControlled", "creds": "Credentials" },\n       "partial_sink": "UserControlledRequestWithCreds",\n       "code": 1,\n       "message_format": "Credentials leaked through requests",\n       "main_trace_source": "url",\n    }\n  ]\n}\n')),(0,r.mdx)("p",null,"Sources are declared as normal in ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," files. Instead of specifying sinks\nwith a ",(0,r.mdx)("inlineCode",{parentName:"p"},"TaintSink")," annotation, however, ",(0,r.mdx)("inlineCode",{parentName:"p"},"PartialSink")," annotations are used to\nspecify where each source needs to flow for the combined source rule. These\n",(0,r.mdx)("inlineCode",{parentName:"p"},"PartialSink")," must reference the labels that were declared in\n",(0,r.mdx)("inlineCode",{parentName:"p"},"multi_sink_labels"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def requests.api.get(\n  url: PartialSink[UserControlledRequestWithCreds[url]],\n  params: PartialSink[UserControlledRequestWithCreds[creds]],\n  **kwargs\n): ...\n")),(0,r.mdx)("p",null,"With the above configuration, Pysa can detect cases where ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," flows\ninto ",(0,r.mdx)("inlineCode",{parentName:"p"},"url")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"Credentials")," flow into ",(0,r.mdx)("inlineCode",{parentName:"p"},"params")," ",(0,r.mdx)("em",{parentName:"p"},"at the same time"),"."),(0,r.mdx)("p",null,"The optional attribute ",(0,r.mdx)("inlineCode",{parentName:"p"},"main_trace_source")," can be used to specify which flow should be shown as the main flow in the SAPP UI. For example, in the above rule, the flow from source ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," to sink ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlledRequestWithCreds")," is the main flow."),(0,r.mdx)("p",null,"The SAPP UI only shows a single flow at a time. However, an issue for a combined source rule corresponds to two flows. For example, for the above rule, an issue is filed only if there exist"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"One flow from source ",(0,r.mdx)("inlineCode",{parentName:"li"},"UserControlled")," to sink ",(0,r.mdx)("inlineCode",{parentName:"li"},"UserControlledRequestWithCreds"),", and"),(0,r.mdx)("li",{parentName:"ul"},"Another flow from source ",(0,r.mdx)("inlineCode",{parentName:"li"},"Credentials")," to sink ",(0,r.mdx)("inlineCode",{parentName:"li"},"UserControlledRequestWithCreds"),".")),(0,r.mdx)("p",null,"For combined source issues, Pysa will always show the main flow, and provide the secondary flow as a subtrace that can be expanded in the UI."),(0,r.mdx)("p",null,"When attribute ",(0,r.mdx)("inlineCode",{parentName:"p"},"main_trace_source")," is missing, Pysa treat the sources under the first tag as the main sources."),(0,r.mdx)("h2",{id:"string-combine-rules"},"String Combine Rules"),(0,r.mdx)("p",null,"It is sometimes useful to detect data tainted with a source (e.g., ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," data) that is incorporated into a suspicious looking string (e.g., a string that looks like a SQL query). Detecting such a pattern is useful, because it allows Pysa to detect dynamic creation of SQL queries which could lead to SQL injection, even if the code under analysis is using a SQL framework that Pysa does not have models for."),(0,r.mdx)("p",null,"To detect such flows, one can specify a variant of ",(0,r.mdx)("a",{parentName:"p",href:"#combined-source-rules"},"combined source rules"),", called string combine rules, to detect when the suspicious string (identified via regex match) and the other configured source both flow into string formatting call sites (such as calling ",(0,r.mdx)("inlineCode",{parentName:"p"},"str.__add__"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"str.__mod__"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"str.format")," or constructing f-strings)."),(0,r.mdx)("p",null,"For example, to detect flows from source ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," to sink ",(0,r.mdx)("inlineCode",{parentName:"p"},"StringMayBeSQL"),", one should specify the following contents in the taint configuration file, where ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," is declared as a main source and ",(0,r.mdx)("inlineCode",{parentName:"p"},"StringMayBeSQL")," is declared as a secondary source:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'{\n  "sources": [\n    { "name": "UserControlled" },\n    { "name": "StringMayBeSQL" }\n  ],\n  "implicit_sources": {\n    "literal_strings": [\n      {\n        "regexp": "SELECT.*",\n        "kind": "StringMayBeSQL",\n        "comment": "matches a SQL statement"\n      }\n    ]\n  },\n  "string_combine_rules": [\n    {\n       "name": "User controlled data flows into potential SQL strings",\n       "main_sources": "UserControlled",\n       "secondary_sources": "StringMayBeSQL",\n       "partial_sink": "UserControlledDataAndStringMayBeSQL",\n       "code": 4324,\n       "message_format": "User controlled data flows into potential SQL strings"\n    }\n  ]\n}\n')),(0,r.mdx)("p",null,"As shown above, one needs to additionally specify a (unique) partial sink kind (such as ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlledDataAndStringMayBeSQL"),"), which will be automatically introduced onto the actual arguments at string formatting call sites."),(0,r.mdx)("p",null,"The above rule enables catching the following flows:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def issue():\n  uc = user_controlled()\n  f"SELECT {uc} FROM async_query"\n  "SELECT " + uc + " FROM async_query"\n  "SELECT %s FROM async_query" % uc\n  "SELECT {} FROM async_query".format(uc)\n')),(0,r.mdx)("p",null,"Note that the string combine rules are strictly more powerful than the feature of implicit literal string sinks.\nThat is, any flow that can be detected via implicit literal string sinks can also be detected via string combine rules, but not vice versa.\nHence, we recommend using the string combine rules."),(0,r.mdx)("h2",{id:"prevent-inferring-models-with-skipanalysis"},"Prevent Inferring Models with ",(0,r.mdx)("inlineCode",{parentName:"h2"},"SkipAnalysis")),(0,r.mdx)("p",null,"In addition to the models defined in ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," files, Pysa will infer models for\nfunctions based what sources, sinks, etc. they call in their body. The\n",(0,r.mdx)("inlineCode",{parentName:"p"},"SkipAnalysis")," annotation can be used to prevent Pysa from inferring models, and\ninstead force it to use only the user defined models for determining taint flow:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipAnalysis\ndef qualifier.dont_generate_models(argument): ...\n")),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"SkipAnalysis")," can be applied at the class level as a shorthand to prevent pysa\nfrom infering models for all functions in a class:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"class skip_analysis.SkipMe(SkipAnalysis): ...\n")),(0,r.mdx)("h2",{id:"ignoring-overrides"},"Ignoring overrides"),(0,r.mdx)("p",null,"When a method is called on a base class, Pysa has to assume that that call could\nactually invoke any subclass methods that override the base class's method. For\nheavily overriden methods, this can lead to both performance impacts and false\npositives. When running Pysa, you may see messages such as this in the output:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"2020-09-02 09:25:50,677 WARNING `object.__init__` has 106 overrides, this might slow down the analysis considerably.\n")),(0,r.mdx)("p",null,"The above message indicates that 106 subclasses of ",(0,r.mdx)("inlineCode",{parentName:"p"},"object")," have overridden\n",(0,r.mdx)("inlineCode",{parentName:"p"},"__init__"),". If Pysa sees taint flowing into ",(0,r.mdx)("inlineCode",{parentName:"p"},"object.__init__"),", then it will\ntreat all 106 overrides of ",(0,r.mdx)("inlineCode",{parentName:"p"},"object.__init__")," as also receiving that taint."),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"@SkipOverrides")," decorator can be applied to deal with false positives or\nperformance issues from having too many overrides on a given function:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipOverrides\ndef object.__init__(self): ...\n")),(0,r.mdx)("p",null,"This annotation will cause Pysa not to propagate taint into to and from\noverridden methods on subclasses, when analyzing functions that call the\noverriden method on the base class."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"maximum_overrides_to_analyze")," can be added the the ",(0,r.mdx)("inlineCode",{parentName:"p"},"options")," block of\n",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config")," to limit the number of overrides that Pysa will analyze:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_overrides_to_analyze": 60\n  }\n}\n')),(0,r.mdx)("p",null,"This option can also be provided in the command line, using\n",(0,r.mdx)("inlineCode",{parentName:"p"},"--maximum-overrides-to-analyze"),"."),(0,r.mdx)("p",null,"This can speed up the analysis, but it will lead to false negatives, because\nPysa will only propagate taint to or from 60 (in the case of the above example)\noverriden methods on subclasses. The remaining overriding methods will be\nignored and treated as if they weren't actually overriding the base class\nmethod."),(0,r.mdx)("p",null,"By default, Pysa skips overrides on some functions that are typically\nproblematic. You can find the full list of default-skipped functions in\n",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/facebook/pyre-check/blob/main/stubs/taint/skipped_overrides.pysa"},(0,r.mdx)("inlineCode",{parentName:"a"},"stubs/taint/skipped_overrides.pysa"))),(0,r.mdx)("h2",{id:"limit-the-trace-length-for-better-signal-and-performance"},"Limit the trace length for better signal and performance"),(0,r.mdx)("p",null,"By default, Pysa will find all flows from sources to sinks matching a rule.\nThis can lead to very long traces which are hard to understand and tend to be\nfalse positives. This also brings down the performance a lot."),(0,r.mdx)("p",null,"Pysa provides a ",(0,r.mdx)("inlineCode",{parentName:"p"},"--maximum-trace-length <integer>")," command line argument which\nlimits the length of traces that it finds. In general, this will also make Pysa\nfaster."),(0,r.mdx)("p",null,"This option can also be added in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config")," as follows:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_trace_length": 20\n  }\n}\n')),(0,r.mdx)("p",null,"Note that this is not a silver bullet and that this might hide security\nvulnerabilities. Use it with caution."),(0,r.mdx)("h2",{id:"limit-the-tito-depth-for-better-signal-and-performance"},"Limit the tito depth for better signal and performance"),(0,r.mdx)("p",null,'Pysa automatically infers when a function propagate the taint from one argument\nto its return value. This is called tito, for "Taint In Taint Out". In practice,\ninfering it can be very expensive since the taint can go through an arbitrary\nnumber of hops (i.e, depth).'),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(x):\n  return x\ndef bar(x):\n  return foo(x)\ndef baz(x):\n  return bar(x)\n")),(0,r.mdx)("p",null,"In this example, ",(0,r.mdx)("inlineCode",{parentName:"p"},"baz")," propagates the taint on its argument to the return value\nusing 3 hops."),(0,r.mdx)("p",null,"Pysa provides a ",(0,r.mdx)("inlineCode",{parentName:"p"},"--maximum-tito-depth <integer>")," command line argument which\nlimints the depth of inferred propagations. In combination with the trace length\nlimit, this usually makes Pysa faster."),(0,r.mdx)("p",null,"This option can also be added in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config")," as follows:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_tito_depth": 20\n  }\n}\n')),(0,r.mdx)("h2",{id:"decorators"},"Decorators"),(0,r.mdx)("p",null,"By default, Pysa does not generally understand decorators, and will treat a call to a decorated function as an obscure call."),(0,r.mdx)("p",null,"This will usually lead to false negatives if the decorated functions has sources or sinks. For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def identity(f: Callable[[str], None]) -> Callable[[str], None]:\n  return f\n\n@identity\ndef decorated_sink(x: str) -> None:\n  sink(x)\n\ndecorated_sink(source()) # False negative, issue will NOT be found!\n")),(0,r.mdx)("p",null,"This also leads to false negatives if the decorator adds a flow to a sink. For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def with_sink(f: Callable[[str], None]) -> Callable[[str], None]:\n  def inner(x: str) -> None:\n    sink(x)\n    f(x)\n\n  return inner\n\n@with_sink\ndef foo(x: str) -> None:\n  print(x)\n\nfoo(source()) # False negative, issue will NOT be found!\n")),(0,r.mdx)("p",null,"Since the call to a decorated function is treated as an obscure call, it will conservatively propagate taint through decorated function:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def identity(f: Callable[[str], str]) -> Callable[[str], str]:\n  return f\n\n@identity\ndef decorated(x: str) -> str:\n  # Whatever happens here will not be considered at the call site.\n  return 'hello %s' % x\n\nsink(decorated(source())) # Issue is properly found.\n")),(0,r.mdx)("p",null,"Pysa provides a few ways to deal with these limitations."),(0,r.mdx)("h2",{id:"ignoring-decorators"},"Ignoring decorators"),(0,r.mdx)("p",null,"Pysa can entirely ignore a decorator, as if it was not present in the source code. This can be done safely when the decorator does not change the signature of the decorated function (i.e, it does not add or remove parameters)."),(0,r.mdx)("p",null,"To ignore a decorator, use the ",(0,r.mdx)("inlineCode",{parentName:"p"},"@IgnoreDecorator")," annotation in a ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@IgnoreDecorator\ndef module.decorator(): ...\n")),(0,r.mdx)("h2",{id:"inlining-decorators"},"Inlining decorators"),(0,r.mdx)("p",null,"Pysa can try to inline decorators into decorated functions before analyzing them. This can be enabled with the ",(0,r.mdx)("inlineCode",{parentName:"p"},"--inline-decorators")," flag."),(0,r.mdx)("p",null,"Inlining will take the code of the decorator and copy it within the decorated function. For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def my_decorator(f: Callable[[int], int]) -> Callable[[int], int]:\n  def inner(x: int) -> int:\n    before(x)\n    result = f(x)\n    after(x)\n    return result\n\n  return inner\n\n@my_decorator\ndef decorated(x: int) -> int:\n  return x + 1\n")),(0,r.mdx)("p",null,"Will be inlined as:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"def decorated(x: int) -> int:\n  before(x)\n  result = x + 1\n  after(x)\n  return result\n")),(0,r.mdx)("h3",{id:"prevent-inlining-decorators-with-skipdecoratorwheninlining"},"Prevent Inlining Decorators with ",(0,r.mdx)("inlineCode",{parentName:"h3"},"SkipDecoratorWhenInlining")),(0,r.mdx)("p",null,"Decorator inlining comes at the cost of increasing the analysis time and also increasing the lengths of traces. If you would like to prevent certain decorators from being inlined, you can mark them in your ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file using ",(0,r.mdx)("inlineCode",{parentName:"p"},"@SkipDecoratorWhenInlining"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# foo.pysa\n@SkipDecoratorWhenInlining\ndef foo.decorator_to_be_skipped(f): ...\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# foo.py\n@decorator_to_be_skipped\ndef bar(x: int) -> None:\n  pass\n")),(0,r.mdx)("p",null,"This will prevent the decorator from being inlined when analyzing ",(0,r.mdx)("inlineCode",{parentName:"p"},"bar"),". Note that we use ",(0,r.mdx)("inlineCode",{parentName:"p"},"@SkipDecoratorWhenInlining")," on the decorator that is to be skipped, not the function on which the decorator is applied."),(0,r.mdx)("p",null,"Unfortunately, this will lead back to false negatives as described earlier."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@decorator_to_be_skipped\ndef bar(x: int) -> None:\n  sink(x)\n\nbar(source()) # False negative, issue will NOT be found!\n")),(0,r.mdx)("h2",{id:"single-trace-sanitizers-with-sanitizesingletrace"},"Single trace sanitizers with ",(0,r.mdx)("inlineCode",{parentName:"h2"},"@SanitizeSingleTrace")),(0,r.mdx)("p",null,"Sanitizers, as described in the ",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-basics"},"Overview"),", are applied in both\nthe forward (i.e source) trace and backward (i.e sink) trace."),(0,r.mdx)("p",null,"For instance, with the given ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@Sanitize(TaintInTaintOut[TaintSink[RemoteCodeExecution]])\ndef shlex.quote(x): ...\n")),(0,r.mdx)("p",null,"And the following Python code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"import subprocess\nfrom shlex import quote\n\ndef quoted_input():\n  x = input() # source 'UserControlled'\n  y = quote(x)\n  return y\n\ndef echo(argument):\n  subprocess.run(f'/bin/echo {argument}', shell=True) # sink 'RemoteCodeExecution'\n\ndef issue():\n  x = quoted_input() # source trace: input -> quoted_input -> issue\n  echo(x) # sink trace: issue -> echo -> subprocess.run\n")),(0,r.mdx)("p",null,"Pysa will NOT find an issue here, as expected.\nThis is because during the propagation of the 'UserControlled' source in the\nforward trace, pysa remembers that it was sanitized for the sink 'RemoteCodeExecution'."),(0,r.mdx)("p",null,"However, Pysa provides a simpler version of sanitizers, which only sanitizes in the\nforward trace or the backward trace:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@SanitizeSingleTrace(TaintSource)\ndef f(): ...\n\n@SanitizeSingleTrace(TaintSource[UserControlled])\ndef g(): ...\n\n@SanitizeSingleTrace(TaintSink)\ndef h(): ...\n\n@SanitizeSingleTrace(TaintSink[RemoteCodeExecution])\ndef i(): ...\n")),(0,r.mdx)("p",null,"These sanitizers are a lot cheaper and could save analysis time. However, these\nmight introduce false positives, so we recommend to use the default sanitizers."),(0,r.mdx)("h2",{id:"filtering-the-call-graph-with-entrypoint"},"Filtering the call graph with ",(0,r.mdx)("inlineCode",{parentName:"h2"},"@Entrypoint")),(0,r.mdx)("p",null,"By default, Pysa will analyze the entire call graph of your program. This can lead to longer analysis times for larger programs, especially when you'd only like to perform analysis on specific parts of the program. This decorator will mark a specified function and the functions it calls as the only functions to be analyzed."),(0,r.mdx)("p",null,"Note: the flag ",(0,r.mdx)("inlineCode",{parentName:"p"},"--limit-entrypoints")," must be passed to ",(0,r.mdx)("inlineCode",{parentName:"p"},"pyre analyze")," for call graph filtering to occur, even if the ",(0,r.mdx)("inlineCode",{parentName:"p"},"@Entrypoint")," decorator is present. This allows for call graph filtering to be easily enabled or disabled without editing your ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," files."),(0,r.mdx)("p",null,"If you have the following Python file:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"class MyClass:\n  def class_entrypoint():\n    taint_sink(taint_source())\n\ndef my_bad_func_1():\n  taint_sink(taint_source())\n\ndef my_bad_func_2():\n  taint_sink(taint_source())\n\ndef func_entrypoint():\n  my_bad_func_1()\n\ndef main():\n  func_entrypoint()\n  my_bad_func_2()\n  MyClass().class_entrypoint()\n\nmain()\n")),(0,r.mdx)("p",null,"And the following ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@Entrypoint\ndef my_file.MyClass.class_entrypoint(): ...\n\n@Entrypoint\ndef func_entrypoint(): ...\n")),(0,r.mdx)("p",null,"Then issues will be found for taint in calls to ",(0,r.mdx)("inlineCode",{parentName:"p"},"class_entrypoint")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"my_bad_func_1"),", but not ",(0,r.mdx)("inlineCode",{parentName:"p"},"my_bad_func_2"),", since it isn't called by a function marked by an ",(0,r.mdx)("inlineCode",{parentName:"p"},"@Entrypoint"),"."),(0,r.mdx)("h2",{id:"taint-in-taint-out-transforms"},"Taint In Taint Out Transforms"),(0,r.mdx)("p",null,"Taint in taint out transforms can be used to capture more precise flows."),(0,r.mdx)("p",null,"As an example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def read_file(path):\n  with open(path, "r") as f:\n    content = f.read()\n  return content\n')),(0,r.mdx)("p",null,"Without taint in taint transforms we can write a rule that captures a ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," path is ",(0,r.mdx)("inlineCode",{parentName:"p"},"read"),". Such a rule can be made much higher signal if we can detect that ",(0,r.mdx)("inlineCode",{parentName:"p"},"content")," is also ",(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnedToUser"),". We can use taint in taint out transforms to stitch the two flows together. We mark ",(0,r.mdx)("inlineCode",{parentName:"p"},"read")," with a taint in taint out transform ",(0,r.mdx)("inlineCode",{parentName:"p"},"FileRead"),", and the rule becomes ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled -> FileRead -> ReturnedToUser"),"."),(0,r.mdx)("p",null,"To contrast with feature annotations, there are two differences:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"The filtering is done during analysis itself, and limits the issues generated (as opposed to a post-processing step by the user)"),(0,r.mdx)("li",{parentName:"ul"},"Taint in taint out transforms can be used to reason about the order of events")),(0,r.mdx)("h3",{id:"syntax"},"Syntax"),(0,r.mdx)("p",null,"In ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config"),", one can specify ",(0,r.mdx)("inlineCode",{parentName:"p"},"transforms")," to define new transforms. Each transform is defined by following fields:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"name"),": name of the transform, this is used when defining rules, as well as writing models"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"comment"),": description of the transform")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'{\n  ...\n  "transforms": [\n    {\n      "name": "MyTransform",\n      "comment": "This is my transform"\n    },\n    ...\n  ],\n  ...\n}\n')),(0,r.mdx)("p",null,"Then, one may use these transforms in ",(0,r.mdx)("inlineCode",{parentName:"p"},"rules")," as follows:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},' {\n  ...\n  "rules": [\n    {\n      "name": ...,\n      "code": ...,\n      "sources": ["SourceA"],\n      "transforms": ["MyTransform1", "MyTransform2"],\n      "sinks": ["SinkB"],\n      "message_format": "[{$sources}] transformed by [${transforms}] may reach [${sinks}]"\n    },\n    ...\n  ],\n  ...\n}\n')),(0,r.mdx)("p",null,"Intuitively, one can think of the rule above as ",(0,r.mdx)("inlineCode",{parentName:"p"},"SourceA -> MyTransform1 -> MyTransform2 -> SinkB"),". The order is important."),(0,r.mdx)("p",null,"Finally, in ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," model files a taint transform can be specified using a ",(0,r.mdx)("inlineCode",{parentName:"p"},"TaintInTaintOut[Transform[...]]")," annotation, where the parameter is the name of the transform."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"def my_function(arg: TaintInTaintOut[Transform[MyTransform]]): ...\n")),(0,r.mdx)("h3",{id:"semantics"},"Semantics"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"  y = my_function(x)\n")),(0,r.mdx)("p",null,"If ",(0,r.mdx)("inlineCode",{parentName:"p"},"x")," has source taint ",(0,r.mdx)("inlineCode",{parentName:"p"},"SourceA"),", the taint of ",(0,r.mdx)("inlineCode",{parentName:"p"},"y")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"MyTransform:SourceA"),". This will correspond to matching ",(0,r.mdx)("inlineCode",{parentName:"p"},"SourceA -> MyTransform")," in a rule. Likewise, if ",(0,r.mdx)("inlineCode",{parentName:"p"},"y")," has sink taint ",(0,r.mdx)("inlineCode",{parentName:"p"},"SinkB"),", then the taint of ",(0,r.mdx)("inlineCode",{parentName:"p"},"x")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"MyTransorm:SinkB"),". This will correspond to matching ",(0,r.mdx)("inlineCode",{parentName:"p"},"MyTransform -> SinkB")," in a rule."),(0,r.mdx)("p",null,"Note that a transform modifies the taint itself. Hence, if a flow passes through a transform, it will no longer match rules which do not contain the transform."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"RuleX: SourceA -> SinkB\nRuleY: SourceA -> MyTransform -> SinkB\nFlow1: SourceA -> SinkB\nFlow2: SourceA -> MyTransform -> SinkB\n")),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"Flow1")," matches ",(0,r.mdx)("inlineCode",{parentName:"p"},"RuleX")," but not ",(0,r.mdx)("inlineCode",{parentName:"p"},"RuleY"),". ",(0,r.mdx)("inlineCode",{parentName:"p"},"Flow2")," matches ",(0,r.mdx)("inlineCode",{parentName:"p"},"RuleY")," but not ",(0,r.mdx)("inlineCode",{parentName:"p"},"RuleX"),"."),(0,r.mdx)("p",null,"Consider the scenario where we have an additional rule:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"RuleZ: SourceC -> SinkD\n")),(0,r.mdx)("p",null,"If transform ",(0,r.mdx)("inlineCode",{parentName:"p"},"MyTransform")," is applied to taint ",(0,r.mdx)("inlineCode",{parentName:"p"},"SourceC"),", there is no possible rule it can possibly match. As an optimization, we check for this continuously in our analysis and filter out eagerly."),(0,r.mdx)("p",null,"Also note that the existing TaintInTaintOut annotation semantics of TITO being assumed (instead of inferred) on the argument are unchanged."),(0,r.mdx)("h2",{id:"tune-the-taint-tree-width-and-depth"},"Tune the taint tree width and depth"),(0,r.mdx)("p",null,"Pysa provides many options to fine tune the taint analysis. The following\noptions can be provided either via the command line or in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config")," file,\nunder the ",(0,r.mdx)("inlineCode",{parentName:"p"},"options")," section."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_model_source_tree_width": 10,\n    "maximum_model_sink_tree_width": 10,\n    "maximum_model_tito_tree_width": 10\n  }\n}\n')),(0,r.mdx)("p",null,"When not provided, these are set to the following defaults:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ocaml",metastring:"file=source/interprocedural_analyses/taint/taintConfiguration.ml start=DOCUMENTATION_CONFIGURATION_START end=DOCUMENTATION_CONFIGURATION_END",file:"source/interprocedural_analyses/taint/taintConfiguration.ml",start:"DOCUMENTATION_CONFIGURATION_START",end:"DOCUMENTATION_CONFIGURATION_END"},"maximum_model_source_tree_width = 25;\nmaximum_model_sink_tree_width = 25;\nmaximum_model_tito_tree_width = 5;\nmaximum_tree_depth_after_widening = 4;\nmaximum_return_access_path_width = 10;\nmaximum_return_access_path_depth_after_widening = 4;\nmaximum_tito_collapse_depth = 4;\nmaximum_tito_positions = 50;\n")),(0,r.mdx)("h3",{id:"maximum-model-source-tree-width"},"Maximum model source tree width"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Command line option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"--maximum-model-source-tree-width")),(0,r.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"maximum_model_source_tree_width"))),(0,r.mdx)("p",null,"This limits the width of the source tree in the model for a callable, i.e\nthe number of output paths in the return value."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def foo():\n  return {"a": source(), "b": source(), "c": source()}\n')),(0,r.mdx)("p",null,"The source tree for ",(0,r.mdx)("inlineCode",{parentName:"p"},"foo")," has a width of 3. Above the provided threshold, pysa\nwill collapse the taint and consider the whole dictionary tainted."),(0,r.mdx)("h3",{id:"maximum-model-sink-tree-width"},"Maximum model sink tree width"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Command line option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"--maximum-model-sink-tree-width")),(0,r.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"maximum_model_sink_tree_width"))),(0,r.mdx)("p",null,"This limits the width of the sink tree in the model for a callable, i.e\nthe number of input paths leading to a sink for a given parameter."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  sink(arg[1])\n  sink(arg[2])\n  sink(arg[3])\n")),(0,r.mdx)("p",null,"The sink tree for ",(0,r.mdx)("inlineCode",{parentName:"p"},"foo")," and parameter ",(0,r.mdx)("inlineCode",{parentName:"p"},"arg")," has a width of 3.\nAbove the provided threshold, pysa will collapse the taint and consider that the\nwhole argument leads to a sink."),(0,r.mdx)("h3",{id:"maximum-model-tito-tree-width"},"Maximum model tito tree width"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Command line option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"--maximum-model-tito-tree-width")),(0,r.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"maximum_model_tito_tree_width"))),(0,r.mdx)("p",null,"This limits the width of the taint-in-taint-out tree in the model for a callable,\ni.e the number of input paths propagated to the return value, for a given parameter."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  return '%s:%s:%s' % (arg.a, arg.b, arg.c)\n")),(0,r.mdx)("p",null,"The taint-in-taint-out tree for ",(0,r.mdx)("inlineCode",{parentName:"p"},"foo")," and parameter ",(0,r.mdx)("inlineCode",{parentName:"p"},"arg")," has a width of 3.\nAbove the provided threshold, pysa will collapse the taint and consider that the\ntaint on the whole argument is propagated to the return value."),(0,r.mdx)("h3",{id:"maximum-tree-depth-after-widening"},"Maximum tree depth after widening"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Command line option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"--maximum-tree-depth-after-widening")),(0,r.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"maximum_tree_depth_after_widening"))),(0,r.mdx)("p",null,"This limits the depth of the source, sink and tito trees within loops, i.e the\nlength of source, sink and tito paths for each variables."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo():\n  variable = MyClass()\n  for x in generate():\n    variable.a.b.c = source()\n  return result\n")),(0,r.mdx)("p",null,"The source tree for ",(0,r.mdx)("inlineCode",{parentName:"p"},"variable")," has a depth of 3 (i.e, ",(0,r.mdx)("inlineCode",{parentName:"p"},"a")," -> ",(0,r.mdx)("inlineCode",{parentName:"p"},"b")," -> ",(0,r.mdx)("inlineCode",{parentName:"p"},"c"),").\nWithin a loop, pysa limits the depth to the provided threshold. For instance,\nif that threshold is 1, we would consider that ",(0,r.mdx)("inlineCode",{parentName:"p"},"variable.a")," is entirely tainted."),(0,r.mdx)("h3",{id:"maximum-return-access-path-width"},"Maximum return access path width"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Command line option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"--maximum-return-access-path-width")),(0,r.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"maximum_return_access_path_width"))),(0,r.mdx)("p",null,"This limits the width of the return access path tree in the model for a callable,\ni.e the number of output paths propagated to the return value, for a given parameter."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  return {'a': arg, 'b': arg, 'c': arg}\n")),(0,r.mdx)("p",null,"The return access path tree for ",(0,r.mdx)("inlineCode",{parentName:"p"},"foo")," and parameter ",(0,r.mdx)("inlineCode",{parentName:"p"},"arg")," has a width of 3.\nAbove the provided threshold, pysa will collapse the taint and consider that the\nwhole return value is tainted whenever ",(0,r.mdx)("inlineCode",{parentName:"p"},"arg")," is tainted."),(0,r.mdx)("h3",{id:"maximum-return-access-path-depth-after-widening"},"Maximum return access path depth after widening"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Command line option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"--maximum-return-access-path-depth-after-widening")),(0,r.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"maximum_return_access_path_depth_after_widening"))),(0,r.mdx)("p",null,"This limits the depth of the return access path tree within loops, i.e the\nlength of output paths propagated to the return value, for a given parameter."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  result = MyClass()\n  for x in generate():\n    result.a.b.c = arg\n  return result\n")),(0,r.mdx)("p",null,"The return access path tree for ",(0,r.mdx)("inlineCode",{parentName:"p"},"foo")," and parameter ",(0,r.mdx)("inlineCode",{parentName:"p"},"arg")," has a depth  of 3\n(i.e, ",(0,r.mdx)("inlineCode",{parentName:"p"},"a")," -> ",(0,r.mdx)("inlineCode",{parentName:"p"},"b")," -> ",(0,r.mdx)("inlineCode",{parentName:"p"},"c"),"). Within a loop, pysa limits the depth to the provided\nthreshold. For instance, if that threshold is 2, we would cut the output path\nto just ",(0,r.mdx)("inlineCode",{parentName:"p"},"a.b"),"."),(0,r.mdx)("h3",{id:"maximum-tito-collapse-depth"},"Maximum tito collapse depth"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Command line option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"--maximum-tito-collapse-depth")),(0,r.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"maximum_tito_collapse_depth"))),(0,r.mdx)("p",null,"This limits the depth of the taint tree after applying taint-in-taint-out,\ni.e the length of paths for taint propagated from a parameter to the return\nvalue."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def identity(arg): return arg\n\ndef foo():\n  input = {'a': {'b': {'c': source()}}}\n  output = identity(input)\n")),(0,r.mdx)("p",null,"The taint tree for ",(0,r.mdx)("inlineCode",{parentName:"p"},"input")," has a depth of 3 (i.e, ",(0,r.mdx)("inlineCode",{parentName:"p"},"a")," -> ",(0,r.mdx)("inlineCode",{parentName:"p"},"b")," -> ",(0,r.mdx)("inlineCode",{parentName:"p"},"c"),").\nWhen the taint is propagated to the return value of ",(0,r.mdx)("inlineCode",{parentName:"p"},"identity"),", we limit\nthe resulting taint tree to the given depth. For instance, if that threshold\nis 1, we would consider that ",(0,r.mdx)("inlineCode",{parentName:"p"},"output['a']")," is tainted."),(0,r.mdx)("p",null,"This is also applied for sinks in the backward analysis:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(arg):\n  output = identity(arg)\n  sink(output['a']['b']['c'])\n")),(0,r.mdx)("p",null,"With a threshold of 1, we would consider that ",(0,r.mdx)("inlineCode",{parentName:"p"},"output['a']")," leads to a sink."),(0,r.mdx)("h3",{id:"maximum-tito-positions"},"Maximum tito positions"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Command line option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"--maximum-tito-positions")),(0,r.mdx)("li",{parentName:"ul"},"taint.config option: ",(0,r.mdx)("inlineCode",{parentName:"li"},"maximum_tito_positions"))),(0,r.mdx)("p",null,"This limits the number of positions to keep track of when propagating taint."),(0,r.mdx)("p",null,"When taint is propagated through a function and returned (i.e, taint-in-taint-out),\npysa will keep track of the position of the argument, and display it in the trace."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def foo():\n  x = source()\n  y = tito(x)\n           ^\n  z = {"a": y}\n            ^\n  sink(z)\n')),(0,r.mdx)("p",null,"In this example, we have 2 tito positions. Above the provided threshold,\npysa simply discards all positions. Note that the taint is still propagated."))}c.isMDXComponent=!0}}]);