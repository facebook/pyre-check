"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[415],{3905:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>d,MDXProvider:()=>c,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>m});var t=a(67294);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function s(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?s(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=t.createContext({}),m=function(e){return function(n){var a=p(n.components);return t.createElement(e,r({},n,{components:a}))}},p=function(e){var n=t.useContext(d),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},c=function(e){var n=p(e.components);return t.createElement(d.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(a),c=i,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||r;return a?t.createElement(h,o(o({ref:n},d),{},{components:a})):t.createElement(h,o({ref:n},d))}));function f(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=h;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var d=2;d<r;d++)s[d]=a[d];return t.createElement.apply(null,s)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},72560:(e,n,a)=>{a.r(n),a.d(n,{frontMatter:()=>o,contentTitle:()=>l,metadata:()=>d,toc:()=>m,default:()=>c});var t=a(87462),i=a(63366),r=(a(67294),a(3905)),s=["components"],o={id:"pysa-advanced",title:"Advanced Topics",sidebar_label:"Advanced Topics"},l=void 0,d={unversionedId:"pysa-advanced",id:"pysa-advanced",isDocsHomePage:!1,title:"Advanced Topics",description:"This page documents less straightforward bits of Pysa.",source:"@site/docs/pysa_advanced.md",sourceDirName:".",slug:"/pysa-advanced",permalink:"/docs/pysa-advanced",editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/pysa_advanced.md",tags:[],version:"current",frontMatter:{id:"pysa-advanced",title:"Advanced Topics",sidebar_label:"Advanced Topics"},sidebar:"pysa",previous:{title:"Feature Annotations",permalink:"/docs/pysa-features"},next:{title:"Implementation Details",permalink:"/docs/pysa-implementation-details"}},m=[{value:"Obscure models",id:"obscure-models",children:[]},{value:"Tainting Specific <code>kwargs</code>",id:"tainting-specific-kwargs",children:[]},{value:"Instance attributes versus class attributes",id:"instance-attributes-versus-class-attributes",children:[]},{value:"Literal String Sources And Sinks",id:"literal-string-sources-and-sinks",children:[]},{value:"Combined Source Rules",id:"combined-source-rules",children:[]},{value:"Prevent Inferring Models with <code>SkipAnalysis</code>",id:"prevent-inferring-models-with-skipanalysis",children:[]},{value:"Ignoring overrides",id:"ignoring-overrides",children:[]},{value:"Limit the trace length for better signal and performance",id:"limit-the-trace-length-for-better-signal-and-performance",children:[]},{value:"Limit the tito depth for better signal and performance",id:"limit-the-tito-depth-for-better-signal-and-performance",children:[]},{value:"Prevent Inlining Decorators with <code>SkipDecoratorWhenInlining</code>",id:"prevent-inlining-decorators-with-skipdecoratorwheninlining",children:[]},{value:"Single trace sanitizers with <code>@SanitizeSingleTrace</code>",id:"single-trace-sanitizers-with-sanitizesingletrace",children:[]},{value:"Taint In Taint Out Transforms",id:"taint-in-taint-out-transforms",children:[{value:"Syntax",id:"syntax",children:[]},{value:"Semantics",id:"semantics",children:[]}]}],p={toc:m};function c(e){var n=e.components,a=(0,i.Z)(e,s);return(0,r.mdx)("wrapper",(0,t.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"This page documents less straightforward bits of Pysa."),(0,r.mdx)("h2",{id:"obscure-models"},"Obscure models"),(0,r.mdx)("p",null,"When Pysa does not have enough information about a function or method, it will\nmake basic assumptions about its behavior. This is referred to as an ",(0,r.mdx)("strong",{parentName:"p"},"obscure\nmodel"),". Most notably, it assumes that the function or method propagates the\ntaint from its arguments to its return value."),(0,r.mdx)("p",null,"This usually happens when Pysa doesn't know about the callee of a function call:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(f: Any):\n    x = input()\n    y = f(x) # no information about `f`, y will be considered tainted.\n    eval(y)\n")),(0,r.mdx)("p",null,"Functions and methods defined in type stubs or in a different language (for\ninstance, in C or C++ binding) will also be treated as obscure models."),(0,r.mdx)("p",null,"To prevent a function or method to be marked as obscure, one can use the\n",(0,r.mdx)("inlineCode",{parentName:"p"},"@SkipObscure")," taint annotation in a ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipObscure\ndef module.foo(): ...\n")),(0,r.mdx)("h2",{id:"tainting-specific-kwargs"},"Tainting Specific ",(0,r.mdx)("inlineCode",{parentName:"h2"},"kwargs")),(0,r.mdx)("p",null,"Sometimes, a function can have potential sinks mixed together with benign\nparameters in the keyword arguments (",(0,r.mdx)("inlineCode",{parentName:"p"},"kwargs"),") that it accepts. In these cases,\ntainting the whole ",(0,r.mdx)("inlineCode",{parentName:"p"},"kwargs")," variable will result in false positives when tainted\ndata flows into a benign ",(0,r.mdx)("inlineCode",{parentName:"p"},"kwarg"),". Instead, for a function like this:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def eval_and_log(**kwargs):\n    eval(kwargs["eval"])\n    logging.debug(kwargs["log"])\n')),(0,r.mdx)("p",null,"We can lie a bit in our ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file, and break out the dangerous argument for\ntainting:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def eval_and_log(*, eval: TaintSink[RemoteCodeExecution], **kwargs): ...\n")),(0,r.mdx)("p",null,"This allows us to catch flows only into the ",(0,r.mdx)("inlineCode",{parentName:"p"},"eval")," keyword argument."),(0,r.mdx)("h2",{id:"instance-attributes-versus-class-attributes"},"Instance attributes versus class attributes"),(0,r.mdx)("p",null,"Models can specify sources and sinks on attributes, following the type annotation\nsyntax:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"django.http.request.HttpRequest.GET: TaintSource[UserControlled]\n")),(0,r.mdx)("p",null,"Any access to ",(0,r.mdx)("inlineCode",{parentName:"p"},"request.GET")," will be tainted when ",(0,r.mdx)("inlineCode",{parentName:"p"},"request")," is an instance of\n",(0,r.mdx)("inlineCode",{parentName:"p"},"HttpRequest")," or any of its children. However, note that the access to the class\nattribute (i.e, ",(0,r.mdx)("inlineCode",{parentName:"p"},"HttpRequest.GET"),") won't be considered tainted."),(0,r.mdx)("p",null,"To specify sources and sinks on class attributes, use the ",(0,r.mdx)("inlineCode",{parentName:"p"},"__class__")," prefix:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"django.http.request.HttpRequest.__class__.GET: TaintSource[UserControlled]\n")),(0,r.mdx)("p",null,"To specify a source on both the class attribute and instance attribute, simply\nuse both lines."),(0,r.mdx)("h2",{id:"literal-string-sources-and-sinks"},"Literal String Sources And Sinks"),(0,r.mdx)("p",null,"Some security vulnerabilities are best captured by modeling strings of a given\nform flowing to dangerous functions, or format strings that match a pattern getting\ntainted data passed in."),(0,r.mdx)("p",null,"To mark all literal strings matching a pattern as sources, you first need to add a\nregular expression corresponding to the pattern to your ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "name": "IPAddress"\n    }\n  ],\n  "implicit_sources": {\n     "literal_strings": [\n       {\n         "regexp": "\\\\d{1,3}(\\\\.\\\\d{1,3})+",\n         "kind": "IPAddress",\n         "description": "String that looks like an IP address."\n       }\n     ]\n  }\n}\n')),(0,r.mdx)("p",null,"With this regex in place, whenever Pysa sees a string such as ",(0,r.mdx)("inlineCode",{parentName:"p"},"123.456.789.123"),", it will flag it\nas a taint source with the kind ",(0,r.mdx)("inlineCode",{parentName:"p"},"IPAddress"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def test() -> None:\n    ip_address = "123.456.789.123"\n    dont_pass_an_ip_address(ip_address) # Pysa will now flag this.\n')),(0,r.mdx)("p",null,"The converse of supporting literal strings as sinks is also supported, for data flowing into a tainted string. The\nsyntax allows you to model data being used to format strings, like f-strings, manual string formatting, the string ",(0,r.mdx)("inlineCode",{parentName:"p"},"format()")," method, and printf-style string formatting with ",(0,r.mdx)("inlineCode",{parentName:"p"},"%"),"."),(0,r.mdx)("p",null,"Template strings and and manual string formatting with more than two subexpressions are not yet supported."),(0,r.mdx)("p",null,"To add a literal sink, first add the literal_sink to your configuration"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sinks": [\n    { "name": "MayBeRendered" },\n    { "name": "MayBeSQL" }\n  ],\n  "implicit_sinks": {\n     "literal_strings": [\n       {\n         "regexp": "^<.*>$",\n         "kind": "MayBeRendered",\n         "description": "Indicates a string whose contents may be rendered."\n       },\n       {\n         "regexp": "^SELECT *.",\n         "kind": "MayBeSQL",\n         "description": "Indicates a string whose contents may be a SQL query."\n       }\n\n     ]\n  }\n')),(0,r.mdx)("p",null,"Now, Pysa will treat any values flowing into a each of the following as a regular sink:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def may_render(parameter: str) -> None:\n    result = f"<content={parameter}>"\n    result = "<content={}>".format(parameter)\n    result = "<content%s>" % (parameter,)\n')),(0,r.mdx)("p",null,"As well as values flowing into each of these as a regular sink:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def build_sql_query(columns: str) -> None:\n    result = f"SELECT {columns} FROM users;"\n    result = "SELECT {} FROM users;".format(columns)\n    result = "SELECT %s FROM users" % (columns,)\n    result = "SELECT " + columns + " FROM users;"\n')),(0,r.mdx)("h2",{id:"combined-source-rules"},"Combined Source Rules"),(0,r.mdx)("p",null,"Some security vulnerabilities are better modeled as ",(0,r.mdx)("em",{parentName:"p"},"multiple")," sources reaching\na sink. For example, leaking credentials via ",(0,r.mdx)("inlineCode",{parentName:"p"},"requests.get")," could be modeled as\nuser controlled data flowing into the ",(0,r.mdx)("inlineCode",{parentName:"p"},"url")," parameter and credentials flowing\ninto the ",(0,r.mdx)("inlineCode",{parentName:"p"},"params")," parameter. These flows can be modeled by ",(0,r.mdx)("em",{parentName:"p"},"combined source\nrules"),"."),(0,r.mdx)("p",null,"Sources for combined source rules are declared as normal in ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config"),".\nSinks, however, need to be unique to the combined source rule and are declared inside\nthe rule definition. The rule itself is declared in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"combined_source_rules"),"\ntop level entry. The rule lists all the same things as a reglular rule, but also ties\nlabels to its sources:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    { "name": "UserControlled" },\n    { "name": "Credentials" }\n  ],\n  "combined_source_rules": [\n    {\n       "name": "Credentials leaked through requests",\n       "sources": { "url": "UserControlled", "creds": "Credentials" },\n       "partial_sink": "UserControlledRequestWithCreds",\n       "code": 1,\n       "message_format": "Credentials leaked through requests"\n    }\n  ]\n}\n')),(0,r.mdx)("p",null,"Sources are declared as normal in ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," files. Instead of specifying sinks\nwith a ",(0,r.mdx)("inlineCode",{parentName:"p"},"TaintSink")," annotation, however, ",(0,r.mdx)("inlineCode",{parentName:"p"},"PartialSink")," annotations are used to\nspecify where each source needs to flow for the combined source rule. These\n",(0,r.mdx)("inlineCode",{parentName:"p"},"PartialSink")," must reference the labels that were declared in\n",(0,r.mdx)("inlineCode",{parentName:"p"},"multi_sink_labels"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def requests.api.get(\n  url: PartialSink[UserControlledRequestWithCreds[url]],\n  params: PartialSink[UserControlledRequestWithCreds[creds]],\n  **kwargs\n): ...\n")),(0,r.mdx)("p",null,"With the above configuration, Pysa can detect cases where ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," flows\ninto ",(0,r.mdx)("inlineCode",{parentName:"p"},"url")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"Credentials")," flow into ",(0,r.mdx)("inlineCode",{parentName:"p"},"params")," ",(0,r.mdx)("em",{parentName:"p"},"at the same time"),"."),(0,r.mdx)("h2",{id:"prevent-inferring-models-with-skipanalysis"},"Prevent Inferring Models with ",(0,r.mdx)("inlineCode",{parentName:"h2"},"SkipAnalysis")),(0,r.mdx)("p",null,"In addition to the models defined in ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," files, Pysa will infer models for\nfunctions based what sources, sinks, etc. they call in their body. The\n",(0,r.mdx)("inlineCode",{parentName:"p"},"SkipAnalysis")," annotation can be used to prevent Pysa from inferring models, and\ninstead force it to use only the user defined models for determining taint flow:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipAnalysis\ndef qualifier.dont_generate_models(argument): ...\n")),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"SkipAnalysis")," can be applied at the class level as a shorthand to prevent pysa\nfrom infering models for all functions in a class:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"class skip_analysis.SkipMe(SkipAnalysis): ...\n")),(0,r.mdx)("h2",{id:"ignoring-overrides"},"Ignoring overrides"),(0,r.mdx)("p",null,"When a method is called on a base class, Pysa has to assume that that call could\nactually invoke any subclass methods that override the base class's method. For\nheavily overriden methods, this can lead to both performance impacts and false\npositives. When running Pysa, you may see messages such as this in the output:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"2020-09-02 09:25:50,677 WARNING `object.__init__` has 106 overrides, this might slow down the analysis considerably.\n")),(0,r.mdx)("p",null,"The above message indicates that 106 subclasses of ",(0,r.mdx)("inlineCode",{parentName:"p"},"object")," have overridden\n",(0,r.mdx)("inlineCode",{parentName:"p"},"__init__"),". If Pysa sees taint flowing into ",(0,r.mdx)("inlineCode",{parentName:"p"},"object.__init__"),", then it will\ntreat all 106 overrides of ",(0,r.mdx)("inlineCode",{parentName:"p"},"object.__init__")," as also receiving that taint."),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"@SkipOverrides")," decorator can be applied to deal with false positives or\nperformance issues from having too many overrides on a given function:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@SkipOverrides\ndef object.__init__(self): ...\n")),(0,r.mdx)("p",null,"This annotation will cause Pysa not to propagate taint into to and from\noverridden methods on subclasses, when analyzing functions that call the\noverriden method on the base class."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"maximum_overrides_to_analyze")," can be added the the ",(0,r.mdx)("inlineCode",{parentName:"p"},"options")," block of\n",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config")," to limit the number of overrides that Pysa will analyze:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_overrides_to_analyze": 60\n  }\n}\n')),(0,r.mdx)("p",null,"This can speed up the analysis, but it will lead to false negatives, because\nPysa will only propagate taint to or from 60 (in the case of the above example)\noverriden methods on subclasses. The remaining overriding methods will be\nignored and treated as if they weren't actually overriding the base class\nmethod."),(0,r.mdx)("p",null,"By default, Pysa skips overrides on some functions that are typically\nproblematic. You can find the full list of default-skipped functions in\n",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/facebook/pyre-check/blob/main/stubs/taint/skipped_overrides.pysa"},(0,r.mdx)("inlineCode",{parentName:"a"},"stubs/taint/skipped_overrides.pysa"))),(0,r.mdx)("h2",{id:"limit-the-trace-length-for-better-signal-and-performance"},"Limit the trace length for better signal and performance"),(0,r.mdx)("p",null,"By default, Pysa will find all flows from sources to sinks matching a rule.\nThis can lead to very long traces which are hard to understand and tend to be\nfalse positives. This also brings down the performance a lot."),(0,r.mdx)("p",null,"Pysa provides a ",(0,r.mdx)("inlineCode",{parentName:"p"},"--maximum-trace-length <integer>")," command line argument which\nlimits the length of traces that it finds. In general, this will also make Pysa\nfaster."),(0,r.mdx)("p",null,"This option can also be added in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config")," as follows:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_trace_length": 20\n  }\n}\n')),(0,r.mdx)("p",null,"Note that this is not a silver bullet and that this might hide security\nvulnerabilities. Use it with caution."),(0,r.mdx)("h2",{id:"limit-the-tito-depth-for-better-signal-and-performance"},"Limit the tito depth for better signal and performance"),(0,r.mdx)("p",null,"Pysa infers automatically when a function propagate the taint from one argument\nto its return value. This is called tito, for Taint In Taint Out. In practice,\ninfering it can be very expensive since the taint can go through an arbitrary\nnumber of hops (i.e, depth)."),(0,r.mdx)("p",null,"For instance:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def foo(x):\n  return x\ndef bar(x):\n  return foo(x)\ndef baz(x):\n  return bar(x)\n")),(0,r.mdx)("p",null,"In this example, ",(0,r.mdx)("inlineCode",{parentName:"p"},"baz")," propagates the taint on its argument to the return value\nusing 3 hops."),(0,r.mdx)("p",null,"Pysa provides a ",(0,r.mdx)("inlineCode",{parentName:"p"},"--maximum-tito-depth <integer>")," command line argument which\nlimints the depth of inferred propagations. In combination with the trace length\nlimit, this usually makes Pysa faster."),(0,r.mdx)("p",null,"This option can also be added in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config")," as follows:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [],\n  "sinks": [],\n  "features": [],\n  "rules": [],\n  "options": {\n    "maximum_tito_depth": 20\n  }\n}\n')),(0,r.mdx)("h1",{id:"inlining-decorators-during-analysis"},"Inlining Decorators during Analysis"),(0,r.mdx)("p",null,"By default, Pysa ignores issues that arise in the bodies of decorators. For example, it misses issues like decorators logging data. In the code below, Pysa will not catch the flow from ",(0,r.mdx)("inlineCode",{parentName:"p"},"loggable_string")," to the sink within the decorator ",(0,r.mdx)("inlineCode",{parentName:"p"},"with_logging"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"def with_logging(f: Callable[[str], None]) -> Callable[[str], None]:\n\n  def inner(y: str) -> None:\n    log_to_my_sink(y)\n    f(y)\n\n  return inner\n\n@with_logging\ndef foo(z: str) -> None:\n  print(z)\n\nfoo(loggable_string)\n")),(0,r.mdx)("p",null,"However, Pysa has the ability to inline decorators within functions before analyzing them so that it can catch such flows. This is currently an experimental feature hidden behind the ",(0,r.mdx)("inlineCode",{parentName:"p"},"--inline-decorators")," flag."),(0,r.mdx)("h2",{id:"prevent-inlining-decorators-with-skipdecoratorwheninlining"},"Prevent Inlining Decorators with ",(0,r.mdx)("inlineCode",{parentName:"h2"},"SkipDecoratorWhenInlining")),(0,r.mdx)("p",null,"Decorator inlining comes at the cost of increasing the analysis time and also increasing the lengths of traces. If you would like to prevent certain decorators from being inlined, you can mark them in your ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file using ",(0,r.mdx)("inlineCode",{parentName:"p"},"@SkipDecoratorWhenInlining"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# foo.pysa\n@SkipDecoratorWhenInlining\ndef foo.decorator_to_be_skipped(f): ...\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# foo.py\n@decorator_to_be_skipped\ndef bar(x: int) -> None:\n  pass\n")),(0,r.mdx)("p",null,"This will prevent the decorator from being inlined when analyzing ",(0,r.mdx)("inlineCode",{parentName:"p"},"bar"),". Note that we use ",(0,r.mdx)("inlineCode",{parentName:"p"},"@SkipDecoratorWhenInlining")," on the decorator that is to be skipped, not the function on which the decorator is applied."),(0,r.mdx)("h2",{id:"single-trace-sanitizers-with-sanitizesingletrace"},"Single trace sanitizers with ",(0,r.mdx)("inlineCode",{parentName:"h2"},"@SanitizeSingleTrace")),(0,r.mdx)("p",null,"Sanitizers, as described in the ",(0,r.mdx)("a",{parentName:"p",href:"/docs/pysa-basics"},"Overview"),", are applied in both\nthe forward (i.e source) trace and backward (i.e sink) trace."),(0,r.mdx)("p",null,"For instance, with the given ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," file:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@Sanitize(TaintInTaintOut[TaintSink[RemoteCodeExecution]])\ndef shlex.quote(x): ...\n")),(0,r.mdx)("p",null,"And the following Python code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"import subprocess\nfrom shlex import quote\n\ndef quoted_input():\n  x = input() # source 'UserControlled'\n  y = quote(x)\n  return y\n\ndef echo(argument):\n  subprocess.run(f'/bin/echo {argument}', shell=True) # sink 'RemoteCodeExecution'\n\ndef issue():\n  x = quoted_input() # source trace: input -> quoted_input -> issue\n  echo(x) # sink trace: issue -> echo -> subprocess.run\n")),(0,r.mdx)("p",null,"Pysa will NOT find an issue here, as expected.\nThis is because during the propagation of the 'UserControlled' source in the\nforward trace, pysa remembers that it was sanitized for the sink 'RemoteCodeExecution'."),(0,r.mdx)("p",null,"However, Pysa provides a simpler version of sanitizers, which only sanitizes in the\nforward trace or the backward trace:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"@SanitizeSingleTrace(TaintSource)\ndef f(): ...\n\n@SanitizeSingleTrace(TaintSource[UserControlled])\ndef g(): ...\n\n@SanitizeSingleTrace(TaintSink)\ndef h(): ...\n\n@SanitizeSingleTrace(TaintSink[RemoteCodeExecution])\ndef i(): ...\n")),(0,r.mdx)("p",null,"These sanitizers are a lot cheaper and could save analysis time. However, these\nmight introduce false positives, so we recommend to use the default sanitizers."),(0,r.mdx)("h2",{id:"taint-in-taint-out-transforms"},"Taint In Taint Out Transforms"),(0,r.mdx)("p",null,"Taint in taint out transforms can be used to capture more precise flows."),(0,r.mdx)("p",null,"As an example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'def read_file(path):\n  with open(path, "r") as f:\n    content = f.read()\n  return content\n')),(0,r.mdx)("p",null,"Without taint in taint transforms we can write a rule that captures a ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled")," path is ",(0,r.mdx)("inlineCode",{parentName:"p"},"read"),". Such a rule can be made much higher signal if we can detect that ",(0,r.mdx)("inlineCode",{parentName:"p"},"content")," is also ",(0,r.mdx)("inlineCode",{parentName:"p"},"ReturnedToUser"),". We can use taint in taint out transforms to stitch the two flows together. We mark ",(0,r.mdx)("inlineCode",{parentName:"p"},"read")," with a taint in taint out transform ",(0,r.mdx)("inlineCode",{parentName:"p"},"FileRead"),", and the rule becomes ",(0,r.mdx)("inlineCode",{parentName:"p"},"UserControlled -> FileRead -> ReturnedToUser"),"."),(0,r.mdx)("p",null,"To contrast with feature annotations, there are two differences:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"The filtering is done during analysis itself, and limits the issues generated (as opposed to a post-processing step by the user)"),(0,r.mdx)("li",{parentName:"ul"},"Taint in taint out transforms can be used to reason about the order of events")),(0,r.mdx)("h3",{id:"syntax"},"Syntax"),(0,r.mdx)("p",null,"In ",(0,r.mdx)("inlineCode",{parentName:"p"},"taint.config"),", one can specify ",(0,r.mdx)("inlineCode",{parentName:"p"},"transforms")," to define new transforms. Each transform is defined by following fields:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"name"),": name of the transform, this is used when defining rules, as well as writing models"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"comment"),": description of the transform")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'{\n  ...\n  "transforms": [\n    {\n      "name": "MyTransform",\n      "comment": "This is my transform"\n    },\n    ...\n  ],\n  ...\n}\n')),(0,r.mdx)("p",null,"Then, one may use these transforms in ",(0,r.mdx)("inlineCode",{parentName:"p"},"rules")," as follows:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},' {\n  ...\n  "rules": [\n    {\n      "name": ...,\n      "code": ...,\n      "sources": ["SourceA"],\n      "transforms": ["MyTransform1", "MyTransform2"],\n      "sinks": ["SinkB"],\n      "message_format": "[{$sources}] transformed by [${transforms}] may reach [${sinks}]"\n    },\n    ...\n  ],\n  ...\n}\n')),(0,r.mdx)("p",null,"Intuitively, one can think of the rule above as ",(0,r.mdx)("inlineCode",{parentName:"p"},"SourceA -> MyTransform1 -> MyTransform2 -> SinkB"),". The order is important."),(0,r.mdx)("p",null,"Finally, in ",(0,r.mdx)("inlineCode",{parentName:"p"},".pysa")," model files a taint transform can be specified using a ",(0,r.mdx)("inlineCode",{parentName:"p"},"TaintInTaintOut[Transform[...]]")," annotation, where the parameter is the name of the transform."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"def my_function(arg: TaintInTaintOut[Transform[MyTransform]]): ...\n")),(0,r.mdx)("h3",{id:"semantics"},"Semantics"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"  y = my_function(x)\n")),(0,r.mdx)("p",null,"If ",(0,r.mdx)("inlineCode",{parentName:"p"},"x")," has source taint ",(0,r.mdx)("inlineCode",{parentName:"p"},"SourceA"),", the taint of ",(0,r.mdx)("inlineCode",{parentName:"p"},"y")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"MyTransform:SourceA"),". This will correspond to matching ",(0,r.mdx)("inlineCode",{parentName:"p"},"SourceA -> MyTransform")," in a rule. Likewise, if ",(0,r.mdx)("inlineCode",{parentName:"p"},"y")," has sink taint ",(0,r.mdx)("inlineCode",{parentName:"p"},"SinkB"),", then the taint of ",(0,r.mdx)("inlineCode",{parentName:"p"},"x")," is ",(0,r.mdx)("inlineCode",{parentName:"p"},"MyTransorm:SinkB"),". This will correspond to matching ",(0,r.mdx)("inlineCode",{parentName:"p"},"MyTransform -> SinkB")," in a rule."),(0,r.mdx)("p",null,"Note that a transform modifies the taint itself. Hence, if a flow passes through a transform, it will no longer match rules which do not contain the transform."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"RuleX: SourceA -> SinkB\nRuleY: SourceA -> MyTransform -> SinkB\nFlow1: SourceA -> SinkB\nFlow2: SourceA -> MyTransform -> SinkB\n")),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"Flow1")," matches ",(0,r.mdx)("inlineCode",{parentName:"p"},"RuleX")," but not ",(0,r.mdx)("inlineCode",{parentName:"p"},"RuleY"),". ",(0,r.mdx)("inlineCode",{parentName:"p"},"Flow2")," matches ",(0,r.mdx)("inlineCode",{parentName:"p"},"RuleY")," but not ",(0,r.mdx)("inlineCode",{parentName:"p"},"RuleX"),"."),(0,r.mdx)("p",null,"Consider the scenario where we have an additional rule:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"RuleZ: SourceC -> SinkD\n")),(0,r.mdx)("p",null,"If transform ",(0,r.mdx)("inlineCode",{parentName:"p"},"MyTransform")," is applied to taint ",(0,r.mdx)("inlineCode",{parentName:"p"},"SourceC"),", there is no possible rule it can possibly match. As an optimization, we check for this continuously in our analysis and filter out eagerly."),(0,r.mdx)("p",null,"Also note that the existing TaintInTaintOut annotation semantics of TITO being assumed (instead of inferred) on the argument are unchanged."))}c.isMDXComponent=!0}}]);