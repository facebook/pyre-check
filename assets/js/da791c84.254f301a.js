"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[397],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>d,MDXProvider:()=>m,mdx:()=>f,useMDXComponents:()=>u,withMDXComponents:()=>p});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=a.createContext({}),p=function(e){return function(n){var t=u(n.components);return a.createElement(e,o({},n,{components:t}))}},u=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=u(e.components);return a.createElement(d.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=u(t),m=i,h=p["".concat(s,".").concat(m)]||p[m]||c[m]||o;return t?a.createElement(h,r(r({ref:n},d),{},{components:t})):a.createElement(h,r({ref:n},d))}));function f(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,s=new Array(o);s[0]=h;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var d=2;d<o;d++)s[d]=t[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},90610:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>r,contentTitle:()=>l,metadata:()=>d,toc:()=>p,default:()=>f});var a=t(87462),i=t(63366),o=(t(67294),t(3905)),s=["components"],r={id:"pysa-basics",title:"Overview",sidebar_label:"Overview"},l=void 0,d={unversionedId:"pysa-basics",id:"pysa-basics",isDocsHomePage:!1,title:"Overview",description:"Pyre has applications beyond type checking python code: it can also run static",source:"@site/docs/pysa_basics.md",sourceDirName:".",slug:"/pysa-basics",permalink:"/docs/pysa-basics",editUrl:"https://github.com/facebook/pyre-check/tree/main/documentation/website/docs/pysa_basics.md",tags:[],version:"current",frontMatter:{id:"pysa-basics",title:"Overview",sidebar_label:"Overview"},sidebar:"pysa",previous:{title:"Quickstart",permalink:"/docs/pysa-quickstart"},next:{title:"Feature Annotations",permalink:"/docs/pysa-features"}},p=[{value:"Taint Analysis",id:"taint-analysis",children:[]},{value:"Configuration",id:"configuration",children:[]},{value:"Sources",id:"sources",children:[]},{value:"Sinks",id:"sinks",children:[{value:"Implicit Sinks",id:"implicit-sinks",children:[]}]},{value:"Rules",id:"rules",children:[]},{value:"Sanitizers",id:"sanitizers",children:[]},{value:"Taint Propagation",id:"taint-propagation",children:[]},{value:"Features",id:"features",children:[]},{value:"Model files",id:"model-files",children:[{value:"Usage",id:"usage",children:[]},{value:"Requirements and Features",id:"requirements-and-features",children:[]}]},{value:"Next Steps",id:"next-steps",children:[]}],u=function(e){return function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.mdx)("div",n)}},m=u("Internal"),c=u("FbInternalOnly"),h={toc:p};function f(e){var n=e.components,t=(0,i.Z)(e,s);return(0,o.mdx)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Pyre has applications beyond type checking python code: it can also run static\nanalysis, more specifically called ",(0,o.mdx)("strong",{parentName:"p"},"Taint Analysis"),", to identify potential security issues.\nThe Python Static Analyzer feature of Pyre is usually abbreviated to Pysa\n(pronounced like the Leaning Tower of Pisa)."),(0,o.mdx)(m,{mdxType:"Internal"}),(0,o.mdx)("h2",{id:"taint-analysis"},"Taint Analysis"),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Tainted data")," is data that must be treated carefully. Pysa works by tracking\nflows of data from where they originate (sources) to where they terminate in a\ndangerous location (sinks). For example, we might use it to track flows where\nuser-controllable request data flows into an ",(0,o.mdx)("inlineCode",{parentName:"p"},"eval")," call, leading to a remote\ncode execution vulnerability. This analysis is made possible by user-created\nmodels which provide annotations on source code, as well as rules that define\nwhich sources are dangerous for which sinks. Pysa comes with many pre-written\nmodels and rules for builtin and common python libraries."),(0,o.mdx)("p",null,"Pysa propagates taint as operations are performed on tainted data. For example,\nif we start with a tainted integer and perform a number of operations on it, the\nend results will still be tainted:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x = some_function_that_returns_a_tainted_value() # 'x' is marked as tainted\ny = x + 10\ns = str(x)\nf = f\"Value = {s}\" # 'f' is marked with the same taint 'x' had\n")),(0,o.mdx)("p",null,"Pysa will only analyze the code in the repo that it runs on, as well as code in\ndirectories listed in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"search_path")," of your\n",(0,o.mdx)("a",{parentName:"p",href:"/docs/configuration"},(0,o.mdx)("inlineCode",{parentName:"a"},".pyre_configuration"))," file. It does not see the source of\nyour dependencies. ",(0,o.mdx)("strong",{parentName:"p"},"Just because")," ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("em",{parentName:"strong"},"you"))," ",(0,o.mdx)("strong",{parentName:"p"},"can see code in your editor\ndoes not mean Pysa has access to that code during analysis.")," Because of this\nlimitation, Pysa makes some simplifying assumptions. If taint flows into a\nfunction Pysa doesn't have the source for, it will assume that the return type\nof that function has the same taint. This helps prevents false negatives, but can\nalso lead to false positives."),(0,o.mdx)("p",null,"When an object is tainted, that means that all attributes of that object are\nalso tainted. Note that this is another source of potential false positives,\nsuch as taint flows that include ",(0,o.mdx)("inlineCode",{parentName:"p"},"some_obj.__class__"),". This means that Pysa\nwill detect all of the following flows:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"x = some_source() # 'x' is marked as tainted\n\nsome_sink(x) # This is detected\nsome_sink(x.some_attribute) # This is also detected\nsome_sink(x.__class__) # This is (unfortunately) also detected\n")),(0,o.mdx)("h2",{id:"configuration"},"Configuration"),(0,o.mdx)("p",null,"Pysa uses two types of files for configuration: a single ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," file,\nand an unlimited number of files with a ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," extension. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config"),"\nfile is a JSON document which stores definitions for ",(0,o.mdx)("em",{parentName:"p"},"sources"),", ",(0,o.mdx)("em",{parentName:"p"},"sinks"),", ",(0,o.mdx)("em",{parentName:"p"},"features"),",\nand ",(0,o.mdx)("em",{parentName:"p"},"rules")," (discussed below). The ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files are model files (also discussed\nbelow) which annotate your code with the ",(0,o.mdx)("em",{parentName:"p"},"sources"),", ",(0,o.mdx)("em",{parentName:"p"},"sinks"),", and ",(0,o.mdx)("em",{parentName:"p"},"features")," defined in\nyour ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," file. Examples of these files can be found in the ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/pyre-check/tree/main/stubs/taint"},"Pyre\nrepository"),"."),(0,o.mdx)("p",null,"These files live in the directory configured by ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint_models_path")," in your\n",(0,o.mdx)("inlineCode",{parentName:"p"},".pyre_configuration")," file. Any ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," file found in this folder will be parsed\nby Pysa and the models will be used during the analysis."),(0,o.mdx)("h2",{id:"sources"},"Sources"),(0,o.mdx)("p",null,"Sources are where tainted data originates. They are declared in your\n",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," file like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'"sources": [\n    {\n        "name": "Cookies",\n        "comment": "used to annotate cookie sources"\n    }\n]\n')),(0,o.mdx)("p",null,"Models that indicate what is a source are then defined in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa"),"\nfiles. Sources are declared with the same syntax as ",(0,o.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/library/typing.html"},"type annotations in Python\n3"),". Function return types,\nclass/model attributes, and even entire classes can be declared as sources by\nadding ",(0,o.mdx)("inlineCode",{parentName:"p"},"TaintSource[SOURCE_NAME]")," wherever you would add a python type:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# Function return source\ndef django.http.request.HttpRequest.get_signed_cookie(\n    self,\n    key,\n    default=...,\n    salt=...,\n    max_age=...\n) -> TaintSource[Cookies]: ...\n\n# Class attribute source:\ndjango.http.request.HttpRequest.COOKIES: TaintSource[Cookies]\n")),(0,o.mdx)("p",null,"When tainting an entire class, any return from a method or access of an\nattribute of the class will count as a returning tainted data. The specifics of\nthese model files are discussed further in the Models section."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# Class source:\nclass BaseException(TaintSource[Exception]): ...\n")),(0,o.mdx)("p",null,"When tainting indexable return types such as ",(0,o.mdx)("inlineCode",{parentName:"p"},"Dict"),"s, ",(0,o.mdx)("inlineCode",{parentName:"p"},"List"),"s, and ",(0,o.mdx)("inlineCode",{parentName:"p"},"Tuple"),"s, the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"AppliesTo")," syntax can be used to only mark a portion of the return type as\ntainted:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'def applies_to_index.only_applies_to_nested() -> AppliesTo[0, AppliesTo[1, TaintSource[Test]]]: ...\ndef applies_to_index.only_applies_to_a_key() -> AppliesTo["a", TaintSource[Test]]: ...\n')),(0,o.mdx)("p",null,"Note that ",(0,o.mdx)("inlineCode",{parentName:"p"},"AppliesTo")," syntax can also be applied to fields of classes and globals,\nwhich can be particularly helpful when annotating dictionaries."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},'# Source file: a.py\nclass C:\n    dictionary_field = {"text": "will_be_tainted"}\n\n# Model file: models.pysa\na.C.dictionary_field: AppliesTo["text", TaintSource[Test]]\n')),(0,o.mdx)("h2",{id:"sinks"},"Sinks"),(0,o.mdx)("p",null,"Sinks are where tainted data terminates. They are declared in your\n",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," file like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'"sinks": [\n  {\n    "name": "SQL",\n    "comment": "use to annotate places of SQL injection risk"\n  }\n]\n')),(0,o.mdx)("p",null,"Models that indicate what is a sink are then defined in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files. Sinks can\nbe added to the same files as sources. Like sources, sinks are declared with the\nsame syntax as ",(0,o.mdx)("a",{parentName:"p",href:"https://docs.python.org/3/library/typing.html"},"type annotations in Python\n3"),". Function parameters, class\nattributes, and even whole classes can be declared as sinks by adding\n",(0,o.mdx)("inlineCode",{parentName:"p"},"TaintSink[SINK_NAME]")," where you would add a python type:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# Function parameter sink\ndef sqlite3.dbapi2.Cursor.execute(self, sql: TaintSink[SQL], parameters): ...\n\n# Attribute sink\nfile_name.ClassName.attribute_name: TaintSink[RemoteCodeExecution]\n")),(0,o.mdx)("p",null,"When tainting an entire class, any flow into a method or attribute of the class\nwill count as a flow to a taint sink. The specifics of these model files are\ndiscussed further in the Models section."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# Entire class sink\nclass BaseException(TaintSink[Logging]): ...\n")),(0,o.mdx)("h3",{id:"implicit-sinks"},"Implicit Sinks"),(0,o.mdx)("p",null,"Implicit sinks are program expressions that we want to act as sinks, but that\ncannot be specified via taint signatures in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files.  Currently, only\nconditional tests are supported as implicit sinks. This allows writing rules\nthat track whether a particular source is used in a conditional test\nexpression."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'"implicit_sinks": {\n  "conditional_test": [ <your kind> ]\n}\n')),(0,o.mdx)("h2",{id:"rules"},"Rules"),(0,o.mdx)("p",null,"Rules declare which flows from source to sink we are concerned about. They are\ndeclared in your ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," file like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'"rules": [\n  {\n    "name": "SQL injection.",\n    "code": 1,\n    "sources": [ "UserControlled" ],\n    "sinks": [ "SQL" ],\n    "message_format": "Data from [{$sources}] source(s) may reach [{$sinks}] sink(s)"\n  }\n]\n')),(0,o.mdx)("p",null,"Each rule needs a brief ",(0,o.mdx)("inlineCode",{parentName:"p"},"name")," that explains its purpose and a ",(0,o.mdx)("em",{parentName:"p"},"unique")," ",(0,o.mdx)("inlineCode",{parentName:"p"},"code"),".\nThe rule must define a list of one or more ",(0,o.mdx)("inlineCode",{parentName:"p"},"sources"),", which we are concerned\nabout flowing into one or more ",(0,o.mdx)("inlineCode",{parentName:"p"},"sinks"),". ",(0,o.mdx)("inlineCode",{parentName:"p"},"message_format")," can further explain the\nissue. When a flow is detected the ",(0,o.mdx)("inlineCode",{parentName:"p"},"{$sources}")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"{$sinks}")," variables will be\nreplaced with the name of the specific source(s) and sink(s) that were involved\nin the detected flow."),(0,o.mdx)("h2",{id:"sanitizers"},"Sanitizers"),(0,o.mdx)("p",null,"Sanitizers break a taint flow by removing taint from data. Models that indicate\nsanitizing functions are defined in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files. Sanitizers can be added to\nthe same files as sources and sinks. Functions are declared as sanitizers by\nadding a special decorator:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# This will remove any taint passing through a function, regardless of whether\n# it is a taint source returned by this function, taint reaching sinks within\n# the function via 'argument', or taint propagateing through 'argument' to the\n# return value.\n@Sanitize\ndef django.utils.html.escape(text): ...\n")),(0,o.mdx)("p",null,"Sanitizers can also be scoped to only remove taint sources, sinks, or\ntaint-in-taint-out (TITO), rather than all taint that passes through the\nfunction. Understanding Pysa's ",(0,o.mdx)("a",{parentName:"p",href:"/docs/pysa-implementation-details"},"implementation\ndetails")," will help you better pick whether to\nsanitize sources, sinks, or TITO :"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# This will remove any taint sources returned by this function, but allow taint\n# to reach sinks within the function via 'argument' as well as allow taint to\n# propagate through 'argument' to the return value.\n@Sanitize(TaintSource)\ndef module.sanitize_source(argument): ...\n\n# This remove any taint which passes through 'argument' to reach a sink within\n# the function, but allow taint sources to be returned from the function as well\n# as allow taint to propagate through 'argument' to the return value.\n@Sanitize(TaintSink)\ndef module.sanitize_sink(argument): ...\n\n# This will remove any taint which propagates through 'argument' to the return\n# value, but allow taint sources to be returned from the function as well as\n# allow taint to reach sinks within the function via 'argument'.\n@Sanitize(TaintInTaintOut)\ndef module.sanitize_tito(argument): ...\n")),(0,o.mdx)("p",null,"For source and sink sanitizers, Pysa also supports only sanitizing specific kinds of\ntaint to ensure that the sanitizers used for a rule don't have adverse effects on other\nrules. The syntax used is identical to how taint sources and sinks are specified normally:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# Sanitizes only the `UserControlled` source kind.\n@Sanitize(TaintSource[UserControlled])\ndef module.return_not_user_controlled(): ...\n\n# Sanitizes both the `SQL` and `Logging` sinks.\n@Sanitize(TaintSink[SQL, Logging])\ndef module.sanitizes_sql_and_logging_sinks(flows_to_sql, logged_parameter): ...\n")),(0,o.mdx)("p",null,"For TITO sanitizers, Pysa supports only sanitizing specific sources and sinks through TITO:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"# With this annotation, whenever `escape(data)` is called, the UserControlled taint of `data`\n# will be sanitized, whereas other taint that might be present on `data` will be preserved.\n@Sanitize(TaintInTaintOut[TaintSource[UserControlled]])\ndef django.utils.html.escape(text: TaintInTaintOut): ...\n\n@Sanitize(TaintInTaintOut[TaintSink[SQL, Logging]])\ndef module.sanitize_for_logging_and_sql(): ...\n")),(0,o.mdx)("p",null,"Specific parameters can be marked as sanitized to remove all taint passing through them:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def module.safe_function(\n  foo: Sanitize,\n  foo: Sanitize[TaintSink],\n  foo: Sanitize[TaintSink[SQL]],\n  foo: Sanitize[TaintInTaintOut],\n  foo: Sanitize[TaintInTaintOut[TaintSink[SQL]]],\n  foo: Sanitize[TaintInTaintOut[TaintSource[UserControlled]]],\n): ...\n")),(0,o.mdx)("p",null,"Similarly, the return value can be marked as sanitized:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def modules.safe_return() -> Sanitize: ...\ndef modules.safe_return_source() -> Sanitize[TaintSource]: ...\ndef modules.return_not_user_controlled() -> Sanitize[TaintSource[UserControlled]]: ...\n")),(0,o.mdx)("p",null,"All parameters can be marked as sanitized as well:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"@Sanitize(Parameters)\ndef module.sanitize_all_parameters(): ...\n\n@Sanitize(Parameters[TaintSource[UserControlled]))\ndef module.parameters_not_user_controlled(): ...\n\n@Sanitize(Parameters[TaintInTaintOut[TaintSource[UserControlled], TaintSink[SQL]]]))\ndef module.parameters_not_taint_in_taint_out(): ...\n")),(0,o.mdx)("p",null,"Attributes can also be marked as sanitizers to remove all taint passing through\nthem:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"django.http.request.HttpRequest.GET: Sanitize\n")),(0,o.mdx)("p",null,"Sanitizing specific sources and sinks can also be used with attributes:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def module.Node.id: Sanitize[TaintSource[UserSecrets]] = ...\ndef module.Node.id: Sanitize[TaintSink[Logging]] = ...\n")),(0,o.mdx)("p",null,"This annotation is useful in the case of explicit sanitizers such as ",(0,o.mdx)("inlineCode",{parentName:"p"},"escape"),",\nwhich helps prevent cross site scripting (XSS) by escaping HTML characters. The\nannotation is also useful, however, in cases where a function is not intended to\nsanitize inputs, but is known to always return safe data despite touching\ntainted data. One such example could be ",(0,o.mdx)("inlineCode",{parentName:"p"},"hmac.digest(key, msg, digest)"),", which\nreturns sufficiently unpredictable data that the output should no longer be\nconsidered attacker-controlled after passing through."),(0,o.mdx)("p",null,"Note that sanitizers come with the risk of losing legitimate taint flows.\nThey remove all taint and aren't restricted to a specific rule or\nindividual source to sink flows. This means you need to ensure you aren't\npotentially affecting other flows when you add a sanitizer for a flow you care\nabout. For this reason, the above sanitizer examples might not be a good idea\nto use. If you are trying to track flows where SQL injection occurs, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"escape"),"\nsanitizer would prevent you from seeing any flows where data going into your\nSQL query happened to be HTML escaped."),(0,o.mdx)("p",null,"The best practice with sanitizers, then, is to make them as specific as possible.\nIt's recommended to sanitize specific sources and sinks over using the general\n@Sanitize annotation."),(0,o.mdx)("h2",{id:"taint-propagation"},"Taint Propagation"),(0,o.mdx)("p",null,"Sometimes the features discussed in the Taint Analysis section are not enough to\ndetect all taint flows. In particular, Pysa relies on additional annotations to\nhelp it understand when an object is tainted via a function call or when a\nfunction call on a tainted object returns tainted data. Taint propagation is\ndefined by adding ",(0,o.mdx)("inlineCode",{parentName:"p"},"TaintInTaintOut")," annotations to models in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files."),(0,o.mdx)("p",null,"When a function call taints an object, such as when you update a dictionary with\na tainted value, Pysa needs a ",(0,o.mdx)("inlineCode",{parentName:"p"},"TaintInTaintOut")," annotation that indicates\n",(0,o.mdx)("inlineCode",{parentName:"p"},"Updates[self]"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def dict.update(self, __m: TaintInTaintOut[Updates[self]]): ...\n")),(0,o.mdx)("p",null,"When a function call on a tainted object returns taint, such as when you\nretrieve a value from a dictionary, Pysa needs a ",(0,o.mdx)("inlineCode",{parentName:"p"},"TaintInTaintOut")," annotation\nthat indicates ",(0,o.mdx)("inlineCode",{parentName:"p"},"LocalReturn"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def dict.get(self: TaintInTaintOut[LocalReturn], key, default): ...\n")),(0,o.mdx)("h2",{id:"features"},"Features"),(0,o.mdx)("p",null,"Feature annotations are also placed in your ",(0,o.mdx)("inlineCode",{parentName:"p"},"taint.config")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files.\nThis is a larger topic and will be covered in detail on ",(0,o.mdx)("a",{parentName:"p",href:"/docs/pysa-features"},"its own page"),"."),(0,o.mdx)("h2",{id:"model-files"},"Model files"),(0,o.mdx)("h3",{id:"usage"},"Usage"),(0,o.mdx)("p",null,"By default, Pysa computes an inferred model for each function and combines it\nwith any declared models in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files (of which there can be more than one).\nThe union of these models and their annotations will be used. For example,\ncookies are both user controlled and potentially sensitive to log, and Pysa\nallows us apply two different annotations to them:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"django.http.request.HttpRequest.COOKIES: TaintSource[UserControlled]\ndjango.http.request.HttpRequest.COOKIES: TaintSource[Cookies]\n")),(0,o.mdx)("h3",{id:"requirements-and-features"},"Requirements and Features"),(0,o.mdx)("h4",{id:"fully-qualified-names"},"Fully qualified names"),(0,o.mdx)("p",null,"Any declarations in ",(0,o.mdx)("inlineCode",{parentName:"p"},".pysa")," files must use the fully qualified name for the\nfunction/attribute they are attempting to annotate. You can usually find the\nfully qualified name for a type by looking at how it is imported, however, it's\nimportant to note that fully qualified names correspond to where something is\ndeclared, not necessarily where it is imported from. For example, you can import\n",(0,o.mdx)("inlineCode",{parentName:"p"},"HttpRequest")," directly from the ",(0,o.mdx)("inlineCode",{parentName:"p"},"django.http")," module, even though it is defined in\n",(0,o.mdx)("inlineCode",{parentName:"p"},"django.http.request"),". If you wanted to taint an attribute of ",(0,o.mdx)("inlineCode",{parentName:"p"},"HttpRequest"),",\nyou would need to use the module in which it was defined:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"django.http.request.HttpRequest.GET: TaintSource[UserControlled]\n")),(0,o.mdx)("h4",{id:"matching-signatures"},"Matching signatures"),(0,o.mdx)("p",null,"The signature of any modeled function needs to match the signature of the\nfunction, as seen by Pyre. Note that Pyre doesn't always see the definition of\nthe of the functions directly. If ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0484/#stub-files"},(0,o.mdx)("inlineCode",{parentName:"a"},".pyi")," stub\nfiles")," are present, Pyre\nwill use the signatures from those files, rather than the actual signature from\nthe function definition in your or your dependencies' code. See the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/types-in-python"},"Gradual\nTyping page")," for more info about these ",(0,o.mdx)("inlineCode",{parentName:"p"},".pyi")," stubs."),(0,o.mdx)("p",null,"This matching signature requirement means that all parameters being modelled must\nbe named identically to the parameters in the corresponding code or ",(0,o.mdx)("inlineCode",{parentName:"p"},".pyi")," file.\nUnmodelled parameters, ",(0,o.mdx)("inlineCode",{parentName:"p"},"*args"),", and ",(0,o.mdx)("inlineCode",{parentName:"p"},"**kwargs")," may be included, but\nare not required. When copying parameters to your model, all type information\nmust be removed, and all default values must be elided (see below)."),(0,o.mdx)("p",null,"If a function includes an ",(0,o.mdx)("inlineCode",{parentName:"p"},"*")," that indicates ",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-3102/"},"keyword only\nparameters"),", or a ",(0,o.mdx)("inlineCode",{parentName:"p"},"/")," that indicates\n",(0,o.mdx)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0570/"},"positional-only parameters"),", then\nthat may be included in your model. Note that unlike when modeling named parameters,\nyou need to include all positional only parameters the model so that Pysa knows what\nposition is being tainted."),(0,o.mdx)("p",null,"For example, ",(0,o.mdx)("inlineCode",{parentName:"p"},"urllib.request.urlopen")," has the following signature:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, *, cafile=None,\n            capath=None, cadefault=False, context=None):\n")),(0,o.mdx)("p",null,"Given that signature, either of the following models are acceptable:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def urllib.request.urlopen(url: TaintSink[RequestSend], data,\n                           timeout, *, cafile, capath,\n                           cadefault, context): ...\ndef urllib.request.urlopen(url: TaintSink[RequestSend]): ...\n")),(0,o.mdx)("p",null,"Pysa will complain if the signature of your model doesn't match the\nimplementation. When working with functions defined outside your project, where\nyou don't directly see the source, you can use ",(0,o.mdx)("a",{parentName:"p",href:"/docs/querying-pyre"},(0,o.mdx)("inlineCode",{parentName:"a"},"pyre query")),"\nwith the ",(0,o.mdx)("inlineCode",{parentName:"p"},"signature")," argument to have Pysa dump it's internal model of a\nfunction, so you know exactly how to write your model."),(0,o.mdx)("h4",{id:"eliding"},"Eliding"),(0,o.mdx)("p",null,"As you can see from the above examples, unmodelled parameters and function bodies can\nboth be elided with ",(0,o.mdx)("inlineCode",{parentName:"p"},"..."),". Additionally, type annotations ",(0,o.mdx)("em",{parentName:"p"},"must")," be entirely\nomitted (not replaced with ",(0,o.mdx)("inlineCode",{parentName:"p"},"..."),"), even when present on the declaration of the\nfunction. This is done to make parsing taint annotations unambiguous."),(0,o.mdx)(c,{mdxType:"FbInternalOnly"},(0,o.mdx)("h2",{id:"next-steps"},"Next Steps"),(0,o.mdx)("p",null,"Ready to start writing some models? Check out our docs on the\n",(0,o.mdx)("a",{parentName:"p",href:"fb/pysa_shipping_rules_models_internal.md"},"end-to-end process of shipping pysa models."))))}f.isMDXComponent=!0}}]);