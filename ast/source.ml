(** Copyright (c) 2016-present, Facebook, Inc.

    This source code is licensed under the MIT license found in the
    LICENSE file in the root directory of this source tree. *)

open Core

open Expression


type mode =
  | Default
  | Declare
  | Strict
  | Infer
  | PlaceholderStub
[@@deriving compare, eq, show, sexp, hash]


module Metadata = struct

  type t = {
    autogenerated: bool;
    debug: bool;
    local_mode: mode;
    ignore_lines: Ignore.t list;
    number_of_lines: int;
    version: int;
  }
  [@@deriving compare, eq, show, hash]

  let create
      ?(autogenerated = false)
      ?(debug = true)
      ?(declare = false)
      ?(ignore_lines = [])
      ?(strict = false)
      ?(version = 3)
      ~number_of_lines
      () =
    let local_mode =
      if declare then
        Declare
      else if strict then
        Strict
      else
        Default
    in
    {
      autogenerated;
      debug;
      local_mode;
      ignore_lines;
      number_of_lines;
      version;
    }

  let parse path lines =
    let is_python_2_shebang line =
      String.is_prefix ~prefix:"#!" line &&
      String.is_substring ~substring:"python2" line
    in
    let is_pyre_comment comment_substring line =
      String.is_prefix ~prefix:"#" line &&
      String.is_substring ~substring:comment_substring line
    in
    let is_debug = is_pyre_comment "pyre-debug" in
    let is_strict = is_pyre_comment "pyre-strict" in
    let is_declare = is_pyre_comment "pyre-do-not-check" in
    let is_placeholder_stub = is_pyre_comment "pyre-placeholder-stub" in
    let parse_ignore index line ignored_lines =
      let create_ignore ~index ~line ~kind =
        let codes =
          try
            Str.search_forward
              (Str.regexp "pyre-\\(ignore\\|fixme\\)\\[\\([0-9, ]+\\)\\]")
              line
              0
            |> ignore;
            Str.matched_group 2 line
            |> Str.split (Str.regexp "[^0-9]+")
            |> List.map ~f:Int.of_string
          with Not_found -> []
        in
        let ignored_line =
          if String.is_prefix ~prefix:"#" (String.strip line) then
            index + 2
          else
            index + 1
        in
        let location =
          let start_column =
            Str.search_forward (Str.regexp "\\(pyre-\\(ignore\\|fixme\\)\\|type: ignore\\)") line 0
          in
          let end_column = String.length line in
          let start = { Location.line = index + 1; column = start_column } in
          let stop = { Location.line = index + 1; column = end_column } in
          Location.reference { Location.path; start; stop }
        in
        Ignore.create ~ignored_line ~codes ~location ~kind
      in
      let contains_outside_quotes ~substring line =
        let find_substring index found characters =
          found || (String.is_substring ~substring characters && index mod 2 = 0)
        in
        String.split_on_chars ~on:['\"'; '\''] line
        |> List.foldi ~init:false ~f:find_substring
      in
      if contains_outside_quotes ~substring:"pyre-ignore" line then
        (create_ignore ~index ~line ~kind:Ignore.PyreIgnore) :: ignored_lines
      else if contains_outside_quotes ~substring:"pyre-fixme" line then
        (create_ignore ~index ~line ~kind:Ignore.PyreFixme) :: ignored_lines
      else if contains_outside_quotes ~substring:"type: ignore" line then
        (create_ignore ~index ~line ~kind:Ignore.TypeIgnore) :: ignored_lines
      else
        ignored_lines
    in
    let is_autogenerated line =
      String.is_substring ~substring:("@" ^ "generated") line ||
      String.is_substring ~substring:("@" ^ "auto-generated") line
    in

    let collect
        index
        (version, debug, local_mode, ignored_lines, autogenerated)
        line =
      let local_mode =
        match local_mode with
        | Some _ ->
            local_mode
        | None ->
            if is_declare line then
              Some Declare
            else if is_strict line then
              Some Strict
            else if is_placeholder_stub line then
              Some PlaceholderStub
            else
              None
      in
      let version =
        match version with
        | Some _ ->
            version
        | None ->
            if is_python_2_shebang line then Some 2 else None
      in
      version,
      debug || is_debug line,
      local_mode,
      parse_ignore index line ignored_lines,
      autogenerated || is_autogenerated line
    in
    let version, debug, local_mode, ignore_lines, autogenerated =
      List.map ~f:(fun line -> String.strip line |> String.lowercase) lines
      |> List.foldi ~init:(None, false, None, [], false) ~f:collect
    in
    let local_mode = Option.value local_mode ~default:Default in
    {
      autogenerated;
      debug;
      local_mode;
      ignore_lines;
      number_of_lines = List.length lines;
      version = Option.value ~default:3 version;
    }
end


type t = {
  docstring: string option;
  metadata: Metadata.t;
  path: string;
  qualifier: Access.t;
  statements: Statement.t list;
}
[@@deriving compare, eq, show]


let mode source ~configuration =
  match configuration, source with
  | { Configuration.infer = true; _ }, _ ->
      Infer

  | { Configuration.strict = true; _ }, _
  | _, { metadata = { Metadata.local_mode = Strict; _ }; _ } ->
      Strict

  | { Configuration.declare = true; _ }, _
  | _, { metadata = { Metadata.local_mode = Declare; _ }; _ } ->
      Declare

  | _ ->
      Default


let create
    ?(docstring = None)
    ?(metadata = Metadata.create ~number_of_lines:(-1) ())
    ?(path = "")
    ?(qualifier = [])
    statements =
  {
    docstring;
    metadata;
    path;
    qualifier;
    statements;
  }


let binary_interface_hash { metadata; _ } =
  [%hash: Metadata.t] (metadata)


let ignore_lines { metadata = { Metadata.ignore_lines; _ }; _ } =
  ignore_lines


let statements { statements; _ } =
  statements


let qualifier ~path =
  let qualifier =
    let reversed_elements =
      Filename.parts path
      |> List.tl_exn (* Strip current directory. *)
      |> List.rev in
    let last_without_suffix =
      let last = List.hd_exn reversed_elements in
      match String.rindex last '.' with
      | Some index ->
          String.slice last 0 index
      | _ ->
          last in
    let strip = function
      | "builtins" :: tail ->
          tail
      | "__init__" :: tail ->
          tail
      | elements ->
          elements in
    (last_without_suffix :: (List.tl_exn reversed_elements))
    |> strip
    |> List.rev_map
      ~f:Access.create
    |> List.concat
  in
  if String.is_suffix ~suffix:".pyi" path then
    (* Drop version from qualifier. *)
    let is_digit qualifier =
      try
        qualifier
        |> Int.of_string
        |> ignore;
        true
      with _ ->
        false
    in
    begin
      match qualifier with
      | minor :: major :: tail
        when is_digit (Access.show [minor]) &&
             is_digit (Access.show [major]) ->
          tail
      | major :: tail when is_digit (String.prefix (Access.show [major]) 1) ->
          tail
      | qualifier ->
          qualifier
    end
  else
    qualifier


let expand_relative_import ?path ~qualifier ~from =
  match Access.show from with
  | "builtins" ->
      []
  | serialized ->
      (* Expand relative imports according to PEP 328 *)
      let dots = String.take_while ~f:(fun dot -> dot = '.') serialized in
      let postfix =
        match String.drop_prefix serialized (String.length dots) with
        (* Special case for single `.`, `..`, etc. in from clause. *)
        | "" -> []
        | nonempty -> Access.create nonempty
      in
      let prefix =
        if not (String.is_empty dots) then
          let initializer_module_offset =
            match path with
            | Some path ->
                (* `.` corresponds to the directory containing the module. For non-init modules, the
                   qualifier matches the path, so we drop exactly the number of dots. However, for
                   __init__ modules, the directory containing it represented by the qualifier. *)
                if String.is_suffix path ~suffix:"/__init__.py"
                || String.is_suffix path ~suffix:"/__init__.pyi" then
                  1
                else
                  0
            | None ->
                0
          in
          List.rev qualifier
          |> (fun reversed -> List.drop reversed (String.length dots - initializer_module_offset))
          |> List.rev
        else
          []
      in
      prefix @ postfix
