(** Copyright (c) 2016-present, Facebook, Inc.

    This source code is licensed under the MIT license found in the
    LICENSE file in the root directory of this source tree. *)

open Core

open Expression


module Metadata = struct
  type t = {
    autogenerated: bool;
    debug: bool;
    declare: bool;
    ignore_lines: (int * int list) list;
    strict: bool;
    version: int;
  }
  [@@deriving compare, eq, show]

  let create
      ?(autogenerated = false)
      ?(debug = true)
      ?(declare = false)
      ?(ignore_lines = [])
      ?(strict = false)
      ?(version = 3)
      () =
    {
      autogenerated;
      debug;
      declare;
      ignore_lines;
      strict;
      version;
    }

  let parse lines =
    let is_python_2_shebang line =
      String.is_prefix ~prefix:"#!" line &&
      String.is_substring ~substring:"python2" line
    in
    let is_debug line =
      String.is_prefix ~prefix:"#" line &&
      String.is_substring ~substring:"pyre-debug" line
    in
    let is_strict line =
      String.is_prefix ~prefix:"#" line &&
      String.is_substring ~substring:"pyre-strict" line
    in
    let is_declare line =
      String.is_prefix ~prefix:"#" line &&
      (String.is_substring ~substring:"pyre-declare-but-dont-check" line ||
       String.is_substring ~substring:"pyre-declare-but-don't-check" line)
    in
    let parse_ignore index line ignored_lines =
      if String.is_substring ~substring:"pyre-ignore" line ||
         String.is_substring ~substring:"pyre-fixme" line ||
         String.is_substring ~substring:"type: ignore" line then
        let codes =
          try
            Str.search_forward (Str.regexp "pyre-\\(ignore\\|fixme\\)\\[\\(.*\\)\\]") line 0
            |> ignore;
            Str.matched_group 2 line
            |> Str.split (Str.regexp "[^0-9]+")
            |> List.map ~f:Int.of_string
          with
            Not_found -> []
        in
        let ignored_line =
          if String.is_prefix ~prefix:"#" (String.strip line) then
            index + 2
          else
            index + 1
        in
        (ignored_line, codes) :: ignored_lines
      else
        ignored_lines
    in
    let is_autogenerated line =
      String.is_substring ~substring:("@" ^ "generated") line ||
      String.is_substring ~substring:("@" ^ "auto-generated") line
    in

    let collect index (version, debug, strict, declare, ignored_lines, autogenerated) line =
      let version =
        match version with
        | Some _ ->
            version
        | None ->
            if is_python_2_shebang line then Some 2 else None in
      version,
      debug || is_debug line,
      strict || is_strict line,
      declare || is_declare line,
      parse_ignore index line ignored_lines,
      autogenerated || is_autogenerated line
    in
    let version, debug, strict, declare, ignore_lines, autogenerated =
      List.map ~f:(fun line -> String.strip line |> String.lowercase) lines
      |> List.foldi ~init:(None, false, false, false, [], false) ~f:collect
    in
    {
      autogenerated;
      debug;
      declare;
      ignore_lines;
      strict;
      version = Option.value ~default:3 version;
    }
end


type t = {
  docstring: string option;
  metadata: Metadata.t;
  path: string;
  qualifier: Expression.t Record.Access.t;
  statements: Statement.t list;
}
[@@deriving compare, eq, show]


let create
    ?(docstring = None)
    ?(metadata = Metadata.create ())
    ?(path = "")
    ?(qualifier = [])
    statements =
  {
    docstring;
    metadata;
    path;
    qualifier;
    statements;
  }


let ignore_lines { metadata = { Metadata.ignore_lines; _ }; _ } =
  ignore_lines


let qualifier ~path =
  let reversed_elements =
    Filename.parts path
    |> List.tl_exn (* Strip current directory. *)
    |> List.rev in
  let last_without_suffix =
    let last = List.hd_exn reversed_elements in
    match String.rindex last '.' with
    | Some index ->
        String.slice last 0 index
    | _ ->
        last in
  let strip = function
    | "builtins" :: tail ->
        tail
    | "__init__" :: tail ->
        tail
    | elements ->
        elements in
  (last_without_suffix :: (List.tl_exn reversed_elements))
  |> strip
  |> List.rev_map
    ~f:Access.create
  |> List.concat
