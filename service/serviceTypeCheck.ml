(** Copyright (c) 2016-present, Facebook, Inc.

    This source code is licensed under the MIT license found in the
    LICENSE file in the root directory of this source tree. *)

open Core

open Ast
open Analysis
open Pyre

module Scheduler = ServiceScheduler
module AstSharedMemory = ServiceAstSharedMemory


type analysis_results = {
  errors: Error.t list;
  lookups: Lookup.t String.Map.t;
  number_files: int;
  type_coverage: TypeCheck.Coverage.t;
}


let process_ignores environment handles errors =
  let module Reader = (val environment : Environment.Handler) in
  let paths_from_handles =
    let get_path paths handle =
      match AstSharedMemory.get_source handle with
      | Some { Source.path; _ } ->
          path :: paths
      | _ -> paths
    in
    List.fold ~init:[] ~f:get_path
  in
  let error_lookup = Location.Table.create () in
  let add_to_lookup ~key ~code =
    match Hashtbl.find error_lookup key with
    | Some codes -> Hashtbl.set ~key ~data:(code :: codes) error_lookup
    | _ -> Hashtbl.set ~key ~data:[code] error_lookup
  in
  List.iter
    ~f:(fun error ->
        add_to_lookup
          ~key:(Location.start_line (Error.location error) (Location.line (Error.location error)))
          ~code:(Error.code error))
    errors;
  let errors_with_ignore_suppression =
    let not_ignored error =
      Reader.ignore_lines
        (Location.start_line (Error.location error) (Location.line (Error.location error)))
      >>| (fun ignore_instance ->
          not (List.is_empty (Source.Ignore.codes ignore_instance) ||
               List.mem ~equal:(=) (Source.Ignore.codes ignore_instance) (Error.code error))
        )
      |> Option.value ~default:true
    in
    List.filter ~f:not_ignored errors
  in
  let unused_ignores =
    let get_unused_ignores sofar path =
      let ignores =
        let key_to_ignores sofar key =
          match Reader.ignore_lines key with
          | Some ignore -> ignore :: sofar
          | _ -> sofar
        in
        List.fold ~init:[] ~f:key_to_ignores (Reader.DependencyHandler.get_ignore_keys ~path)
      in
      let unused_ignores =
        let filter_active_ignores sofar ignore =
          match Source.Ignore.kind ignore with
          | Source.Ignore.TypeIgnore -> sofar
          | _ ->
              let key =
                Location.start_line
                  (Source.Ignore.location ignore)
                  (Source.Ignore.ignored_line ignore)
              in
              begin
                match Hashtbl.find error_lookup key with
                | Some codes ->
                    let unused_codes =
                      let find_unused sofar code =
                        if List.mem ~equal:(=) codes code then sofar else code :: sofar
                      in
                      List.fold ~init:[] ~f:find_unused (Source.Ignore.codes ignore)
                    in
                    if List.is_empty (Source.Ignore.codes ignore) || List.is_empty unused_codes then
                      sofar
                    else
                      { ignore with Source.Ignore.codes = unused_codes } :: sofar
                | _ -> ignore :: sofar
              end
        in
        List.fold ~init:[] ~f:filter_active_ignores ignores
      in
      sofar @ unused_ignores
    in
    List.fold ~init:[] ~f:get_unused_ignores (paths_from_handles handles)
  in
  let errors_with_unused_ignores =
    let create_unused_ignore_error errors unused_ignore =
      let placeholder_define =
        {
          Statement.Define.name = Expression.Access.create "";
          parameters = [];
          body = [];
          decorators = [];
          docstring = None;
          return_annotation = None;
          async = false;
          generated = false;
          parent = None;
        }
      in
      let error =
        {
          Error.location = Source.Ignore.location unused_ignore;
          kind = Error.UnusedIgnore {
              Error.unused_error_codes = Source.Ignore.codes unused_ignore;
            };
          define = {
            Node.location = Source.Ignore.location unused_ignore;
            value = placeholder_define
          };
        }
      in
      error :: errors
    in
    List.fold ~init:errors_with_ignore_suppression ~f:create_unused_ignore_error unused_ignores
  in
  errors_with_unused_ignores


let analyze_source
    ({ Configuration.verbose; sections; _ } as configuration)
    environment
    ({ Source.path; metadata; _ } as source) =
  (* Re-initialize log for subprocesses. *)
  Log.initialize ~verbose ~sections;

  (* Override file-specific local debug configuraiton *)
  let { Source.Metadata.autogenerated; declare; debug; strict; version; _ } = metadata in
  let configuration =
    Configuration.localize
      configuration
      ~local_debug:debug
      ~local_strict:strict
      ~declare
  in

  if version < 3 || autogenerated then
    begin
      Log.log
        ~section:`Check
        "Skipping `%s` (%s)"
        path
        (if autogenerated then "auto-generated" else "Python 2.x");
      { TypeCheck.errors = []; lookup = None; type_coverage = TypeCheck.Coverage.create_empty; }
    end
  else
    begin
      let timer = Timer.start () in
      Log.log ~section:`Check "Checking `%s`..." path;
      let errors = TypeCheck.check configuration environment source in
      Statistics.performance
        ~flush:false
        ~randomly_log_every:100
        ~section:`Check
        ~name:(Format.asprintf "SingleFileTypeCheck of %s" path)
        ~timer
        ~normals:["path", path; "request kind", "SingleFileTypeCheck"]
        ~configuration
        ();
      errors
    end


let analyze_sources_parallel
    scheduler
    ({Configuration.source_root; project_root = directory; _ } as configuration)
    environment
    handles =
  let merge_lookups ~key:_ = function
    | `Both (lookup, _) -> Some lookup
    | `Left lookup -> Some lookup
    | `Right lookup -> Some lookup
  in
  let init = {
    errors = [];
    lookups = String.Map.empty;
    number_files = 0;
    type_coverage = TypeCheck.Coverage.create_empty;
  }
  in
  let handles =
    handles
    |> List.filter ~f:(fun handle ->
        match AstSharedMemory.get_source handle with
        | Some { Source.path; _ } ->
            Path.create_relative ~root:source_root ~relative:path
            |> Path.directory_contains ~follow_symlinks:true ~directory
        | _ ->
            false)
  in
  handles
  |> Scheduler.map_reduce
    scheduler
    ~init:
      {
        errors = [];
        lookups = String.Map.empty;
        number_files = 0;
        type_coverage = TypeCheck.Coverage.create_empty;
      }
    ~map:(fun _ handles ->
        let result =
          List.fold ~init ~f:(
            fun { errors; lookups; number_files; type_coverage = total_type_coverage } handle ->
              match AstSharedMemory.get_source handle with
              | Some source ->
                  let { TypeCheck.errors = new_errors; lookup; type_coverage; } =
                    analyze_source configuration environment source
                  in
                  {
                    errors = List.append new_errors errors;
                    lookups =
                      begin
                        match lookup with
                        | Some table ->
                            Map.set ~key:(File.Handle.show handle) ~data:table lookups
                        | None ->
                            lookups
                      end;
                    number_files = number_files + 1;
                    type_coverage = TypeCheck.Coverage.sum total_type_coverage type_coverage;
                  }
              | None -> {
                  errors;
                  lookups;
                  number_files = number_files + 1;
                  type_coverage = total_type_coverage;
                })
            handles
        in
        Statistics.flush ();
        result)
    ~reduce:(fun left right ->
        let number_files = left.number_files + right.number_files in
        Log.info "Processed %d of %d sources" number_files (List.length handles);
        {
          errors = List.append left.errors right.errors;
          lookups = Map.merge ~f:merge_lookups left.lookups right.lookups;
          number_files;
          type_coverage = TypeCheck.Coverage.sum left.type_coverage right.type_coverage;
        })
  |> (fun { errors; lookups; type_coverage; _ } ->
      (process_ignores environment handles errors, lookups, type_coverage))


let analyze_sources
    scheduler
    ?(repopulate_handles = [])
    ({Configuration.source_root; project_root = directory; _ } as configuration)
    environment
    handles =
  Log.info "Checking...";
  Annotated.Class.AttributesCache.clear ();
  ServiceEnvironment.repopulate
    environment
    ~configuration
    ~handles:repopulate_handles;
  match Scheduler.is_parallel scheduler with
  | true ->
      analyze_sources_parallel scheduler configuration environment handles
  | false ->
      let get_sources =
        List.fold
          ~init:[]
          ~f:(fun sources path ->
              match AstSharedMemory.get_source path with
              | Some ({ Source.path; _ } as source) ->
                  if Path.create_relative ~root:source_root ~relative:path
                     |> Path.directory_contains ~follow_symlinks:true ~directory then
                    source::sources
                  else
                    sources
              | _ -> sources)
      in
      let sources = get_sources handles in
      let analyze_and_postprocess
          configuration
          environment
          (current_errors, lookups, total_type_coverage)
          source =
        let { TypeCheck.errors; lookup; type_coverage; } =
          analyze_source configuration environment source
        in
        (errors :: current_errors,
         begin
           match lookup with
           | None -> lookups
           | Some lookup -> String.Map.set ~key:source.Source.path ~data:lookup lookups
         end,
         (TypeCheck.Coverage.sum total_type_coverage type_coverage))
      in
      List.fold
        ~init:([], String.Map.empty, TypeCheck.Coverage.create_empty)
        ~f:(analyze_and_postprocess configuration environment)
        sources
      |> (fun (error_list, lookups, type_coverage) ->
          List.concat error_list, lookups, type_coverage)
      |> (fun (errors, lookups, type_coverage) ->
          process_ignores environment handles errors, lookups, type_coverage)
