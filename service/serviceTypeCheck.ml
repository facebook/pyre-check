(** Copyright (c) 2016-present, Facebook, Inc.

    This source code is licensed under the MIT license found in the
    LICENSE file in the root directory of this source tree. *)

open Core

open Ast
open Analysis
open Pyre

module Scheduler = ServiceScheduler
module AstSharedMemory = ServiceAstSharedMemory


type analysis_results = {
  errors: Error.t list;
  lookups: Lookup.t String.Map.t;
  number_files: int;
  type_coverage: TypeCheck.Coverage.t;
}


let analyze_source
    ({ Configuration.verbose; sections; _ } as configuration)
    environment
    ({ Source.path; metadata; _ } as source) =
  (* Re-initialize log for subprocesses. *)
  Log.initialize ~verbose ~sections;

  (* Override file-specific local debug configuraiton *)
  let { Source.Metadata.autogenerated; declare; debug; strict; version; _ } = metadata in
  let configuration =
    Configuration.localize
      configuration
      ~local_debug:debug
      ~local_strict:strict
      ~declare
  in

  if version < 3 || autogenerated then
    begin
      Log.log
        ~section:`Check
        "Skipping `%s` (%s)"
        path
        (if autogenerated then "auto-generated" else "Python 2.x");
      { TypeCheck.errors = []; lookup = None; type_coverage = TypeCheck.Coverage.create_empty; }
    end
  else
    begin
      let timer = Timer.start () in
      Log.log ~section:`Check "Checking `%s`..." path;
      let errors = TypeCheck.check configuration environment source in
      Statistics.performance
        ~flush:false
        ~randomly_log_every:100
        ~section:`Check
        ~name:"SingleFileTypeCheck"
        ~timer
        ~normals:["path", path; "request kind", "SingleFileTypeCheck"]
        ~configuration
        ();
      errors
    end


let analyze_sources_parallel
    scheduler
    ({Configuration.source_root; project_root = directory; _ } as configuration)
    environment
    handles =
  let merge_lookups ~key:_ = function
    | `Both (lookup, _) -> Some lookup
    | `Left lookup -> Some lookup
    | `Right lookup -> Some lookup
  in
  let init = {
    errors = [];
    lookups = String.Map.empty;
    number_files = 0;
    type_coverage = TypeCheck.Coverage.create_empty;
  }
  in
  let handles =
    handles
    |> List.filter ~f:(fun handle ->
        match AstSharedMemory.get_source handle with
        | Some { Source.path; _ } ->
            Path.create_relative ~root:source_root ~relative:path
            |> Path.directory_contains ~follow_symlinks:true ~directory
        | _ ->
            false)
  in
  handles
  |> Scheduler.map_reduce
    scheduler
    ~init:
      {
        errors = [];
        lookups = String.Map.empty;
        number_files = 0;
        type_coverage = TypeCheck.Coverage.create_empty;
      }
    ~map:(fun _ handles ->
        let result =
          List.fold ~init ~f:(
            fun { errors; lookups; number_files; type_coverage = total_type_coverage } handle ->
              match AstSharedMemory.get_source handle with
              | Some source ->
                  let { TypeCheck.errors = new_errors; lookup; type_coverage; } =
                    analyze_source configuration environment source
                  in
                  {
                    errors = List.append new_errors errors;
                    lookups =
                      begin
                        match lookup with
                        | Some table ->
                            Map.set ~key:(File.Handle.show handle) ~data:table lookups
                        | None ->
                            lookups
                      end;
                    number_files = number_files + 1;
                    type_coverage = TypeCheck.Coverage.sum total_type_coverage type_coverage;
                  }
              | None -> {
                  errors;
                  lookups;
                  number_files = number_files + 1;
                  type_coverage = total_type_coverage;
                })
            handles
        in
        Statistics.flush ();
        result)
    ~reduce:(fun left right ->
        let number_files = left.number_files + right.number_files in
        Log.info "Processed %d of %d sources" number_files (List.length handles);
        {
          errors = List.append left.errors right.errors;
          lookups = Map.merge ~f:merge_lookups left.lookups right.lookups;
          number_files;
          type_coverage = TypeCheck.Coverage.sum left.type_coverage right.type_coverage;
        })
  |> (fun { errors; lookups; type_coverage; _ } -> (errors, lookups, type_coverage))


let analyze_sources
    scheduler
    ?(repopulate_handles = [])
    ({Configuration.source_root; project_root = directory; _ } as configuration)
    environment
    handles =
  Log.info "Checking...";
  ServiceEnvironment.repopulate
    environment
    ~configuration
    ~handles:repopulate_handles;
  match Scheduler.is_parallel scheduler with
  | true -> analyze_sources_parallel scheduler configuration environment handles
  | false ->
      let get_sources =
        List.fold
          ~init:[]
          ~f:(fun sources path ->
              match AstSharedMemory.get_source path with
              | Some ({ Source.path; _ } as source) ->
                  if Path.create_relative ~root:source_root ~relative:path
                     |> Path.directory_contains ~follow_symlinks:true ~directory then
                    source::sources
                  else
                    sources
              | _ -> sources)
      in
      let sources = get_sources handles in
      let analyze_and_postprocess
          configuration
          environment
          (current_errors, lookups, total_type_coverage)
          source =
        let { TypeCheck.errors; lookup; type_coverage; } =
          analyze_source configuration environment source
        in
        (errors :: current_errors,
         begin
           match lookup with
           | None -> lookups
           | Some lookup -> String.Map.set ~key:source.Source.path ~data:lookup lookups
         end,
         (TypeCheck.Coverage.sum total_type_coverage type_coverage))
      in
      List.fold
        ~init:([], String.Map.empty, TypeCheck.Coverage.create_empty)
        ~f:(analyze_and_postprocess configuration environment)
        sources
      |> (fun (error_list, lookups, type_coverage) ->
          List.concat error_list, lookups, type_coverage)
