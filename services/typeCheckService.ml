(** Copyright (c) 2016-present, Facebook, Inc.

    This source code is licensed under the MIT license found in the
    LICENSE file in the root directory of this source tree. *)

open Core

open Ast
open Analysis
open Pyre

module Error = PyreError


type analysis_results = {
  errors: Error.t list;
  lookups: Lookup.t String.Map.t;
  number_files: int;
  type_coverage: TypeCheck.Coverage.t;
}


let analyze_source
    ({ Configuration.verbose; sections; _ } as configuration)
    environment
    ({ Source.path; metadata; _ } as source) =
  (* Re-initialize log for subprocesses. *)
  Log.initialize ~verbose ~sections;

  (* Override file-specific local debug configuraiton *)
  let { Source.Metadata.autogenerated; declare; debug; strict; version; _ } = metadata in
  let configuration = Configuration.localize configuration ~local_debug:debug ~strict ~declare in

  if version < 3 || autogenerated then
    begin
      Log.log
        ~section:`Check
        "Skipping `%s` (%s)"
        path
        (if autogenerated then "auto-generated" else "Python 2.x");
      { TypeCheck.errors = []; lookup = None; type_coverage = TypeCheck.Coverage.create_empty; }
    end
  else
    begin
      let timer = Timer.start () in
      Log.log ~section:`Check "Checking `%s`..." path;
      let errors = TypeCheck.check configuration environment source in
      Statistics.performance
        ~flush:false
        ~randomly_log_every:100
        ~section:`Check
        ~name:"SingleFileTypeCheck"
        ~timer
        ~normals:["path", path; "request kind", "SingleFileTypeCheck"]
        ~configuration
        ();
      errors
    end


let analyze_sources_parallel
    service
    ({Configuration.source_root; project_root = directory; _ } as configuration)
    environment
    handles =
  let merge_lookups ~key:_ = function
    | `Both (lookup, _) -> Some lookup
    | `Left lookup -> Some lookup
    | `Right lookup -> Some lookup
  in
  let init = {
    errors = [];
    lookups = String.Map.empty;
    number_files = 0;
    type_coverage = TypeCheck.Coverage.create_empty;
  }
  in
  let handles =
    handles
    |> List.filter ~f:(fun handle ->
        match AstSharedMemory.get_source handle with
        | Some { Source.path; _ } ->
            Path.create_relative ~root:source_root ~relative:path
            |> Path.directory_contains ~follow_symlinks:true ~directory
        | _ ->
            false)
  in
  handles
  |> Service.map_reduce
    service
    ~init:
      {
        errors = [];
        lookups = String.Map.empty;
        number_files = 0;
        type_coverage = TypeCheck.Coverage.create_empty;
      }
    ~map:(fun _ handles ->
        let result =
          List.fold ~init ~f:(
            fun { errors; lookups; number_files; type_coverage = total_type_coverage } handle ->
              match AstSharedMemory.get_source handle with
              | Some source ->
                  let { TypeCheck.errors = new_errors; lookup; type_coverage; } =
                    analyze_source configuration environment source
                  in
                  {
                    errors = List.append new_errors errors;
                    lookups =
                      (match lookup with
                       | Some table ->
                           Map.add ~key:(File.Handle.show handle) ~data:table lookups
                       | None ->
                           lookups);
                    number_files = number_files + 1;
                    type_coverage = TypeCheck.Coverage.sum total_type_coverage type_coverage;
                  }
              | None -> {
                  errors;
                  lookups;
                  number_files = number_files + 1;
                  type_coverage = total_type_coverage;
                })
            handles
        in
        Statistics.flush ();
        result)
    ~reduce:(fun left right ->
        let number_files = left.number_files + right.number_files in
        Log.info "Processed %d of %d sources" number_files (List.length handles);
        {
          errors = List.append left.errors right.errors;
          lookups = Map.merge ~f:merge_lookups left.lookups right.lookups;
          number_files;
          type_coverage = TypeCheck.Coverage.sum left.type_coverage right.type_coverage;
        })
  |> (fun { errors; lookups; type_coverage; _ } ->
      let file_path =
        Path.get_relative_to_root ~root:directory ~path:source_root
        |> Option.value ~default:(Path.absolute source_root)
      in
      Statistics.coverage
        ~coverage:[
          "full_type_coverage", TypeCheck.Coverage.full type_coverage;
          "partial_type_coverage", TypeCheck.Coverage.partial type_coverage;
          "no_type_coverage", TypeCheck.Coverage.untyped type_coverage;
          "ignore_coverage", TypeCheck.Coverage.ignore type_coverage;
          "total_errors", List.length errors;
        ]
        ~configuration
        ~normals:[
          "file_name", file_path;
        ]
        ();
      errors, lookups)


let analyze_sources
    service
    ?(repopulate_handles = [])
    ({Configuration.source_root; project_root = directory; _ } as configuration)
    environment
    handles =
  Log.info "Checking...";
  EnvironmentService.repopulate
    environment
    ~configuration
    ~handles:repopulate_handles;
  match Service.is_parallel service with
  | true -> analyze_sources_parallel service configuration environment handles
  | false ->
      let get_sources =
        List.fold
          ~init:[]
          ~f:(fun sources path ->
              match AstSharedMemory.get_source path with
              | Some ({ Source.path; _ } as source) ->
                  if Path.create_relative ~root:source_root ~relative:path
                     |> Path.directory_contains ~follow_symlinks:true ~directory then
                    source::sources
                  else
                    sources
              | _ -> sources)
      in
      let sources = get_sources handles in
      let analyze_and_postprocess
          configuration
          environment
          (current_errors, lookups, total_type_coverage)
          source =
        let { TypeCheck.errors; lookup; type_coverage; } =
          analyze_source configuration environment source
        in
        (errors :: current_errors,
         (match lookup with
          | None -> lookups
          | Some lookup -> String.Map.add ~key:source.Source.path ~data:lookup lookups),
         (TypeCheck.Coverage.sum total_type_coverage type_coverage))
      in
      List.fold
        ~init:([], String.Map.empty, TypeCheck.Coverage.create_empty)
        ~f:(analyze_and_postprocess configuration environment)
        sources
      |> (fun (error_list, lookups, { TypeCheck.Coverage.full; partial; untyped; ignore; }) ->
          let file_path =
            Path.get_relative_to_root ~root:directory ~path:source_root
            |> Option.value ~default:(Path.absolute source_root)
          in
          Statistics.coverage
            ~coverage:[
              "full_type_coverage", full;
              "partial_type_coverage", partial;
              "no_type_coverage", untyped;
              "ignore_coverage", ignore;
              "total_errors", List.length error_list;
            ]
            ~configuration
            ~normals:[
              "file_name", file_path;
            ]
            ();
          error_list, lookups)
      |> fun (error_list, lookups) -> List.concat error_list, lookups
