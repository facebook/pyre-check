(** Copyright (c) 2016-present, Facebook, Inc.

    This source code is licensed under the MIT license found in the
    LICENSE file in the root directory of this source tree. *)

open Core

open Ast
open Analysis
open Pyre

module Error = PyreError


type analysis_results = {
  errors: Error.t list;
  lookups: Lookup.t String.Map.t;
  number_files: int;
}


let analyze_source
    ({ Configuration.verbose; sections; _ } as configuration)
    environment
    ({ Source.path; metadata; _ } as source) =
  (* Re-initialize log for subprocesses. *)
  Log.initialize ~verbose ~sections;

  (* Override file-specific local debug configuraiton *)
  let { Source.Metadata.autogenerated; declare; debug; strict; version; _ } = metadata in
  let configuration = Configuration.localize configuration ~local_debug:debug ~strict ~declare in

  if version < 3 || autogenerated then
    begin
      Log.log
        ~section:`Check
        "Skipping `%s` (%s)"
        path
        (if autogenerated then "auto-generated" else "Python 2.x");
      { TypeCheck.errors = []; lookup = None }
    end
  else
    begin
      let timer = Timer.start () in
      Log.log ~section:`Check "Checking `%s`..." path;
      let errors = TypeCheck.check configuration environment source in
      Log.log ~section:`Check "Checked `%s` in %fs" path (Timer.stop timer);
      Statistics.performance
        ~flush:false
        ~randomly_log_every:100
        ~name:"SingleFileTypeCheck"
        ~timer
        ~normals:["path", path; "RequestKind", "SingleFileTypeCheck"]
        ~configuration
        ();
      errors
    end


let analyze_sources_parallel
    service
    configuration
    environment
    handles =
  let merge_lookups ~key:_ = function
    | `Both (lookup, _) -> Some lookup
    | `Left lookup -> Some lookup
    | `Right lookup -> Some lookup
  in
  let init = { errors = []; lookups = String.Map.empty; number_files = 0 } in
  Service.map_reduce
    service
    ~init:{ errors = []; lookups = String.Map.empty; number_files = 0 }
    ~map:(fun _ handles ->
        let result =
          List.fold ~init ~f:(
            fun { errors; lookups; number_files } handle ->
              match AstSharedMemory.get_source handle with
              | Some source ->
                  let { TypeCheck.errors = new_errors; lookup } =
                    analyze_source configuration environment source
                  in
                  {
                    errors = List.append new_errors errors;
                    lookups =
                      (match lookup with
                       | Some table ->
                           Map.add ~key:(File.Handle.show handle) ~data:table lookups
                       | None ->
                           lookups);
                    number_files = number_files + 1
                  }
              | None -> { errors; lookups; number_files = number_files + 1 })
            handles
        in
        Statistics.flush ();
        result)

    ~reduce:(fun left right ->
        let number_files = left.number_files + right.number_files in
        Log.info "Processed %d of %d sources" number_files (List.length handles);
        {
          errors = List.append left.errors right.errors;
          lookups = Map.merge ~f:merge_lookups left.lookups right.lookups;
          number_files;
        })
    handles
  |> (fun { errors; lookups; _ } -> errors, lookups)


let analyze_sources
    service
    ?(repopulate_handles = [])
    ({Configuration.project_root; _ } as configuration)
    environment
    handles =
  Log.info "Checking...";
  EnvironmentService.repopulate
    environment
    ~root:project_root
    ~handles:repopulate_handles;
  match Service.is_parallel service with
  | true -> analyze_sources_parallel service configuration environment handles
  | false ->
      let get_sources =
        List.fold
          ~init:[]
          ~f:(fun sources path ->
              match AstSharedMemory.get_source path with
              | Some source -> source::sources
              | None -> sources)
      in
      let sources = get_sources handles in
      let analyze_and_postprocess configuration environment (current_errors, lookups) source =
        let { TypeCheck.errors; lookup } = analyze_source configuration environment source in
        errors :: current_errors,
        (match lookup with
         | None -> lookups
         | Some lookup -> String.Map.add ~key:source.Source.path ~data:lookup lookups)
      in
      List.fold
        ~init:([], String.Map.empty)
        ~f:(analyze_and_postprocess configuration environment)
        sources
      |> fun (error_list, lookups) -> List.concat error_list, lookups
