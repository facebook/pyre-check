(*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *)

open Core
open Pyre
open Ast
open Analysis
open Expression

module Global = struct
  type t =
    | Class
    | Module
    | Attribute of Type.t
  [@@deriving show]
end

(* Resolve global symbols, ignoring decorators. *)
let resolve_global ~resolution name =
  let global_resolution = Resolution.global_resolution resolution in
  match GlobalResolution.global global_resolution name with
  | Some { AttributeResolution.Global.undecorated_signature = Some signature; _ } ->
      Some (Global.Attribute (Type.Callable signature))
  | _ -> (
      let annotation =
        from_reference name ~location:Location.any
        |> Resolution.resolve_expression_to_annotation resolution
      in
      match Annotation.annotation annotation with
      | Type.Parametric { name = "type"; _ }
        when GlobalResolution.class_exists global_resolution (Reference.show name) ->
          Some Global.Class
      | Type.Top when GlobalResolution.module_exists global_resolution name -> Some Global.Module
      | Type.Top when not (Annotation.is_immutable annotation) ->
          (* FIXME: We are relying on the fact that nonexistent functions & attributes resolve to
             mutable annotation, while existing ones resolve to immutable annotation. This is
             fragile! *)
          None
      | annotation -> Some (Global.Attribute annotation) )


type parameter_requirements = {
  anonymous_parameters_count: int;
  parameter_set: String.Set.t;
  has_star_parameter: bool;
  has_star_star_parameter: bool;
}

let create_parameters_requirements ~type_parameters =
  let get_parameters_requirements requirements type_parameter =
    let open Type.Callable.RecordParameter in
    match type_parameter with
    | PositionalOnly _ ->
        {
          requirements with
          anonymous_parameters_count = requirements.anonymous_parameters_count + 1;
        }
    | Named { name; _ }
    | KeywordOnly { name; _ } ->
        let name = Identifier.sanitized name in
        { requirements with parameter_set = String.Set.add requirements.parameter_set name }
    | Variable _ -> { requirements with has_star_parameter = true }
    | Keywords _ -> { requirements with has_star_star_parameter = true }
  in
  let init =
    {
      anonymous_parameters_count = 0;
      parameter_set = String.Set.empty;
      has_star_parameter = false;
      has_star_star_parameter = false;
    }
  in
  List.fold_left type_parameters ~f:get_parameters_requirements ~init


let demangle_class_attribute name =
  if String.is_substring ~substring:"__class__" name then
    String.split name ~on:'.'
    |> List.rev
    |> function
    | attribute :: "__class__" :: rest -> List.rev (attribute :: rest) |> String.concat ~sep:"."
    | _ -> name
  else
    name


let model_verification_error ~path ~location kind =
  { ModelVerificationError.T.kind; path; location }


let model_compatible
    ~path
    ~location
    ~callable_name
    ~callable_type
    ~type_parameters
    ~normalized_model_parameters
  =
  let open Result in
  let parameter_requirements = create_parameters_requirements ~type_parameters in
  (* Once a requirement has been satisfied, it is removed from requirement object. At the end, we
     check whether there remains unsatisfied requirements. *)
  let validate_model_parameter errors_and_requirements (model_parameter, _, original) =
    (* Ensure that the parameter's default value is either not present or `...` to catch common
       errors when declaring models. *)
    let errors_and_requirements =
      match Node.value original with
      | { Parameter.value = Some expression; name; _ } ->
          if not (Expression.equal_expression (Node.value expression) Expression.Ellipsis) then
            Error
              (model_verification_error
                 ~path
                 ~location
                 (InvalidDefaultValue { callable_name; name; expression }))
          else
            errors_and_requirements
      | _ -> errors_and_requirements
    in
    let open AccessPath.Root in
    let open ModelVerificationError.T in
    errors_and_requirements
    >>| fun (errors, requirements) ->
    match model_parameter with
    | LocalResult
    | Variable _ ->
        failwith
          ( "LocalResult|Variable won't be generated by AccessPath.Root.normalize_parameters, "
          ^ "and they cannot be compared with type_parameters." )
    | PositionalParameter { name; positional_only = true; _ } ->
        let { anonymous_parameters_count; _ } = requirements in
        if anonymous_parameters_count >= 1 then
          errors, { requirements with anonymous_parameters_count = anonymous_parameters_count - 1 }
        else
          UnexpectedPositionalOnlyParameter name :: errors, requirements
    | PositionalParameter { name; _ }
    | NamedParameter { name } ->
        let name = Identifier.sanitized name in
        if String.is_prefix name ~prefix:"__" then (* It is an positional only parameter. *)
          let { anonymous_parameters_count; has_star_parameter; _ } = requirements in
          if anonymous_parameters_count >= 1 then
            ( errors,
              { requirements with anonymous_parameters_count = anonymous_parameters_count - 1 } )
          else if has_star_parameter then
            (* If all positional only parameter quota is used, it might be covered by a `*args` *)
            errors, requirements
          else
            UnexpectedPositionalOnlyParameter name :: errors, requirements
        else
          let { parameter_set; has_star_parameter; has_star_star_parameter; _ } = requirements in
          (* Consume an required or optional named parameter. *)
          if String.Set.mem parameter_set name then
            let parameter_set = String.Set.remove parameter_set name in
            errors, { requirements with parameter_set }
          else if has_star_star_parameter then
            (* If the name is not found in the set, it is covered by `**kwargs` *)
            errors, requirements
          else if has_star_parameter then (* positional parameters can be covered by `*args` *)
            match model_parameter with
            | PositionalParameter _ -> errors, requirements
            | _ -> UnexpectedNamedParameter name :: errors, requirements
          else
            UnexpectedNamedParameter name :: errors, requirements
    | StarParameter _ ->
        if requirements.has_star_parameter then
          errors, requirements
        else
          UnexpectedStarredParameter :: errors, requirements
    | StarStarParameter _ ->
        if requirements.has_star_star_parameter then
          errors, requirements
        else
          UnexpectedDoubleStarredParameter :: errors, requirements
  in
  let errors_and_requirements =
    List.fold_left
      normalized_model_parameters
      ~f:validate_model_parameter
      ~init:(Result.Ok ([], parameter_requirements))
  in
  errors_and_requirements
  >>= fun (errors, _) ->
  if List.is_empty errors then
    Result.Ok ()
  else
    Result.Error
      (model_verification_error
         ~path
         ~location
         (IncompatibleModelError { name = callable_name; callable_type; reasons = errors }))


let verify_signature ~path ~location ~normalized_model_parameters ~name callable_annotation =
  match callable_annotation with
  | Some
      ( {
          Type.Callable.implementation =
            { Type.Callable.parameters = Type.Callable.Defined implementation_parameters; _ };
          kind;
          _;
        } as callable ) -> (
      match kind with
      | Type.Callable.Named actual_name when not (Reference.equal name actual_name) ->
          Error
            (model_verification_error ~path ~location (ImportedFunctionModel { name; actual_name }))
      | _ ->
          model_compatible
            ~path
            ~location
            ~callable_name:(Reference.show name)
            ~callable_type:callable
            ~type_parameters:implementation_parameters
            ~normalized_model_parameters )
  | _ -> Result.Ok ()


let verify_global ~path ~location ~resolution ~name =
  let name = demangle_class_attribute (Reference.show name) |> Reference.create in
  let global_resolution = Resolution.global_resolution resolution in
  let global = GlobalResolution.global global_resolution name in
  if Option.is_some global then
    Result.Ok ()
  else
    let class_summary, attribute_name =
      ( Reference.as_list name
        |> List.drop_last
        >>| Reference.create_from_list
        >>| Reference.show
        >>| (fun class_name -> Type.Primitive class_name)
        >>= GlobalResolution.class_definition global_resolution
        >>| Node.value,
        Reference.last name )
    in
    match class_summary with
    | Some { ClassSummary.attribute_components; name = class_name; _ } ->
        let attributes, constructor_attributes =
          ( ClassSummary.ClassAttributes.attributes
              ~include_generated_attributes:false
              attribute_components,
            ClassSummary.ClassAttributes.constructor_attributes attribute_components )
        in
        if
          Identifier.SerializableMap.mem attribute_name attributes
          || Identifier.SerializableMap.mem attribute_name constructor_attributes
        then
          Result.Ok ()
        else
          Result.Error
            (model_verification_error
               ~path
               ~location
               (MissingAttribute { class_name = Reference.show class_name; attribute_name }))
    | _ ->
        Result.Error
          (model_verification_error ~path ~location (NotInEnvironment (Reference.show name)))
