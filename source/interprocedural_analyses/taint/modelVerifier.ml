(*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *)

(* ModelVerifier: implements additional validation for model files. *)

open Core
open Pyre
open Ast
open Expression
module PyrePysaApi = Interprocedural.PyrePysaApi
module PyrePysaLogic = Analysis.PyrePysaLogic
module AccessPath = Interprocedural.AccessPath

type parameter_requirements = {
  anonymous_parameters_positions: Int.Set.t;
  parameter_set: String.Set.t;
  has_star_parameter: bool;
  has_star_star_parameter: bool;
}

let create_parameters_requirements ~type_parameters =
  let get_parameters_requirements requirements type_parameter =
    let open Type.Callable.CallableParamType in
    match type_parameter with
    | PositionalOnly { index; _ } ->
        {
          requirements with
          anonymous_parameters_positions = Set.add requirements.anonymous_parameters_positions index;
        }
    | Named { name; _ }
    | KeywordOnly { name; _ } ->
        let name = Identifier.sanitized name in
        { requirements with parameter_set = Set.add requirements.parameter_set name }
    | Variable _ -> { requirements with has_star_parameter = true }
    | Keywords _ -> { requirements with has_star_star_parameter = true }
  in
  let init =
    {
      anonymous_parameters_positions = Int.Set.empty;
      parameter_set = String.Set.empty;
      has_star_parameter = false;
      has_star_star_parameter = false;
    }
  in
  List.fold_left type_parameters ~f:get_parameters_requirements ~init


let demangle_class_attribute name =
  if String.is_substring ~substring:"__class__" name then
    String.split name ~on:'.'
    |> List.rev
    |> function
    | attribute :: "__class__" :: rest -> List.rev (attribute :: rest) |> String.concat ~sep:"."
    | _ -> name
  else
    name


let model_verification_error ~path ~location kind = { ModelVerificationError.kind; path; location }

let verify_model_syntax ~path ~location ~callable_name ~normalized_model_parameters =
  (* Ensure that the parameter's default value is either not present or `...` to catch common errors
     when declaring models. *)
  let check_default_value { AccessPath.NormalizedParameter.original; _ } =
    match Node.value original with
    | { Parameter.value = None; _ }
    | { Parameter.value = Some { Node.value = Expression.Constant Constant.Ellipsis; _ }; _ } ->
        None
    | { Parameter.value = Some expression; name; _ } ->
        Some
          (model_verification_error
             ~path
             ~location
             (InvalidDefaultValue { callable_name = Reference.show callable_name; name; expression }))
  in
  List.find_map normalized_model_parameters ~f:check_default_value
  |> function
  | Some error -> Error error
  | None -> Ok ()


let verify_imported_model ~path ~location ~callable_name ~callable_annotation =
  match callable_annotation with
  | Some { Type.Callable.kind = Type.Callable.Named actual_name; _ }
    when not (Reference.equal callable_name actual_name) ->
      Error
        (model_verification_error
           ~path
           ~location
           (ImportedFunctionModel { name = callable_name; actual_name }))
  | _ -> Ok ()


let model_compatible_errors ~callable_overload ~normalized_model_parameters =
  let open ModelVerificationError in
  (* Once a requirement has been satisfied, it is removed from requirement object. At the end, we
     check whether there remains unsatisfied requirements. *)
  let validate_model_parameter
      position
      (errors, requirements)
      { AccessPath.NormalizedParameter.root = model_parameter; _ }
    =
    let open AccessPath.Root in
    match model_parameter with
    | LocalResult
    | Variable _
    | CapturedVariable _ ->
        failwith
          "LocalResult|Variable|CapturedVariable won't be generated by \
           AccessPath.Root.normalize_parameters, and they cannot be compared with type_parameters."
    | PositionalParameter { name; positional_only = true; _ } ->
        if Core.Set.mem requirements.anonymous_parameters_positions position then
          errors, requirements
        else if requirements.has_star_parameter then
          (* If all positional only parameter quota is used, it might be covered by a `*args` *)
          errors, requirements
        else
          ( IncompatibleModelError.UnexpectedPositionalOnlyParameter
              {
                name;
                position;
                valid_positions = Core.Set.elements requirements.anonymous_parameters_positions;
              }
            :: errors,
            requirements )
    | PositionalParameter { name; positional_only = false; _ }
    | NamedParameter { name } ->
        let name = Identifier.sanitized name in
        let { parameter_set; has_star_parameter; has_star_star_parameter; _ } = requirements in
        (* Consume an required or optional named parameter. *)
        if Core.Set.mem parameter_set name then
          let parameter_set = Core.Set.remove parameter_set name in
          errors, { requirements with parameter_set }
        else if has_star_star_parameter then
          (* If the name is not found in the set, it is covered by `**kwargs` *)
          errors, requirements
        else if has_star_parameter then (* positional parameters can be covered by `*args` *)
          match model_parameter with
          | PositionalParameter _ -> errors, requirements
          | _ -> UnexpectedNamedParameter name :: errors, requirements
        else
          IncompatibleModelError.UnexpectedNamedParameter name :: errors, requirements
    | StarParameter _ ->
        if requirements.has_star_parameter then
          errors, requirements
        else
          IncompatibleModelError.UnexpectedStarredParameter :: errors, requirements
    | StarStarParameter _ ->
        if requirements.has_star_star_parameter then
          errors, requirements
        else
          IncompatibleModelError.UnexpectedDoubleStarredParameter :: errors, requirements
  in
  match callable_overload with
  | { Type.Callable.parameters = Type.Callable.Defined type_parameters; _ } ->
      let parameter_requirements = create_parameters_requirements ~type_parameters in
      let errors, _ =
        List.foldi
          normalized_model_parameters
          ~f:validate_model_parameter
          ~init:([], parameter_requirements)
      in
      List.map
        ~f:(fun reason -> { IncompatibleModelError.reason; overload = Some callable_overload })
        errors
  | _ -> []


let verify_signature
    ~path
    ~location
    ~normalized_model_parameters
    ~name:callable_name
    callable_annotation
  =
  let open Result in
  verify_model_syntax ~path ~location ~callable_name ~normalized_model_parameters
  >>= fun () ->
  verify_imported_model ~path ~location ~callable_name ~callable_annotation
  >>= fun () ->
  match callable_annotation with
  | Some ({ Type.Callable.implementation; overloads; _ } as callable) ->
      let errors =
        model_compatible_errors ~callable_overload:implementation ~normalized_model_parameters
      in
      let errors =
        if (not (List.is_empty errors)) && not (List.is_empty overloads) then
          (* We might be referring to a parameter defined in an overload. *)
          let errors_in_overloads =
            List.map overloads ~f:(fun callable_overload ->
                model_compatible_errors ~callable_overload ~normalized_model_parameters)
          in
          if List.find ~f:List.is_empty errors_in_overloads |> Option.is_some then
            []
          else
            errors @ List.concat errors_in_overloads
        else
          List.map ~f:ModelVerificationError.IncompatibleModelError.strip_overload errors
      in
      if not (List.is_empty errors) then
        Error
          (model_verification_error
             ~path
             ~location
             (IncompatibleModelError
                { name = Reference.show callable_name; callable_type = callable; errors }))
      else
        Ok ()
  | _ -> Ok ()


let verify_global ~path ~location ~pyre_api ~name =
  let name = demangle_class_attribute (Reference.show name) |> Reference.create in
  let global = PyrePysaApi.ModelQueries.resolve_qualified_name_to_global pyre_api name in
  match global with
  | Some PyrePysaApi.ModelQueries.Global.Class ->
      Error
        (model_verification_error ~path ~location (ModelingClassAsAttribute (Reference.show name)))
  | Some PyrePysaApi.ModelQueries.Global.Module ->
      Error
        (model_verification_error ~path ~location (ModelingModuleAsAttribute (Reference.show name)))
  | Some (PyrePysaApi.ModelQueries.Global.Function _) ->
      Error
        (model_verification_error
           ~path
           ~location
           (ModelingCallableAsAttribute (Reference.show name)))
  | Some PyrePysaApi.ModelQueries.Global.Attribute
  | Some PyrePysaApi.ModelQueries.Global.UnknownAttribute
  | None -> (
      let class_summary =
        Reference.prefix name
        >>| Reference.show
        >>= PyrePysaApi.ReadOnly.get_class_summary pyre_api
        >>| Node.value
      in
      match class_summary, global with
      | Some ({ name = class_name; _ } as class_summary), _ ->
          let attributes =
            PyrePysaLogic.ClassSummary.attributes ~include_generated_attributes:false class_summary
          in
          let constructor_attributes =
            PyrePysaLogic.ClassSummary.constructor_attributes class_summary
          in
          let attribute_name = Reference.last name in
          if
            Identifier.SerializableMap.mem attribute_name attributes
            || Identifier.SerializableMap.mem attribute_name constructor_attributes
          then
            Ok ()
          else
            Error
              (model_verification_error
                 ~path
                 ~location
                 (MissingAttribute
                    { class_name = Reference.show class_name; attribute_name = Reference.last name }))
      | None, Some _ -> Ok ()
      | None, None -> (
          let module_name = Reference.first name in
          let module_resolved =
            PyrePysaApi.ModelQueries.resolve_qualified_name_to_global
              pyre_api
              (Reference.create module_name)
          in
          match module_resolved with
          | Some _ ->
              Error
                (model_verification_error
                   ~path
                   ~location
                   (MissingSymbol { module_name; symbol_name = Reference.show name }))
          | None ->
              Error
                (model_verification_error
                   ~path
                   ~location
                   (NotInEnvironment { module_name; name = Reference.show name }))))
