@SkipObscure
def typing.cast(typ, val: TaintInTaintOut[LocalReturn, NoCollapse]): ...

@SkipObscure
def copy.copy(x: TaintInTaintOut[LocalReturn, NoCollapse]): ...

@SkipObscure
def copy.deepcopy(x: TaintInTaintOut[LocalReturn, NoCollapse]): ...

class enumerate(SkipOverrides): ...

@SkipObscure
def enumerate.__new__(cls, iterable: TaintInTaintOut[LocalReturn, ParameterPath[_.all()], ReturnPath[_.all()[1]], NoCollapse]): ...

@SkipObscure
def sorted(__iterable: TaintInTaintOut[LocalReturn, ParameterPath[_.all()], ReturnPath[_.all()], NoCollapse]): ...
def sorted(__iterable: TaintInTaintOut[LocalReturn, ParameterPath[_.keys()], ReturnPath[_.all()], NoCollapse]): ...

class reversed(SkipOverrides): ...

@SkipObscure
def reversed.__new__(cls, sequence: TaintInTaintOut[LocalReturn, ParameterPath[_.all()], ReturnPath[_.all()], NoCollapse], /): ...
def reversed.__new__(cls, sequence: TaintInTaintOut[LocalReturn, ParameterPath[_.keys()], ReturnPath[_.all()], NoCollapse], /): ...

# There is no way to model `map` properly, we keep it obscure.

class filter(SkipOverrides): ...

@SkipObscure
def filter.__new__(cls, function, iterable: TaintInTaintOut[LocalReturn, ParameterPath[_.all()], ReturnPath[_.all()], NoCollapse], /): ...
def filter.__new__(cls, function, iterable: TaintInTaintOut[LocalReturn, ParameterPath[_.keys()], ReturnPath[_.all()], NoCollapse], /): ...

# `iter()` with a single argument is hardcoded in the analysis.
# `iter()` with two arguments is hard to model, so we keep it obscure.

# `next()` with a single argument is hardcoded in the analysis.
@SkipObscure
def next(__i: TaintInTaintOut[Collapse], __default: TaintInTaintOut[LocalReturn, NoCollapse]): ...

# Don't propagate taint through .__class__
@SkipObscure
@Sanitize
@property
def object.__class__(): ...
